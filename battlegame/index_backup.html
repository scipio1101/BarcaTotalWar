<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·´å¡ï¼šå…¨é¢æˆ˜äº‰ï¼ˆä¼šæˆ˜ç•Œé¢ï¼‰</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a252f 0%, #2c3e50 50%, #34495e 100%);
            color: white;
            min-height: 100vh;
            overflow-x: auto;
        }

        .game-container {
            max-width: 100%;
            margin: 0;
            padding: 10px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-game-layout {
            display: flex;
            gap: 15px;
            flex: 1;
            align-items: stretch;
            height: 840px;
            min-height: 840px;
            max-height: 840px;
            max-width: 100vw;
        }

        .game-header {
            text-align: center;
            margin-bottom: 10px;
            padding: 8px 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .game-header h2 {
            margin: 0;
            padding: 0;
            font-size: 1.2em;
        }

        .game-title {
            font-size: 2em;
            margin: 0 0 5px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            background: linear-gradient(45deg, #e74c3c, #f39c12, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .phase-bar {
            text-align: center;
            margin-bottom: 15px;
            padding: 12px 20px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(155, 89, 182, 0.3));
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .phase-bar .current-player-info {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .phase-bar .phase-info {
            font-size: 1.2em;
            opacity: 0.95;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .game-info {
            width: 350px;
            min-width: 320px;
            max-width: 25vw;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: 840px;
            min-height: 840px;
            max-height: 840px;
            overflow-y: auto;
        }

        .current-player {
            font-size: 1.8em;
            font-weight: bold;
            text-align: center;
            padding: 10px 20px;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }

        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .rome {
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .carthage {
            color: #3498db;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .game-board {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-radius: 20px;
            box-shadow: inset 0 4px 20px rgba(0,0,0,0.3);
            height: 840px;
            min-height: 840px;
            max-height: 840px;
            overflow: auto;
        }

        .square-grid {
            position: relative;
            display: inline-block;
            padding: 20px;
            width: 1640px;
            height: 820px;
            overflow: visible;
            max-width: calc(100% - 40px);
            max-height: calc(100% - 40px);
        }

        .square {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #27ae60;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .square:hover {
            background: #2ecc71;
            z-index: 5;
        }

        .square.selected {
            background: #f39c12 !important;
            z-index: 50;
            box-shadow: 0 0 8px rgba(243, 156, 18, 0.6);
        }

        .square.possible-move {
            background: #3498db !important;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
            z-index: 10;
        }

        .square.target-selected {
            background: #9b59b6 !important;
            animation: targetPulse 1s infinite;
            box-shadow: 0 0 8px rgba(155, 89, 182, 0.6);
            z-index: 50;
        }

        .unit-large {
            position: absolute;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            z-index: 15;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @keyframes targetPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(155, 89, 182, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(155, 89, 182, 1);
            }
        }

        .damage-popup {
            position: absolute;
            z-index: 20;
            font-size: 20px;
            font-weight: bold;
            color: #e74c3c;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: damageFloat 2s ease-out forwards;
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        .explosion-effect {
            position: absolute;
            z-index: 15;
            pointer-events: none;
            font-size: 30px;
            animation: explosion 1s ease-out forwards;
        }

        @keyframes explosion {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes missFloat {
            0% {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateX(-50%) translateY(-20px) scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: translateX(-50%) translateY(-40px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes missEffect {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0.7;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0.4;
            }
            100% {
                transform: translate(-50%, -50%) scale(2.5);
                opacity: 0;
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-3px);
            }
            75% {
                transform: translateX(3px);
            }
        }
        
        @keyframes collision {
            0% { background-color: rgba(255, 0, 0, 0.8); transform: scale(1); }
            50% { background-color: rgba(255, 255, 0, 0.8); transform: scale(1.1); }
            100% { background-color: rgba(255, 0, 0, 0.8); transform: scale(1); }
        }
        
        .collision-effect {
            animation: collision 0.6s ease-in-out;
            z-index: 1000;
        }
        
        /* ç§»åŠ¨åŠ¨ç”» */
        .unit-moving {
            transition: left 0.8s ease-in-out, top 0.8s ease-in-out;
            z-index: 1000;
        }
        
        /* è§„åˆ’é˜¶æ®µå ä½æ˜¾ç¤º */
        .planned-occupation {
            position: absolute;
            border: 2px dashed;
            background: rgba(255, 255, 255, 0.3);
            z-index: 100;
            pointer-events: none;
        }
        
        .planned-occupation.rome {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.2);
        }
        
        .planned-occupation.carthage {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.2);
        }
        
        .planned-occupation.step-0 {
            opacity: 1.0;
            z-index: 130;
            border-style: solid;
        }
        
        .planned-occupation.step-1 {
            opacity: 0.8;
            z-index: 120;
        }
        
        .planned-occupation.step-2 {
            opacity: 0.6;
            z-index: 110;
        }
        
        .planned-occupation.step-3 {
            opacity: 0.4;
            z-index: 105;
        }

        .move-path {
            position: absolute;
            z-index: 200;
            pointer-events: none;
        }

        .move-arrow {
            position: absolute;
            height: 2px;
            background: rgba(241, 196, 15, 0.8);
            transform-origin: left center;
            z-index: 200;
            pointer-events: none;
            border-radius: 1px;
        }

        .move-arrow::after {
            content: '';
            position: absolute;
            right: -8px;
            top: -3px;
            width: 0;
            height: 0;
            border-left: 8px solid var(--arrow-color, rgba(241, 196, 15, 0.8));
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
        }

        .step-number {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #f39c12;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            z-index: 210;
            border: 2px solid white;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
        }

        .hex.attack-target {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #a93226;
            animation: attackPulse 1s infinite;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.6);
        }

        @keyframes attackPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.6);
            }
            50% {
                box-shadow: 0 0 30px rgba(231, 76, 60, 1);
            }
        }

        @keyframes impactFlash {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* éƒ¨ç½²åŒºåŸŸæ ·å¼ */
        .deployment-zone-rome {
            background: rgba(231, 76, 60, 0.15) !important;
            border: 1px dashed rgba(231, 76, 60, 0.4);
        }

        .deployment-zone-carthage {
            background: rgba(52, 152, 219, 0.15) !important;
            border: 1px dashed rgba(52, 152, 219, 0.4);
        }

        .deployment-zone-active {
            background: rgba(241, 196, 15, 0.2) !important;
            border: 1px solid rgba(241, 196, 15, 0.6);
            animation: deploymentPulse 2s infinite;
        }

        @keyframes deploymentPulse {
            0%, 100% {
                background: rgba(241, 196, 15, 0.2) !important;
            }
            50% {
                background: rgba(241, 196, 15, 0.3) !important;
            }
        }

        .unit-large:hover {
            transform: scale(1.05) translateZ(0);
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
        }

        .unit-large.rome {
            background: radial-gradient(circle, #e74c3c, #c0392b);
            border-color: #fff;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4), 0 0 15px rgba(231, 76, 60, 0.3);
        }
        
        .unit-large.rome.image-unit {
            background: transparent;
            box-shadow: none;
        }

        .unit-large.carthage {
            background: radial-gradient(circle, #3498db, #2980b9);
            border-color: #fff;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4), 0 0 15px rgba(52, 152, 219, 0.3);
        }

        .unit-large.selected {
            box-shadow: 0 0 20px rgba(255,255,255,1), 0 0 30px rgba(255,255,255,0.6);
            transform: scale(1.05) translateZ(0);
            border-color: #f1c40f;
            animation: selectedGlow 1.5s infinite;
        }

        /* å¯è¢«æ·»åŠ çš„æ”¯æ´å•ä½ - ç´«è‰²æ¡†è„‰å†² */
        .unit-large.support-available {
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.8);
            border: 3px solid #9b59b6;
            animation: purplePulse 2s infinite;
        }
        
        /* å·²æ·»åŠ çš„æ”¯æ´å•ä½ - é»„è‰²æ¡†+æ”¾å¤§ */
        .unit-large.support-selected {
            box-shadow: 0 0 20px rgba(241, 196, 15, 1);
            border: 3px solid #f1c40f;
            transform: scale(1.08);
        }
        
        /* å¯è¢«é€‰æ‹©çš„æ”»å‡»ç›®æ ‡ - ç´«è‰²æ¡†è„‰å†² */
        .unit-large.target-available {
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.8);
            border: 3px solid #9b59b6;
            animation: purplePulse 2s infinite;
        }
        
        /* å·²é€‰æ‹©çš„æ”»å‡»ç›®æ ‡ - é»„è‰²æ¡†+æ”¾å¤§ */
        .unit-large.target-selected {
            box-shadow: 0 0 20px rgba(241, 196, 15, 1);
            border: 3px solid #f1c40f;
            transform: scale(1.08);
        }
        
        /* ç´«è‰²è„‰å†²åŠ¨ç”» - ç”¨äºæ‰€æœ‰å¯é€‰é¡¹ */
        @keyframes purplePulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(155, 89, 182, 0.6);
                border-color: #9b59b6;
            }
            50% {
                box-shadow: 0 0 25px rgba(155, 89, 182, 1);
                border-color: #8e44ad;
            }
        }

        @keyframes selectedGlow {
            0%, 100% {
                box-shadow: 0 0 25px rgba(255,255,255,1), 0 0 35px rgba(255,255,255,0.6);
            }
            50% {
                box-shadow: 0 0 35px rgba(255,255,255,1), 0 0 45px rgba(255,255,255,0.8);
            }
        }

        /* è¿‘æˆ˜å†²é”‹åŠ¨ç”» */
        @keyframes chargeForward {
            0% { transform: translate(0, 0) scale(1); }
            30% { transform: translate(var(--charge-x), var(--charge-y)) scale(1.15); }
            50% { transform: translate(var(--charge-x), var(--charge-y)) scale(1.2); }
            70% { transform: translate(var(--charge-x), var(--charge-y)) scale(1.15); }
            100% { transform: translate(0, 0) scale(1); }
        }

        /* æ–©å‡»è½¨è¿¹åŠ¨ç”» */
        @keyframes slashEffect {
            0% { 
                transform: translate(-50%, -50%) scale(0) rotate(-45deg);
                opacity: 0;
            }
            30% { 
                transform: translate(-50%, -50%) scale(1.2) rotate(15deg);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(2) rotate(45deg);
                opacity: 0;
            }
        }

        /* å†²å‡»æ³¢æ•ˆæœ */
        @keyframes shockwave {
            0% { 
                transform: translate(-50%, -50%) scale(0);
                opacity: 0.8;
            }
            100% { 
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
            }
        }

        /* å—å‡»é—ªçº¢ */
        @keyframes hitFlash {
            0%, 100% { 
                filter: brightness(1);
                background-color: transparent;
            }
            25%, 75% { 
                filter: brightness(1.5) hue-rotate(-20deg);
                background-color: rgba(255, 0, 0, 0.3);
            }
            50% { 
                filter: brightness(2) hue-rotate(-40deg);
                background-color: rgba(255, 0, 0, 0.5);
            }
        }

        /* æ”»å‡»è€…å‰å€¾åŠ¨ä½œ */
        @keyframes attackLunge {
            0%, 100% { transform: scale(1) translateY(0); }
            40% { transform: scale(1.1) translateY(-5px); }
            60% { transform: scale(1.15) translateY(-3px); }
        }

        /* åé€€æ•ˆæœ */
        @keyframes recoil {
            0% { transform: translate(0, 0); }
            30% { transform: translate(var(--recoil-x), var(--recoil-y)); }
            100% { transform: translate(0, 0); }
        }

        /* å¢å¼ºä¼¤å®³æ•°å­— - æš´å‡» */
        @keyframes criticalDamage {
            0% {
                transform: translate(-50%, 0) scale(1) rotate(-10deg);
                opacity: 1;
                color: #ff3333;
            }
            20% {
                transform: translate(-50%, -15px) scale(1.8) rotate(5deg);
                color: #ff0000;
            }
            40% {
                transform: translate(-50%, -25px) scale(1.6) rotate(-5deg);
            }
            100% {
                transform: translate(-50%, -80px) scale(2.5) rotate(0deg);
                opacity: 0;
                color: #ffff00;
            }
        }

        /* è¿å‡»æ•°å­— */
        @keyframes comboEffect {
            0% {
                transform: translate(-50%, 0) scale(0.5);
                opacity: 0;
            }
            30% {
                transform: translate(-50%, -20px) scale(1.3);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -60px) scale(1);
                opacity: 0;
            }
        }

        /* å…‰èŠ’çˆ†å‘ */
        @keyframes radialBurst {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                transform: translate(-50%, -50%) scale(4) rotate(180deg);
                opacity: 0;
            }
        }

        .unit-large.has-moved {
            /* ç§»åŠ¨åæ ·å¼ä¸ç§»åŠ¨å‰ä¿æŒç›¸åŒ */
            /* opacity: 0.7; */
            /* filter: grayscale(30%); */
        }

        .controls {
            text-align: center;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            background: linear-gradient(135deg, #2980b9, #1f4e79);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: linear-gradient(135deg, #7f8c8d, #5d6d7e);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .unit-info {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .faction-stats {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
        }

        .faction-stats.rome {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        .faction-stats.carthage {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.1);
        }

        .square-grid-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(0,0,0,0.1) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(0,0,0,0.1) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(0,0,0,0.1) 75%);
            background-size: 20px 20px;
            border-radius: 10px;
            z-index: -1;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1400px) {
            .game-info {
                width: 300px;
                min-width: 280px;
                padding: 12px;
                gap: 10px;
            }
            
            .main-game-layout {
                gap: 10px;
            }
            
            .game-container {
                padding: 5px;
            }
            
            .game-header {
                padding: 6px 12px;
                margin-bottom: 8px;
            }
            
            .game-title {
                font-size: 1.8em;
                margin-bottom: 4px;
            }
            
            .game-header h2 {
                font-size: 1.1em;
            }
            
            .phase-bar {
                padding: 10px 15px;
            }
            
            .phase-bar .current-player-info {
                font-size: 1.3em;
                margin-bottom: 6px;
            }
            
            .phase-bar .phase-info {
                font-size: 1.1em;
            }
        }

        @media (max-width: 1200px) {
            .main-game-layout {
                flex-direction: column;
                gap: 15px;
                height: auto;
                min-height: auto;
                max-height: none;
            }
            
            .game-info {
                width: 100%;
                max-width: none;
                height: auto;
                min-height: auto;
                max-height: none;
            }
            
            .game-board {
                height: 600px;
                min-height: 600px;
                max-height: 600px;
            }
            
            .game-header {
                padding: 5px 10px;
                margin-bottom: 6px;
            }
            
            .game-title {
                font-size: 1.5em;
                margin-bottom: 3px;
            }
            
            .game-header h2 {
                font-size: 1em;
            }
            
            .phase-bar {
                padding: 8px 12px;
                margin-bottom: 10px;
            }
            
            .phase-bar .current-player-info {
                font-size: 1.2em;
            }
            
            .phase-bar .phase-info {
                font-size: 1em;
            }
        }

        /* èƒœè´Ÿç»“ç®—å¼¹çª—æ ·å¼ */
        .victory-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            animation: fadeIn 0.5s ease-out;
        }

        .victory-modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .victory-modal-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 20px;
            padding: 0;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.6s ease-out;
            overflow: hidden;
            border: 3px solid rgba(255, 215, 0, 0.5);
        }

        .victory-banner {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.2) 100%);
            padding: 40px 20px;
            text-align: center;
            border-bottom: 3px solid rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .victory-banner::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            animation: rotate 10s linear infinite;
        }

        .victory-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }

        .victory-title {
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 
                3px 3px 6px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 215, 0, 0.6),
                0 0 40px rgba(255, 215, 0, 0.4);
            margin: 0;
            position: relative;
            z-index: 1;
        }

        .victory-details {
            padding: 30px;
            color: white;
        }

        .victory-details h2 {
            text-align: center;
            font-size: 28px;
            color: #ffd700;
            margin: 0 0 25px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
        }

        .faction-result {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .result-row:hover {
            transform: scale(1.02);
        }

        .rome-result {
            background: linear-gradient(90deg, rgba(231, 76, 60, 0.3) 0%, rgba(192, 57, 43, 0.3) 100%);
            border-left: 5px solid #e74c3c;
        }

        .carthage-result {
            background: linear-gradient(90deg, rgba(52, 152, 219, 0.3) 0%, rgba(41, 128, 185, 0.3) 100%);
            border-left: 5px solid #3498db;
        }

        .faction-name {
            font-size: 24px;
        }

        .faction-score {
            font-size: 22px;
            color: #ffd700;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        .victory-message {
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ecf0f1;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffd700;
        }

        .victory-btn {
            display: block;
            margin: 0 auto 30px;
            padding: 15px 50px;
            font-size: 22px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .victory-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%);
        }

        .victory-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            85% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">å·´å¡ï¼šå…¨é¢æˆ˜äº‰ï¼ˆä¼šæˆ˜ç•Œé¢ï¼‰</h1>
            <h2>ç½—é©¬ vs è¿¦å¤ªåŸº</h2>
        </div>

        <div class="phase-bar">
            <div class="current-player-info">
                å½“å‰å›åˆ: <span id="current-player-text" class="rome">ç½—é©¬</span>
            </div>
            <div class="phase-info">
                <span id="current-phase-text">é˜¶æ®µ: è§„åˆ’å’Œç§»åŠ¨</span>
            </div>
        </div>

        <div class="main-game-layout">
            <div class="game-board">
                <div class="square-grid-background"></div>
                <div id="square-grid" class="square-grid"></div>
        </div>

        <div class="game-info">
                <div id="phase-status-info" style="margin-bottom: 12px; padding: 12px; background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(155, 89, 182, 0.15)); border-radius: 10px; border: 2px solid rgba(52, 152, 219, 0.4); text-align: center; font-weight: bold; font-size: 14px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                    <div style="color: #3498db; margin-bottom: 5px; font-size: 13px;">å½“å‰å›åˆ</div>
                    <div id="sidebar-player-text" class="rome" style="font-size: 18px; margin-bottom: 10px; text-shadow: 0 0 10px rgba(231, 76, 60, 0.3);">ğŸ›ï¸ ç½—é©¬</div>
                    <div style="color: #3498db; margin-bottom: 5px; font-size: 13px;">å½“å‰é˜¶æ®µ</div>
                    <div id="sidebar-phase-text" style="font-size: 16px; color: white; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,0.5);">ğŸ“¦ éƒ¨ç½²é˜¶æ®µ</div>
                </div>
                <div class="control-buttons">
                <button id="add-step-btn" class="btn" style="display: none;">æ·»åŠ æ­¥éª¤</button>
                <button id="finish-plan-btn" class="btn" style="display: none;">å®Œæˆå•ä½è§„åˆ’</button>
                <button id="execute-plan-btn" class="btn" style="display: none;">æ‰§è¡Œç§»åŠ¨</button>
                <button id="cancel-move-btn" class="btn" style="display: none;">å–æ¶ˆ</button>
                <button id="finish-all-plans-btn" class="btn" style="display: none;">å®Œæˆæ‰€æœ‰è§„åˆ’</button>
                <button id="execute-all-btn" class="btn" style="display: none;">ç»Ÿä¸€æ‰§è¡Œ</button>
                <button id="finish-attacker-support-btn" class="btn" style="display: none;">å®Œæˆæ”»å‡»æ–¹æ”¯æ´é€‰æ‹©</button>
                <button id="finish-defender-support-btn" class="btn" style="display: none;">å®Œæˆé˜²å®ˆæ–¹æ”¯æ´é€‰æ‹©</button>
                <button id="defender-retreat-btn" class="btn" style="display: none; background: #e74c3c;">é€‰æ‹©æ’¤é€€</button>
                <button id="defender-stand-btn" class="btn" style="display: none; background: #27ae60;">åšå®ˆæˆ˜æ–—</button>
                <button id="execute-charge-btn" class="btn" style="display: none;">æ‰§è¡Œå†²é”‹</button>
                <button id="confirm-ranged-attack-btn" class="btn" style="display: none; background: linear-gradient(135deg, #e67e22, #d35400);">ğŸ¹ ç¡®è®¤å°„å‡»</button>
                    <button id="next-phase-btn" class="btn">ä¸‹ä¸€é˜¶æ®µ</button>
                <button id="confirm-deployment-btn" class="btn" style="display: none;">ç¡®è®¤éƒ¨ç½²</button>
                <button id="toggle-unit-info-btn" class="btn" style="background: linear-gradient(135deg, #16a085, #1abc9c);">ğŸ‘ï¸ éšè—å•ä½ä¿¡æ¯</button>
                <button id="save-game-btn" class="btn" style="background: linear-gradient(135deg, #27ae60, #229954);">ğŸ’¾ ä¿å­˜æ¸¸æˆ</button>
                <button id="load-game-btn" class="btn" style="background: linear-gradient(135deg, #8e44ad, #9b59b6);">ğŸ“‚ è½½å…¥æ¸¸æˆ</button>
                <button id="reset-btn" class="btn">é‡æ–°å¼€å§‹</button>
            </div>
            <div id="dice-result" style="display: none; text-align: center; margin-top: 10px; font-size: 16px; padding: 10px; background: #f8f9fa; border: 2px solid #3498db; border-radius: 8px; color: #2c3e50; font-weight: bold;"></div>
            
            <div class="game-log">
                <h3 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px;">ğŸ“œ æ¸¸æˆæ—¥å¿—</h3>
                    <div id="game-log-content" style="height: 300px; overflow-y: auto; padding: 10px; background: #f8f9fa; border: 1px solid #bdc3c7; border-radius: 5px; font-size: 14px; line-height: 1.4; color: #2c3e50;">
                    <div style="color: #7f8c8d; font-style: italic;">æ¸¸æˆå¼€å§‹ï¼Œç­‰å¾…è¡ŒåŠ¨...</div>
                </div>
            </div>
            
            <div class="unit-info">
                <div id="selected-unit-info">é€‰æ‹©ä¸€ä¸ªå•ä½æŸ¥çœ‹è¯¦æƒ…</div>
                <div class="faction-stats">
                    <div class="faction-stat">
                        <span class="faction-label rome">ğŸ›ï¸ ç½—é©¬</span>
                        <span id="rome-count">6</span>
                    </div>
                    <div class="faction-stat">
                        <span class="faction-label carthage">ğŸŒŠ è¿¦å¤ªåŸº</span>
                        <span id="carthage-count">6</span>
                </div>
            </div>
        </div>

        <div class="game-stats">
            <div class="faction-stats rome">
                <h3>ç½—é©¬</h3>
                <div id="rome-units">åˆ†å€¼: <span id="rome-count-bottom">4</span></div>
            </div>
            <div class="faction-stats carthage">
                <h3>è¿¦å¤ªåŸº</h3>
                <div id="carthage-units">åˆ†å€¼: <span id="carthage-count-bottom">4</span></div>
            </div>
        </div>
    </div>

    <!-- èƒœè´Ÿç»“ç®—å¼¹çª— -->
    <div id="victory-modal" class="victory-modal">
        <div class="victory-modal-content">
            <div class="victory-banner">
                <div id="victory-icon" class="victory-icon"></div>
                <h1 id="victory-title" class="victory-title"></h1>
            </div>
            <div class="victory-details">
                <h2>æˆ˜æ–—ç»“ç®—</h2>
                <div class="faction-result">
                    <div class="result-row rome-result">
                        <span class="faction-name">ğŸ›ï¸ ç½—é©¬</span>
                        <span id="rome-final-score" class="faction-score"></span>
                    </div>
                    <div class="result-row carthage-result">
                        <span class="faction-name">ğŸŒŠ è¿¦å¤ªåŸº</span>
                        <span id="carthage-final-score" class="faction-score"></span>
                    </div>
                </div>
                <div id="victory-message" class="victory-message"></div>
            </div>
            <button id="victory-restart-btn" class="victory-btn">é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <script>
        class HexGame {
            constructor() {
                this.gridWidth = 100; // å‡å°‘50%
                this.gridHeight = 50; // å‡å°‘50%
                this.hexSize = 60;
                this.currentPlayer = 'rome'; // 'rome' or 'carthage'
                this.currentPhase = 'deployment'; // 'deployment', 'movement', 'turning', 'ranged', 'melee'
                this.deploymentPhase = 'rome'; // 'rome', 'carthage', 'completed'
                this.meleeSubPhase = 'select_attacker'; // 'select_attacker', 'select_target', 'select_attacker_support', 'select_defender_support', 'execute_combat'
                this.meleeType = null; // 'charge' (å†²é”‹è¿‘æˆ˜) or 'sustained' (æŒç»­è¿‘æˆ˜)
                this.meleeAttacker = null; // å†²é”‹å•ä½
                this.meleeTarget = null; // è¢«æ”»å‡»å•ä½
                this.attackerSupports = []; // æ”»å‡»æ–¹æ”¯æ´éƒ¨é˜Ÿ
                this.defenderSupports = []; // é˜²å®ˆæ–¹æ”¯æ´éƒ¨é˜Ÿ
                this.selectedUnit = null;
                this.isDragging = false;
                this.draggedUnit = null;
                this.dragOffset = { x: 0, y: 0 };
                this.lastClickTime = 0;
                this.lastClickedUnit = null;
                this.generalDeathTestDone = { rome: false, carthage: false }; // è·Ÿè¸ªå°†é¢†é˜µäº¡æµ‹è¯•æ˜¯å¦å·²æ‰§è¡Œ
                this.lastSpaceKeyTime = 0; // ç”¨äºæ£€æµ‹åŒå‡»ç©ºæ ¼é”®
                this.targetPosition = null; // é€‰æ‹©çš„ç›®æ ‡ä½ç½®
                this.moveState = 'none'; // 'none', 'unit_selected', 'planning', 'ready_to_execute', 'all_planned'
                this.movePlan = []; // å½“å‰å•ä½çš„ç§»åŠ¨è§„åˆ’æ­¥éª¤ [{startX, startY, endX, endY}, ...]
                this.currentPlanStep = 0; // å½“å‰è§„åˆ’çš„æ­¥éª¤
                this.allUnitPlans = new Map(); // æ‰€æœ‰å•ä½çš„ç§»åŠ¨è§„åˆ’ Map<unitId, plan[]>
                this.planningPhase = 'planning'; // 'planning', 'executing'
                this.phaseCompleted = { movement: false, turning: false, ranged: false, melee: false }; // å„é˜¶æ®µå®ŒæˆçŠ¶æ€
                this.lastClickTime = 0;
                this.lastClickedHex = null;
                this.units = [];
                this.gameBoard = [];
                this.showUnitInfo = true; // æ§åˆ¶æ˜¯å¦æ˜¾ç¤ºå•ä½åç§°å’ŒHPå€¼
                this.rangedAttacker = null; // å°„å‡»é˜¶æ®µçš„æ”»å‡»å•ä½
                this.rangedTarget = null; // å°„å‡»é˜¶æ®µçš„ç›®æ ‡å•ä½
                
                this.initializeGame();
                this.setupEventListeners();
            }

            initializeGame() {
                this.createHexGrid();
                this.initializeUnits();
                
                // è®¡ç®—åˆå§‹æ€»åˆ†å€¼
                this.initialPoints = {
                    rome: this.calculateFactionPoints('rome'),
                    carthage: this.calculateFactionPoints('carthage')
                };
                console.log(`[æ¸¸æˆåˆå§‹åŒ–] ç½—é©¬åˆå§‹åˆ†å€¼: ${this.initialPoints.rome}, è¿¦å¤ªåŸºåˆå§‹åˆ†å€¼: ${this.initialPoints.carthage}`);
                
                this.renderBoard();
                this.updateMoveButtons(); // ç¡®ä¿æŒ‰é’®çŠ¶æ€æ­£ç¡®
                this.updateUI();
                
                // å¦‚æœæ˜¯éƒ¨ç½²é˜¶æ®µï¼Œæ·»åŠ æç¤ºä¿¡æ¯
                if (this.currentPhase === 'deployment') {
                    this.addGameLog(`ğŸ“¦ éƒ¨ç½²é˜¶æ®µå¼€å§‹ï¼æ‹–æ‹½å·±æ–¹å•ä½è°ƒæ•´éƒ¨ç½²ä½ç½®`);
                    this.addGameLog(`ğŸ›ï¸ ç½—é©¬ï¼šå¯åœ¨åœ°å›¾ä¸‹æ–¹åŒºåŸŸéƒ¨ç½²`);
                    this.addGameLog(`ğŸŒŠ è¿¦å¤ªåŸºï¼šå¯åœ¨åœ°å›¾ä¸Šæ–¹åŒºåŸŸéƒ¨ç½²`);
                    this.addGameLog(`ğŸ’¡ æ‹–æ‹½å•ä½åˆ°åˆé€‚ä½ç½®ï¼Œå®Œæˆåç‚¹å‡»"ç¡®è®¤éƒ¨ç½²"æŒ‰é’®`);
                }
            }

            createHexGrid() {
                // åˆ›å»ºå…­è§’æ ¼åæ ‡ç³»ç»Ÿ
                this.gameBoard = [];
                for (let row = 0; row < this.gridHeight; row++) {
                    this.gameBoard[row] = [];
                    for (let col = 0; col < this.gridWidth; col++) {
                        this.gameBoard[row][col] = {
                            x: col,
                            y: row,
                            unit: null,
                            terrain: 'plains'
                        };
                    }
                }
            }

            initializeUnits() {
                // å®šä¹‰å•ä½å°ºå¯¸ï¼ˆæœå‘ä¸ºnorthæ—¶çš„å°ºå¯¸ï¼‰
                this.unitBaseSizes = {
                    'infantry': { width: 3, height: 2 },     // æ­¥å…µ 3x2
                    'cavalry': { width: 2, height: 1 },      // éª‘å…µ 2x1  
                    'archer': { width: 3, height: 1 },       // å¼“ç®­æ‰‹ 3x1
                    'legionary': { width: 3, height: 2 },    // å†›å›¢å…µ 3x2
                    'centurion': { width: 2, height: 1 },    // ç™¾å¤«é•¿ 2x1
                    'hastati': { width: 3, height: 2 },      // åå¤‡å…µ 3x2
                    'elephant': { width: 3, height: 2 },     // æˆ˜è±¡ 3x2
                    'general': { width: 2, height: 1 }       // å°†é¢† 2x1 (ç­‰åŒäºéª‘å…µ)
                };

                // ä¸ºäº†å…¼å®¹ç°æœ‰ä»£ç ï¼Œä¿ç•™unitSizes
                this.unitSizes = this.unitBaseSizes;

                // å®šä¹‰å•ä½åˆ†å€¼
                this.unitValues = {
                    // ç½—é©¬å•ä½
                    'legionary': 5,      // ç½—é©¬å†›å›¢å…µ
                    'hastati': 7,        // ç½—é©¬åå¤‡å…µ
                    'cavalry': 12,       // ç½—é©¬è´µæ—éª‘å…µ/è¿¦å¤ªåŸºéª‘å…µ
                    'general': 15,       // ç½—é©¬å°†å†›/è¿¦å¤ªåŸºå°†å†›
                    'archer': 3,         // ç½—é©¬å¼“ç®­æ‰‹/è¿¦å¤ªåŸºå¼“ç®­æ‰‹
                    // è¿¦å¤ªåŸºå•ä½
                    'infantry': 5,       // è¿¦å¤ªåŸºæ­¥å…µ
                    'elephant': 20,      // è¿¦å¤ªåŸºæˆ˜è±¡ï¼ˆç‰¹æ®Šå•ä½ï¼Œåˆ†å€¼è¾ƒé«˜ï¼‰
                    'centurion': 15      // ç™¾å¤«é•¿ï¼ˆå¦‚æœä½¿ç”¨ï¼‰
                };

                // æˆ˜åœºå•ä½
                this.units = [
                    // ç¬¬ä¸€æ’å†›å›¢æ­¥å…µ
                    { 
                        id: 1, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 34, 
                        y: 34, 
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',         // å£«æ°”ï¼šgood(è‰¯å¥½)/shaken(åŠ¨æ‘‡)
                        order: 'good',          // ç§©åºï¼šgood(è‰¯å¥½)/chaotic(æ··ä¹±)
                        combatStatus: 'not_engaged',  // æˆ˜æ–—çŠ¶æ€ï¼šengaged(è¿‘æˆ˜ä¸­)/not_engaged(æœªè¿‘æˆ˜)/supporting(æ”¯æ´ä¸­)
                        hasRangedAttacked: false,     // å·²å°„å‡»ï¼štrue/false
                        hasMeleeAttacked: false,      // å·²è¿‘æˆ˜ï¼štrue/false
                        lastMeleeResult: 'none'       // ä¸Šä¸€è½®è¿‘æˆ˜ç»“æœï¼šnone(æ— )/won(èƒœåˆ©)/lost(å¤±è´¥)/draw(åŠ¿å‡åŠ›æ•Œ)
                    },
                    { 
                        id: 2, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 41, 
                        y: 34, 
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 3, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 48, 
                        y: 34,
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 4, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 55, 
                        y: 34,
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    // ç¬¬äºŒæ’å†›å›¢æ­¥å…µ
                    { 
                        id: 5, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 38, 
                        y: 36,
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 6, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 44, 
                        y: 36,
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 7, 
                        name: 'å†›å›¢æ­¥å…µ', 
                        type: 'legionary', 
                        faction: 'rome', 
                        x: 52, 
                        y: 36,
                        chargeAttack: 5,        // å†²é”‹è¿‘æˆ˜
                        sustainedMelee: 5,      // æŒç»­è¿‘æˆ˜
                        supportMelee: 2,        // æ”¯æ´è¿‘æˆ˜
                        throwingAttack: 2,      // æŠ•æ·æ”»å‡»
                        rangedAttack: 2,        // å°„å‡»æ”»å‡»
                        defense: 4,             // é˜²å¾¡èƒ½åŠ›
                        casualtyTolerance: 4,   // ä¼¤äº¡æ‰¿å—åŠ›
                        specialSkills: ['ç›¾å¢™', 'æŠ•æ·æ ‡æª'], // ç‰¹æ®ŠæŠ€èƒ½
                        range: 6,               // å°„ç¨‹
                        movement: 6,            // ç§»åŠ¨
                        leadership: 0,          // é¢†å¯¼åŠ›
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    // ç¬¬ä¸‰æ’åå¤‡æ­¥å…µ
                    { 
                        id: 8, 
                        name: 'ç½—é©¬åå¤‡å…µ', 
                        type: 'hastati', 
                        faction: 'rome', 
                        x: 34, 
                        y: 39, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 4,
                        specialSkills: ['æŒ‡æŒ¥', 'æ¿€åŠ±'],
                        range: 1,
                        movement: 6,
                        leadership: 3,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 9, 
                        name: 'ç½—é©¬åå¤‡å…µ', 
                        type: 'hastati', 
                        faction: 'rome', 
                        x: 41, 
                        y: 39,
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 4,
                        specialSkills: ['æŒ‡æŒ¥', 'æ¿€åŠ±'],
                        range: 1,
                        movement: 6,
                        leadership: 3,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 10, 
                        name: 'ç½—é©¬åå¤‡å…µ', 
                        type: 'hastati', 
                        faction: 'rome', 
                        x: 48, 
                        y: 39,
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 4,
                        specialSkills: ['æŒ‡æŒ¥', 'æ¿€åŠ±'],
                        range: 1,
                        movement: 6,
                        leadership: 3,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 11, 
                        name: 'ç½—é©¬åå¤‡å…µ', 
                        type: 'hastati', 
                        faction: 'rome', 
                        x: 55, 
                        y: 39,
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 3,
                        rangedAttack: 2,
                        defense: 4,
                        casualtyTolerance: 4,
                        specialSkills: ['æŒ‡æŒ¥', 'æ¿€åŠ±'],
                        range: 6,
                        movement: 6,
                        leadership: 3,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    //éª‘å…µ
                    { 
                        id: 12, 
                        name: 'ç½—é©¬æ‰§æ”¿å®˜', 
                        type: 'general', 
                        faction: 'rome', 
                        x: 20, 
                        y: 33, 
                        chargeAttack: 6,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 8,
                        specialSkills: ['é«˜çº§æŒ‡æŒ¥', 'æˆ˜æœ¯å¤§å¸ˆ', 'é¼“èˆå£«æ°”'],
                        range: 1,
                        movement: 9,
                        leadership: 9,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 13, 
                        name: 'ç½—é©¬è´µæ—éª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'rome', 
                        x: 66, 
                        y: 33, 
                        chargeAttack: 6,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['å†²é”‹', 'å¿«é€ŸæœºåŠ¨'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 14, 
                        name: 'ç½—é©¬è´µæ—éª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'rome', 
                        x: 17, 
                        y: 33, 
                        chargeAttack: 6,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['å†²é”‹', 'å¿«é€ŸæœºåŠ¨'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 15, 
                        name: 'ç½—é©¬è´µæ—éª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'rome', 
                        x: 69, 
                        y: 33, 
                        chargeAttack: 6,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['å†²é”‹', 'å¿«é€ŸæœºåŠ¨'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    // åŒç›Ÿå¼“ç®­æ‰‹
                    { 
                        id: 16, 
                        name: 'åŒç›Ÿçš„å¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'rome', 
                        x: 27, 
                        y: 30, 
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 1,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['ç²¾å‡†å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 17, 
                        name: 'åŒç›Ÿçš„å¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'rome', 
                        x: 40, 
                        y: 30,
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 1,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['ç²¾å‡†å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 18, 
                        name: 'åŒç›Ÿçš„å¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'rome', 
                        x: 50, 
                        y: 30,
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 1,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['ç²¾å‡†å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 19, 
                        name: 'åŒç›Ÿçš„å¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'rome', 
                        x: 60, 
                        y: 30,
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 1,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['ç²¾å‡†å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'north',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    
                    // è¿¦å¤ªåŸºæ­¥å…µ
                    { 
                        id: 117, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 30, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 118, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 34, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 119, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 38, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 120, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 42, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 121, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 46, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 122, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 50, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 123, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 54, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 124, 
                        name: 'è¿¦å¤ªåŸºæ­¥å…µ', 
                        type: 'infantry', 
                        faction: 'carthage', 
                        x: 58, 
                        y: 9, 
                        chargeAttack: 6,
                        sustainedMelee: 6,
                        supportMelee: 3,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 4,
                        casualtyTolerance: 5,
                        specialSkills: ['ç‹‚çƒ­å†²é”‹'],
                        range: 1,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    // è¿¦å¤ªåŸºæˆ˜è±¡å’Œéª‘å…µ
                    { 
                        id: 125, 
                        name: 'è¿¦å¤ªåŸºæˆ˜è±¡', 
                        type: 'elephant', 
                        faction: 'carthage', 
                        x: 19, 
                        y: 8, 
                        chargeAttack: 4,
                        sustainedMelee: 3,
                        supportMelee: 1,
                        throwingAttack: 1,
                        rangedAttack: 1,
                        defense: 4,
                        casualtyTolerance: 9,
                        specialSkills: ['è·µè¸', 'ææ€–å†²å‡»', 'å·¨å…½å¨æ…‘'],
                        range: 6,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 60,
                        maxHp: 60,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 126, 
                        name: 'è¿¦å¤ªåŸºéª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'carthage', 
                        x: 67, 
                        y: 10, 
                        chargeAttack: 5,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['æ¸¸å‡»æˆ˜æœ¯', 'å¿«é€Ÿæ’¤é€€'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 127, 
                        name: 'è¿¦å¤ªåŸºéª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'carthage', 
                        x: 70, 
                        y: 10, 
                        chargeAttack: 5,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['æ¸¸å‡»æˆ˜æœ¯', 'å¿«é€Ÿæ’¤é€€'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 128, 
                        name: 'è¿¦å¤ªåŸºéª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'carthage', 
                        x: 73, 
                        y: 10, 
                        chargeAttack: 5,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['æ¸¸å‡»æˆ˜æœ¯', 'å¿«é€Ÿæ’¤é€€'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 129, 
                        name: 'è¿¦å¤ªåŸºéª‘å…µ', 
                        type: 'cavalry', 
                        faction: 'carthage', 
                        x: 76, 
                        y: 10, 
                        chargeAttack: 5,
                        sustainedMelee: 3,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['æ¸¸å‡»æˆ˜æœ¯', 'å¿«é€Ÿæ’¤é€€'],
                        range: 1,
                        movement: 9,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 130, 
                        name: 'è¿¦å¤ªåŸºå°†å†›', 
                        type: 'general', 
                        faction: 'carthage', 
                        x: 24, 
                        y: 8, 
                        chargeAttack: 6,
                        sustainedMelee: 4,
                        supportMelee: 2,
                        throwingAttack: 0,
                        rangedAttack: 0,
                        defense: 5,
                        casualtyTolerance: 5,
                        specialSkills: ['é«˜çº§æŒ‡æŒ¥', 'æˆ˜æœ¯å¤§å¸ˆ', 'é¼“èˆå£«æ°”'],
                        range: 1,
                        movement: 9,
                        leadership: 9,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    // è¿¦å¤ªåŸºå¼“ç®­æ‰‹
                    { 
                        id: 131, 
                        name: 'è¿¦å¤ªåŸºå¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'carthage', 
                        x: 30, 
                        y: 13, 
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 2,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['è¿ç»­å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 132, 
                        name: 'è¿¦å¤ªåŸºå¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'carthage', 
                        x: 43, 
                        y: 13, 
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 2,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['è¿ç»­å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                    { 
                        id: 133, 
                        name: 'è¿¦å¤ªåŸºå¼“ç®­æ‰‹', 
                        type: 'archer', 
                        faction: 'carthage', 
                        x: 58, 
                        y: 13, 
                        chargeAttack: 3,
                        sustainedMelee: 2,
                        supportMelee: 2,
                        throwingAttack: 2,
                        rangedAttack: 2,
                        defense: 6,
                        casualtyTolerance: 4,
                        specialSkills: ['è¿ç»­å°„å‡»'],
                        range: 12,
                        movement: 6,
                        leadership: 0,
                        hasMoved: false, 
                        direction: 'south',
                        hp: 40,
                        maxHp: 40,
                        morale: 'good',
                        order: 'good',
                        combatStatus: 'not_engaged',
                        hasRangedAttacked: false,
                        hasMeleeAttacked: false
                    },
                ];

                // ä¸ºæ‰€æœ‰å•ä½æ·»åŠ lastMeleeResultã€lastBattleDamageã€engagedWithã€supportingUnitã€valueå±æ€§ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                this.units.forEach(unit => {
                    if (!unit.hasOwnProperty('lastMeleeResult')) {
                        unit.lastMeleeResult = 'none';
                    }
                    if (!unit.hasOwnProperty('lastBattleDamage')) {
                        unit.lastBattleDamage = 0;
                    }
                    if (!unit.hasOwnProperty('engagedWith')) {
                        unit.engagedWith = null; // è¿½è¸ªæ­£åœ¨ä¸è°è¿‘æˆ˜
                    }
                    if (!unit.hasOwnProperty('supportingUnit')) {
                        unit.supportingUnit = null; // è¿½è¸ªæ­£åœ¨æ”¯æ´å“ªä¸ªå•ä½
                    }
                    
                    // ä¸ºæ¯ä¸ªå•ä½è®¾ç½®åˆ†å€¼
                    if (!unit.hasOwnProperty('value')) {
                        unit.value = this.unitValues[unit.type] || 0;
                    }
                    
                    // ç»Ÿä¸€è®¾ç½®å•ä½æœå‘ï¼šç½—é©¬æœåŒ—ï¼Œè¿¦å¤ªåŸºæœå—
                    if (unit.faction === 'rome') {
                        unit.direction = 'north';
                    } else if (unit.faction === 'carthage') {
                        unit.direction = 'south';
                    }
                });

                // è®¡ç®—å¹¶å­˜å‚¨åˆå§‹æ€»åˆ†å€¼
                this.initialRomeValue = this.units
                    .filter(u => u.faction === 'rome')
                    .reduce((sum, u) => sum + (u.value || 0), 0);
                this.initialCarthageValue = this.units
                    .filter(u => u.faction === 'carthage')
                    .reduce((sum, u) => sum + (u.value || 0), 0);
                
                console.log(`åˆå§‹åˆ†å€¼ - ç½—é©¬: ${this.initialRomeValue}, è¿¦å¤ªåŸº: ${this.initialCarthageValue}`);

            }

            setupEventListeners() {
                document.getElementById('reset-btn').addEventListener('click', () => {
                    this.resetGame();
                });

                document.getElementById('add-step-btn').addEventListener('click', () => {
                    this.addPlanStep();
                });

                document.getElementById('finish-plan-btn').addEventListener('click', () => {
                    this.finishPlanning();
                });

                document.getElementById('execute-plan-btn').addEventListener('click', async () => {
                    // é˜²æ­¢é‡å¤ç‚¹å‡»
                    const btn = document.getElementById('execute-plan-btn');
                    if (btn.disabled) return;
                    
                    btn.disabled = true;
                    btn.textContent = 'æ‰§è¡Œä¸­...';
                    
                    try {
                        await this.executePlan();
                    } catch (error) {
                        console.error('æ‰§è¡Œå•ä¸ªè®¡åˆ’æ—¶å‡ºé”™:', error);
                        this.addGameLog('âŒ æ‰§è¡Œå•ä¸ªè®¡åˆ’æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                    } finally {
                        btn.disabled = false;
                        btn.textContent = 'æ‰§è¡Œç§»åŠ¨';
                    }
                });

                document.getElementById('finish-all-plans-btn').addEventListener('click', () => {
                    this.finishAllPlanning();
                });

                document.getElementById('execute-all-btn').addEventListener('click', async () => {
                    // é˜²æ­¢é‡å¤ç‚¹å‡»
                    const btn = document.getElementById('execute-all-btn');
                    if (btn.disabled) return;
                    
                    btn.disabled = true;
                    btn.textContent = 'æ‰§è¡Œä¸­...';
                    
                    try {
                        await this.executeAllPlans();
                    } catch (error) {
                        console.error('æ‰§è¡Œè®¡åˆ’æ—¶å‡ºé”™:', error);
                        this.addGameLog('âŒ æ‰§è¡Œè®¡åˆ’æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                    } finally {
                        btn.disabled = false;
                        btn.textContent = 'ç»Ÿä¸€æ‰§è¡Œ';
                    }
                });

                document.getElementById('cancel-move-btn').addEventListener('click', () => {
                    this.cancelMove();
                });

                document.getElementById('next-phase-btn').addEventListener('click', () => {
                    const btn = document.getElementById('next-phase-btn');
                    if (btn.disabled) {
                        console.log('[é˜¶æ®µæ§åˆ¶] ä¸‹ä¸€é˜¶æ®µæŒ‰é’®è¢«ç¦ç”¨');
                        return;
                    }
                    this.nextPhase();
                });

                document.getElementById('confirm-deployment-btn').addEventListener('click', () => {
                    this.confirmDeployment();
                });
                
                document.getElementById('finish-attacker-support-btn').addEventListener('click', () => {
                    this.finishAttackerSupport();
                });
                
                document.getElementById('finish-defender-support-btn').addEventListener('click', () => {
                    this.finishDefenderSupport();
                });
                
                document.getElementById('defender-retreat-btn').addEventListener('click', () => {
                    this.defenderChooseRetreat();
                });
                
                document.getElementById('defender-stand-btn').addEventListener('click', () => {
                    this.defenderChooseStand();
                });
                
                document.getElementById('execute-charge-btn').addEventListener('click', () => {
                    this.executeChargeAttack();
                    this.renderBoard();
                    this.updateUI();
                });

                document.getElementById('confirm-ranged-attack-btn').addEventListener('click', () => {
                    this.confirmRangedAttack();
                });

                document.getElementById('toggle-unit-info-btn').addEventListener('click', () => {
                    this.toggleUnitInfo();
                });

                document.getElementById('save-game-btn').addEventListener('click', () => {
                    this.saveGame();
                });

                document.getElementById('load-game-btn').addEventListener('click', () => {
                    this.loadGame();
                });

                // æ·»åŠ å…¨å±€æ‹–æ‹½äº‹ä»¶
                document.addEventListener('mousemove', (e) => {
                    this.handleDrag(e);
                });

                document.addEventListener('mouseup', (e) => {
                    this.endDrag(e);
                });

                // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
                document.addEventListener('keydown', (e) => {
                    this.handleKeyPress(e);
                });
            }

            renderBoard() {
                const container = document.getElementById('square-grid');
                container.innerHTML = '';

                // æ¸²æŸ“åŸºç¡€ç½‘æ ¼ï¼ˆå®Œæ•´æ¸²æŸ“ä»¥æ¶ˆé™¤é—´éš™ï¼‰
                for (let row = 0; row < this.gridHeight; row++) {
                    for (let col = 0; col < this.gridWidth; col++) {
                        const square = this.createSquareElement(col, row);
                        container.appendChild(square);
                    }
                }

                // æ¸²æŸ“å•ä½ï¼ˆæ ¹æ®éƒ¨ç½²é˜¶æ®µå†³å®šæ˜¾ç¤ºå“ªäº›å•ä½ï¼‰
                // æ³¨æ„ï¼šå³ä½¿HP<=0ä¹Ÿè¦æ¸²æŸ“å•ä½ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½æ­£åœ¨è¿›è¡Œå´©æºƒæµ‹è¯•å’Œåé€€
                // åªæœ‰çœŸæ­£è¢«æ¶ˆç­ï¼ˆä»unitsæ•°ç»„ä¸­ç§»é™¤ï¼‰çš„å•ä½æ‰ä¸ä¼šè¢«æ¸²æŸ“
                this.units.forEach(unit => {
                    if (!unit.isAnimating) {
                        // åœ¨éƒ¨ç½²é˜¶æ®µï¼Œåªæ˜¾ç¤ºå½“å‰éƒ¨ç½²æ–¹çš„å•ä½
                        if (this.currentPhase === 'deployment') {
                            if (unit.faction === this.deploymentPhase) {
                        const unitElement = this.createLargeUnitElement(unit);
                        container.appendChild(unitElement);
                            }
                        } else {
                            // ééƒ¨ç½²é˜¶æ®µï¼Œæ˜¾ç¤ºæ‰€æœ‰å•ä½
                            const unitElement = this.createLargeUnitElement(unit);
                            container.appendChild(unitElement);
                        }
                    }
                });

                // æ¸²æŸ“åé‡æ–°åº”ç”¨é«˜äº®å’Œè·¯å¾„
                this.drawAllMovePaths();
                if (this.selectedUnit && this.moveState === 'planning') {
                    this.highlightCurrentStepMoves();
                } else if (this.selectedUnit && this.moveState === 'unit_selected') {
                    this.highlightCurrentStepMoves();
                }
            }

            createSquareElement(x, y) {
                const square = document.createElement('div');
                square.className = 'square';
                square.dataset.x = x;
                square.dataset.y = y;

                // å°æ ¼å­å¸ƒå±€
                const squareSize = 16;
                const posX = x * squareSize;
                const posY = y * squareSize;

                square.style.left = posX + 'px';
                square.style.top = posY + 'px';

                // è‰åœ°æ•ˆæœ - æ·±æµ…è‰ç»¿è‰²ç›¸é—´
                if ((x + y) % 2 === 0) {
                    square.style.background = '#27ae60';
                } else {
                    square.style.background = '#2ecc71';
                }

                // åœ¨éƒ¨ç½²é˜¶æ®µæ˜¾ç¤ºéƒ¨ç½²åŒºåŸŸ
                if (this.currentPhase === 'deployment') {
                    // ç½—é©¬éƒ¨ç½²åŒºåŸŸï¼ˆä¸‹åŠéƒ¨åˆ†ï¼‰
                    if (y >= this.gridHeight * 0.6) {
                        square.classList.add('deployment-zone-rome');
                        if (this.deploymentPhase === 'rome') {
                            square.classList.add('deployment-zone-active');
                        }
                    }
                    // è¿¦å¤ªåŸºéƒ¨ç½²åŒºåŸŸï¼ˆä¸ŠåŠéƒ¨åˆ†ï¼‰
                    else if (y < this.gridHeight * 0.4) {
                        square.classList.add('deployment-zone-carthage');
                        if (this.deploymentPhase === 'carthage') {
                            square.classList.add('deployment-zone-active');
                        }
                    }
                }

                square.addEventListener('click', (e) => {
                    console.log('æ–¹æ ¼è¢«ç‚¹å‡»!', x, y);
                    this.handleSquareClick(x, y, e);
                });

                return square;
            }

            createLargeUnitElement(unit) {
                const size = this.getUnitSizeWithDirection(unit);
                const squareSize = 16;
                
                const unitDiv = document.createElement('div');
                unitDiv.className = `unit-large ${unit.faction}`;
                if (unit.hasMoved) {
                    unitDiv.classList.add('has-moved');
                }
                
                // è¿‘æˆ˜é˜¶æ®µçš„é«˜äº®
                if (this.currentPhase === 'melee') {
                    // é€‰æ‹©æ”»å‡»è€…é˜¶æ®µ - é«˜äº®å·²é€‰æ‹©çš„æ”»å‡»è€…
                    if (this.meleeSubPhase === 'select_attacker' && this.meleeAttacker && unit.id === this.meleeAttacker.id) {
                        unitDiv.classList.add('target-selected');
                    }
                    
                    // é€‰æ‹©ç›®æ ‡é˜¶æ®µ
                    if (this.meleeSubPhase === 'select_target' && this.meleeAttacker) {
                        // å·²é€‰æ‹©çš„æ”»å‡»è€… - é»„è‰²æ¡†
                        if (unit.id === this.meleeAttacker.id) {
                            unitDiv.classList.add('target-selected');
                        }
                        // å¯é€‰çš„æ”»å‡»ç›®æ ‡ - ç´«è‰²æ¡†è„‰å†²
                        const availableTargets = this.getUnitsInRange(this.meleeAttacker, 3, false);
                        if (availableTargets.find(u => u.id === unit.id)) {
                            unitDiv.classList.add('target-available');
                        }
                    }
                    
                    // é€‰æ‹©æ”»å‡»æ–¹æ”¯æ´é˜¶æ®µ
                    if (this.meleeSubPhase === 'select_attacker_support' && this.meleeAttacker) {
                        // å·²é€‰æ‹©çš„æ”»å‡»è€… - é»„è‰²æ¡†
                        if (unit.id === this.meleeAttacker.id) {
                            unitDiv.classList.add('target-selected');
                        }
                        // å·²é€‰æ‹©çš„ç›®æ ‡ - é»„è‰²æ¡†
                        if (this.meleeTarget && unit.id === this.meleeTarget.id) {
                            unitDiv.classList.add('target-selected');
                        }
                        // å·²æ·»åŠ çš„æ”¯æ´å•ä½ - é»„è‰²æ¡†æ”¾å¤§ï¼ˆä¼˜å…ˆåˆ¤æ–­ï¼‰
                        const isSelected = this.attackerSupports.find(u => u.id === unit.id);
                        if (isSelected) {
                            unitDiv.classList.add('support-selected');
                        } else {
                            // å¯è¢«æ·»åŠ çš„æ”¯æ´å•ä½ - ç´«è‰²æ¡†è„‰å†²ï¼ˆæ’é™¤å·²æ·»åŠ çš„ï¼‰
                            const availableSupports = this.getAvailableSupportUnits(this.meleeAttacker);
                            if (availableSupports.find(u => u.id === unit.id)) {
                                unitDiv.classList.add('support-available');
                            }
                        }
                    }
                    
                    // é€‰æ‹©é˜²å®ˆæ–¹æ”¯æ´é˜¶æ®µ
                    if (this.meleeSubPhase === 'select_defender_support' && this.meleeTarget) {
                        // å·²é€‰æ‹©çš„æ”»å‡»è€… - é»„è‰²æ¡†
                        if (this.meleeAttacker && unit.id === this.meleeAttacker.id) {
                            unitDiv.classList.add('target-selected');
                        }
                        // å·²é€‰æ‹©çš„ç›®æ ‡ - é»„è‰²æ¡†
                        if (unit.id === this.meleeTarget.id) {
                            unitDiv.classList.add('target-selected');
                        }
                        // å·²æ·»åŠ çš„æ”»å‡»æ–¹æ”¯æ´å•ä½ - é»„è‰²æ¡†
                        if (this.attackerSupports.find(u => u.id === unit.id)) {
                            unitDiv.classList.add('support-selected');
                        }
                        // å·²æ·»åŠ çš„é˜²å®ˆæ–¹æ”¯æ´å•ä½ - é»„è‰²æ¡†æ”¾å¤§ï¼ˆä¼˜å…ˆåˆ¤æ–­ï¼‰
                        const isDefenderSelected = this.defenderSupports.find(u => u.id === unit.id);
                        if (isDefenderSelected) {
                            unitDiv.classList.add('support-selected');
                        } else {
                            // å¯è¢«æ·»åŠ çš„é˜²å®ˆæ–¹æ”¯æ´å•ä½ - ç´«è‰²æ¡†è„‰å†²ï¼ˆæ’é™¤å·²æ·»åŠ çš„ï¼‰
                            const availableSupports = this.getAvailableSupportUnits(this.meleeTarget);
                            if (availableSupports.find(u => u.id === unit.id)) {
                                unitDiv.classList.add('support-available');
                            }
                        }
                    }
                }
                // ä¸ºå›¾ç‰‡å•ä½æ·»åŠ ç‰¹æ®Šç±»
                if ((unit.faction === 'rome' && (unit.type === 'legionary' || unit.type === 'centurion' || unit.type === 'hastati' || unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general')) || 
                    (unit.faction === 'carthage' && (unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general' || unit.type === 'infantry' || unit.type === 'elephant'))) {
                    unitDiv.classList.add('image-unit');
                }
                unitDiv.dataset.unitId = unit.id;
                unitDiv.dataset.x = unit.x;
                unitDiv.dataset.y = unit.y;
                
                // è®¾ç½®å•ä½å°ºå¯¸å’Œä½ç½®
                unitDiv.style.width = (size.width * squareSize) + 'px';
                unitDiv.style.height = (size.height * squareSize) + 'px';
                unitDiv.style.left = (unit.x * squareSize) + 'px';
                unitDiv.style.top = (unit.y * squareSize) + 'px';
                
                // HP<=0çš„å•ä½æ˜¾ç¤ºä¸ºæ¿’æ­»çŠ¶æ€ï¼ˆåŠé€æ˜+çº¢è‰²è¾¹æ¡†ï¼‰
                if (unit.hp <= 0) {
                    unitDiv.style.opacity = '0.6';
                    unitDiv.style.border = '3px solid #e74c3c';
                    unitDiv.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.8)';
                }
                
                // è·å–å•ä½å›¾æ ‡å’Œæ–¹å‘ç®­å¤´
                const unitIcon = this.getUnitIcon(unit);
                const directionArrow = this.getDirectionArrow(unit.direction);
                
                const fontSize = Math.min(size.width * 2, size.height * 3, 16);
                
                // å°†é¢†æœ‰ç‰¹æ®Šçš„æ˜¾ç¤ºæ•ˆæœ
                const isGeneral = unit.type === 'general';
                const borderStyle = '';
                
                // ä¸ºå›¾ç‰‡å•ä½å’Œemojiå•ä½ä½¿ç”¨ä¸åŒçš„å¸ƒå±€
                const isImageUnit = (unit.faction === 'rome' && (unit.type === 'legionary' || unit.type === 'centurion' || unit.type === 'hastati' || unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general')) || 
                                   (unit.faction === 'carthage' && (unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general' || unit.type === 'infantry' || unit.type === 'elephant'));
                
                // ä½¿ç”¨å•ä½çš„nameå­—æ®µä½œä¸ºæ˜¾ç¤ºåç§°
                const unitDisplayName = unit.name;
                
                if (isImageUnit) {
                    // è®¡ç®—å›¾ç‰‡æ—‹è½¬è§’åº¦
                    const rotationDegrees = {
                        'north': 0,
                        'east': 90,
                        'south': 180,
                        'west': 270
                    };
                    const rotation = rotationDegrees[unit.direction] || 0;
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ä»¥ä¿æŒå›¾ç‰‡åœ¨æ—‹è½¬åçš„å¤§å°ä¸€è‡´
                    const isRotated = (unit.direction === 'east' || unit.direction === 'west');
                    const scaleValue = isRotated ? Math.max(size.width / size.height, size.height / size.width) : 1;
                    
                    unitDiv.innerHTML = `
                        <div style="position: relative; width: 100%; height: 100%; background: transparent; ${borderStyle}">
                            <div style="width: 100%; height: 100%; background: transparent; display: flex; align-items: center; justify-content: center; transform: rotate(${rotation}deg) scale(${scaleValue});">
                                ${unitIcon}
                            </div>
                            ${isGeneral ? `<div style="position: absolute; top: 2px; left: 2px; font-size: ${fontSize-3}px; color: #f1c40f; font-weight: bold; background: rgba(0,0,0,0.5); padding: 1px 3px; border-radius: 2px;">L${unit.leadership}</div>` : ''}
                            ${this.showUnitInfo ? `<div style="position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); font-size: ${Math.max(8, fontSize-4)}px; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,1); background: rgba(0,0,0,0.7); padding: 1px 4px; border-radius: 3px; white-space: nowrap; z-index: 10; border: 1px solid #000;">
                                ${unitDisplayName}
                            </div>` : ''}
                        </div>
                    `;
                } else {
                    unitDiv.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; font-size: ${fontSize-4}px; ${borderStyle}">
                            <div style="font-size: ${fontSize}px; margin-bottom: 1px;">${unitIcon}</div>
                            <div style="font-size: ${fontSize-2}px; color: #f1c40f; text-shadow: 1px 1px 2px rgba(0,0,0,1);">
                                ${directionArrow}
                            </div>
                            ${isGeneral ? `<div style="font-size: ${fontSize-3}px; color: #f1c40f; font-weight: bold;">L${unit.leadership}</div>` : ''}
                            ${this.showUnitInfo ? `<div style="position: absolute; bottom: -16px; left: 50%; transform: translateX(-50%); font-size: ${Math.max(8, fontSize-4)}px; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,1); background: rgba(0,0,0,0.7); padding: 1px 4px; border-radius: 3px; white-space: nowrap; z-index: 10; border: 1px solid #000;">
                                ${unitDisplayName}
                            </div>` : ''}
                        </div>
                    `;
                }
                
                const hpPercentage = (unit.hp / unit.maxHp) * 100;
                let hpColor = '#2ecc71';
                if (hpPercentage < 70) hpColor = '#f39c12';
                if (hpPercentage < 40) hpColor = '#e74c3c';
                
                // è·å–å•ä½åç§°
                const getUnitName = (unitType) => {
                    const nameMap = {
                        'legionary': 'å†›å›¢å…µ',
                        'centurion': 'ç™¾å¤«é•¿',
                        'archer': 'å¼“ç®­æ‰‹',
                        'infantry': 'æ­¥å…µ',
                        'elephant': 'æˆ˜è±¡',
                        'cavalry': 'éª‘å…µ',
                        'general': 'å°†é¢†'
                    };
                    return nameMap[unitType] || unitType;
                };
                
                const moraleText = unit.morale === 'good' ? 'è‰¯å¥½' : 'åŠ¨æ‘‡';
                const orderText = unit.order === 'good' ? 'è‰¯å¥½' : 'æ··ä¹±';
                const combatText = unit.combatStatus === 'engaged' ? 'è¿‘æˆ˜ä¸­' : unit.combatStatus === 'supporting' ? 'æ”¯æ´ä¸­' : 'æœªè¿‘æˆ˜';
                const directionText = {
                    'north': 'åŒ—â†‘',
                    'east': 'ä¸œâ†’', 
                    'south': 'å—â†“',
                    'west': 'è¥¿â†'
                }[unit.direction] || unit.direction;
                const directionIcon = {
                    'north': 'â¬†ï¸',
                    'east': 'â¡ï¸', 
                    'south': 'â¬‡ï¸',
                    'west': 'â¬…ï¸'
                }[unit.direction] || 'ğŸ§­';
                
                const tooltipText = `${unit.name} (${unit.faction === 'rome' ? 'ç½—é©¬' : 'è¿¦å¤ªåŸº'}) | ğŸ’åˆ†å€¼: ${unit.value || 0}
HP: ${unit.hp}/${unit.maxHp} | æœå‘: ${directionIcon}${directionText} | ä½ç½®: (${unit.x}, ${unit.y})
å£«æ°”: ${moraleText} | ç§©åº: ${orderText} | æˆ˜æ–—çŠ¶æ€: ${combatText}
å†²é”‹è¿‘æˆ˜: ${unit.chargeAttack} | æŒç»­è¿‘æˆ˜: ${unit.sustainedMelee} | æ”¯æ´è¿‘æˆ˜: ${unit.supportMelee}
æŠ•æ·æ”»å‡»: ${unit.throwingAttack} | å°„å‡»æ”»å‡»: ${unit.rangedAttack} | é˜²å¾¡èƒ½åŠ›: ${unit.defense}
ä¼¤äº¡æ‰¿å—åŠ›: ${unit.casualtyTolerance} | å°„ç¨‹: ${unit.range} | ç§»åŠ¨: ${unit.movement}
ç‰¹æ®ŠæŠ€èƒ½: ${unit.specialSkills.join(', ')}${unit.leadership > 0 ? `\né¢†å¯¼åŠ›: ${unit.leadership}` : ''}
è¡ŒåŠ¨çŠ¶æ€: ç§»åŠ¨${unit.hasMoved ? 'âœ…' : 'â­•'} | å°„å‡»${unit.hasRangedAttacked ? 'âœ…' : 'â­•'} | è¿‘æˆ˜${unit.hasMeleeAttacked ? 'âœ…' : 'â­•'}`;
                
                unitDiv.title = tooltipText;

                // æ·»åŠ HPæ¡
                if (this.showUnitInfo && unit.hp < unit.maxHp) {
                    const hpBar = document.createElement('div');
                    hpBar.className = 'hp-bar';
                    hpBar.style.cssText = `
                        position: absolute;
                        bottom: -6px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: ${size.width * squareSize - 16}px;
                        height: 4px;
                        background: rgba(0,0,0,0.6);
                        border-radius: 1px;
                        overflow: hidden;
                    `;
                    
                    const hpFill = document.createElement('div');
                    hpFill.style.cssText = `
                        width: ${hpPercentage}%;
                        height: 100%;
                        background: ${hpColor};
                        transition: all 0.3s ease;
                    `;
                    
                    hpBar.appendChild(hpFill);
                    unitDiv.appendChild(hpBar);
                }

                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                unitDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('å•ä½å…ƒç´ è¢«ç‚¹å‡»!', unit.name);
                    this.handleUnitClick(unit, e);
                });

                // åœ¨éƒ¨ç½²é˜¶æ®µä¸ºå½“å‰éƒ¨ç½²æ–¹çš„å•ä½æ·»åŠ æ‹–æ‹½åŠŸèƒ½
                if (this.currentPhase === 'deployment' && unit.faction === this.deploymentPhase) {
                    unitDiv.style.cursor = 'grab';
                    
                    unitDiv.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startDrag(unit, e);
                    });
                }

                // å³é”®ç‚¹å‡»è°ƒæ•´æ–¹å‘
                unitDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.handleDirectionChange(unit.x, unit.y, e);
                });

                return unitDiv;
            }

            handleSquareClick(x, y, event) {
                console.log(`ç‚¹å‡»ä½ç½®: (${x}, ${y}), å½“å‰é˜¶æ®µ: ${this.currentPhase}`);
                
                // æ£€æŸ¥å½“å‰é˜¶æ®µæ˜¯å¦å…è®¸æ“ä½œ
                if (this.currentPhase === 'deployment') {
                    // éƒ¨ç½²é˜¶æ®µä¸å…è®¸ç‚¹å‡»æ“ä½œï¼Œåªå…è®¸æ‹–æ‹½
                    console.log('éƒ¨ç½²é˜¶æ®µï¼Œå¿½ç•¥ç‚¹å‡»');
                    return;
                }
                
                if (this.currentPhase === 'turning') {
                    // è½¬å‘é˜¶æ®µåªå…è®¸å³é”®è½¬å‘ï¼Œä¸å…è®¸ç‚¹å‡»æ“ä½œ
                    console.log('è½¬å‘é˜¶æ®µï¼Œå¿½ç•¥ç‚¹å‡»');
                    return;
                }
                
                if (this.currentPhase !== 'movement' && this.currentPhase !== 'ranged' && this.currentPhase !== 'melee') {
                    console.log('éæ³•é˜¶æ®µï¼Œå¿½ç•¥ç‚¹å‡»');
                    return;
                }
                
                const clickedUnit = this.findUnitAtPosition(x, y);
                console.log('ç‚¹å‡»ä½ç½®çš„å•ä½:', clickedUnit ? clickedUnit.name : 'æ— å•ä½');
                
                // æ£€æŸ¥åŒå‡»å°„å‡»ï¼ˆåœ¨ handleSquareClick ä¸­ä¹Ÿéœ€è¦æ£€æµ‹ï¼Œå› ä¸ºç‚¹å‡»å¤§å•ä½æ—¶å¯èƒ½è§¦å‘æ–¹æ ¼ç‚¹å‡»è€Œä¸æ˜¯å•ä½ç‚¹å‡»ï¼‰
                if (clickedUnit && clickedUnit.faction !== this.currentPlayer && this.currentPhase === 'ranged') {
                    const currentTime = Date.now();
                    const timeDiff = currentTime - this.lastClickTime;
                    const isSameUnit = this.lastClickedUnit && this.lastClickedUnit.id === clickedUnit.id;
                    
                    console.log(`[æ–¹æ ¼åŒå‡»æ£€æµ‹] æ—¶é—´å·®=${timeDiff}ms, ç›¸åŒå•ä½=${isSameUnit}, ä¸Šæ¬¡å•ä½=${this.lastClickedUnit?.name}`);
                    
                    // å¦‚æœåŒå‡»åŒä¸€ä¸ªæ•Œæ–¹å•ä½ä¸”å·²é€‰æ‹©æ”»å‡»è€…ï¼Œç›´æ¥æ‰§è¡Œå°„å‡»
                    if ((this.moveState === 'target_selected' || this.moveState === 'unit_selected') && 
                        this.selectedUnit && 
                        isSameUnit && 
                        timeDiff < 600 && timeDiff > 10) {
                        
                        console.log(`âœ¨ [æ–¹æ ¼åŒå‡»] æ£€æµ‹åˆ°åŒå‡»å°„å‡»: ${this.selectedUnit.name} â†’ ${clickedUnit.name}`);
                        
                        if (this.canAttackInCurrentPhase(this.selectedUnit, clickedUnit)) {
                            console.log('ğŸ¯ [æ–¹æ ¼åŒå‡»] åŒå‡»å°„å‡»ç›®æ ‡æœ‰æ•ˆï¼Œæ‰§è¡Œå°„å‡»');
                            this.addGameLog(`âš¡ åŒå‡»å¿«é€Ÿå°„å‡»: ${this.selectedUnit.name} â†’ ${clickedUnit.name}`);
                            
                            // ç›´æ¥æ‰§è¡Œæ”»å‡»
                            this.executeAttack(this.selectedUnit, clickedUnit);
                            this.resetMoveState();
                            setTimeout(() => {
                                this.renderBoard();
                                this.updateUI();
                            }, 1000);
                            
                            // é‡ç½®åŒå‡»æ£€æµ‹å˜é‡
                            this.lastClickTime = 0;
                            this.lastClickedUnit = null;
                            return; // ç«‹å³è¿”å›ï¼Œä¸æ‰§è¡Œåç»­é€»è¾‘
                        }
                    }
                }

                switch (this.moveState) {
                    case 'none':
                        // è¿‘æˆ˜é˜¶æ®µä½¿ç”¨ç‰¹æ®Šå¤„ç†é€»è¾‘
                        if (this.currentPhase === 'melee') {
                            if (clickedUnit) {
                                this.handleMeleePhaseClick(clickedUnit);
                            }
                            return;
                        }
                        
                        // ç¬¬ä¸€æ­¥ï¼šé€‰æ‹©å•ä½
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            // æ£€æŸ¥é€šç”¨çŠ¶æ€ï¼šè¿‘æˆ˜ä¸­å’Œæ”¯æ´ä¸­çš„éƒ¨é˜Ÿä¸èƒ½ç§»åŠ¨å’Œå°„å‡»
                                if (clickedUnit.combatStatus === 'engaged') {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æ­£å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼Œæ— æ³•ç§»åŠ¨æˆ–å°„å‡»');
                                    return;
                                }
                            if (clickedUnit.combatStatus === 'supporting') {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æ­£åœ¨æ”¯æ´ä¸­ï¼Œæ— æ³•ç§»åŠ¨æˆ–å°„å‡»');
                                return;
                            }
                            
                            // æ£€æŸ¥æ··ä¹±çŠ¶æ€ï¼šæ··ä¹±çš„å•ä½ä¸èƒ½ç§»åŠ¨
                            if (this.currentPhase === 'movement' && clickedUnit.order === 'chaotic') {
                                this.addGameLog('âš ï¸ è¯¥å•ä½ç§©åºæ··ä¹±ï¼Œæ— æ³•ç§»åŠ¨ï¼è¯·ç­‰å¾…ä¸‹å›åˆæ¢å¤æµ‹è¯•');
                                return;
                            }
                            
                            // æ£€æŸ¥é˜¶æ®µç‰¹å®šæ¡ä»¶
                            if (this.currentPhase === 'ranged') {
                                if (clickedUnit.rangedAttack === 0 && clickedUnit.throwingAttack === 0) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æ²¡æœ‰è¿œç¨‹æ”»å‡»èƒ½åŠ›');
                                    return;
                                }
                                if (clickedUnit.hasRangedAttacked) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»è¿›è¡Œè¿‡å°„å‡»');
                                    return;
                                }
                            } else if (this.currentPhase === 'movement') {
                                if (clickedUnit.hasMoved) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»ç§»åŠ¨è¿‡');
                                    return;
                                }
                            }
                            this.selectUnit(clickedUnit);
                        }
                        break;

                    case 'unit_selected':
                        // è¿‘æˆ˜é˜¶æ®µä½¿ç”¨ç‰¹æ®Šå¤„ç†
                        if (this.currentPhase === 'melee') {
                            this.handleMeleePhaseClick(clickedUnit);
                            return;
                        }
                        
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            // æ£€æŸ¥èƒ½å¦é‡æ–°é€‰æ‹©è¯¥å•ä½
                            let canSelect = true;
                            if (this.currentPhase === 'ranged' && clickedUnit.hasRangedAttacked) {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»è¿›è¡Œè¿‡å°„å‡»');
                                canSelect = false;
                            } else if (this.currentPhase === 'movement' && clickedUnit.hasMoved) {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»ç§»åŠ¨è¿‡');
                                canSelect = false;
                            }
                            
                            if (canSelect) {
                            this.selectUnit(clickedUnit);
                            }
                        } else if (clickedUnit && clickedUnit.faction !== this.currentPlayer) {
                            // é€‰æ‹©æ”»å‡»ç›®æ ‡ï¼ˆæ ¹æ®é˜¶æ®µåˆ¤æ–­æ”»å‡»ç±»å‹ï¼‰
                            console.log(`å°è¯•æ”»å‡»ç›®æ ‡: ${clickedUnit.name} åœ¨ (${clickedUnit.x}, ${clickedUnit.y})`);
                            if (this.canAttackInCurrentPhase(this.selectedUnit, clickedUnit)) {
                                console.log('ç›®æ ‡å¯ä»¥æ”»å‡»ï¼Œé€‰æ‹©ä¸ºæ”»å‡»ç›®æ ‡');
                                this.selectAttackTarget(clickedUnit);
                            } else if (this.currentPhase === 'ranged') {
                                // å°„å‡»é˜¶æ®µçš„ç‰¹æ®Šæç¤º
                                const distance = this.getDistance(this.selectedUnit.x, this.selectedUnit.y, clickedUnit.x, clickedUnit.y);
                                
                                if (this.selectedUnit.combatStatus === 'engaged') {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æ­£å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼Œæ— æ³•è¿›è¡Œå°„å‡»');
                                } else if (this.selectedUnit.rangedAttack === 0 && this.selectedUnit.throwingAttack === 0) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æ²¡æœ‰è¿œç¨‹æ”»å‡»èƒ½åŠ›');
                                } else if (clickedUnit.combatStatus === 'engaged') {
                                    this.addGameLog('âš ï¸ ç›®æ ‡æ­£å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼Œæ— æ³•å°„å‡»');
                                } else if (distance > this.selectedUnit.range) {
                                    this.addGameLog(`âš ï¸ ç›®æ ‡è·ç¦»${distance}ï¼Œè¶…å‡ºå°„ç¨‹${this.selectedUnit.range}`);
                                } else if (!this.hasLineOfSight(this.selectedUnit, clickedUnit)) {
                                    this.addGameLog('ğŸš« å°„å‡»è·¯å¾„è¢«é˜»æŒ¡ï¼æ— æ³•å°„å‡»è¯¥ç›®æ ‡');
                                } else {
                                    this.addGameLog(`âš ï¸ æ— æ³•å°„å‡»è¯¥ç›®æ ‡ (è·ç¦»:${distance}, å°„ç¨‹:${this.selectedUnit.range})`);
                                }
                            }
                        } else if (!clickedUnit && this.currentPhase === 'movement') {
                            // å¼€å§‹ç§»åŠ¨è§„åˆ’ï¼ˆä»…åœ¨ç§»åŠ¨é˜¶æ®µï¼‰
                            this.startMovePlanning(x, y);
                        }
                        break;

                    case 'planning':
                        // è¿‘æˆ˜é˜¶æ®µä½¿ç”¨ç‰¹æ®Šå¤„ç†
                        if (this.currentPhase === 'melee') {
                            if (clickedUnit) {
                                this.handleMeleePhaseClick(clickedUnit);
                            }
                            return;
                        }
                        
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer && !clickedUnit.hasMoved) {
                            // é‡æ–°é€‰æ‹©å•ä½
                            this.selectUnit(clickedUnit);
                        } else if (!clickedUnit) {
                            // æ·»åŠ è§„åˆ’æ­¥éª¤
                            this.addMoveStep(x, y);
                        }
                        break;

                    case 'target_selected':
                        // è¿‘æˆ˜é˜¶æ®µä½¿ç”¨ç‰¹æ®Šå¤„ç†
                        if (this.currentPhase === 'melee') {
                            if (clickedUnit) {
                                this.handleMeleePhaseClick(clickedUnit);
                            }
                            return;
                        }
                        
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            // é‡æ–°é€‰æ‹©å·±æ–¹å•ä½
                            let canSelect = true;
                            if (this.currentPhase === 'ranged' && clickedUnit.hasRangedAttacked) {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»è¿›è¡Œè¿‡å°„å‡»');
                                canSelect = false;
                            } else if (this.currentPhase === 'movement' && clickedUnit.hasMoved) {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»ç§»åŠ¨è¿‡');
                                canSelect = false;
                            }
                            
                            if (canSelect) {
                                this.selectUnit(clickedUnit);
                            }
                        } else if (clickedUnit && clickedUnit.faction !== this.currentPlayer) {
                            // æ£€æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä¸ªç›®æ ‡
                            const isSameTarget = this.targetPosition && this.targetPosition.target && 
                                               this.targetPosition.target.id === clickedUnit.id;
                            
                            if (isSameTarget) {
                                // é‡å¤ç‚¹å‡»åŒä¸€ä¸ªç›®æ ‡ï¼Œä¸åšä»»ä½•æ“ä½œï¼ˆç­‰å¾…åŒå‡»æ£€æµ‹æˆ–æ‰§è¡ŒæŒ‰é’®ï¼‰
                                console.log(`é‡å¤é€‰æ‹©åŒä¸€ç›®æ ‡: ${clickedUnit.name}ï¼Œç­‰å¾…åŒå‡»æˆ–ç‚¹å‡»æ‰§è¡ŒæŒ‰é’®`);
                            } else {
                            // é‡æ–°é€‰æ‹©æ”»å‡»ç›®æ ‡
                            console.log(`é‡æ–°é€‰æ‹©æ”»å‡»ç›®æ ‡: ${clickedUnit.name} åœ¨ (${clickedUnit.x}, ${clickedUnit.y})`);
                            if (this.canAttackInCurrentPhase(this.selectedUnit, clickedUnit)) {
                                console.log('æ–°ç›®æ ‡å¯ä»¥æ”»å‡»ï¼Œæ›´æ–°æ”»å‡»ç›®æ ‡');
                                this.selectAttackTarget(clickedUnit);
                                this.addGameLog(`ğŸ¯ æ›´æ¢æ”»å‡»ç›®æ ‡ä¸º: ${clickedUnit.name}`);
                            } else if (this.currentPhase === 'ranged') {
                                // å°„å‡»é˜¶æ®µçš„ç‰¹æ®Šæç¤º
                                const distance = this.getDistance(this.selectedUnit.x, this.selectedUnit.y, clickedUnit.x, clickedUnit.y);
                                
                                if (this.selectedUnit.combatStatus === 'engaged') {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æ­£å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼Œæ— æ³•è¿›è¡Œå°„å‡»');
                                } else if (this.selectedUnit.rangedAttack === 0 && this.selectedUnit.throwingAttack === 0) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½æ²¡æœ‰è¿œç¨‹æ”»å‡»èƒ½åŠ›');
                                } else if (clickedUnit.combatStatus === 'engaged') {
                                    this.addGameLog('âš ï¸ ç›®æ ‡æ­£å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼Œæ— æ³•å°„å‡»');
                                } else if (distance > this.selectedUnit.range) {
                                    this.addGameLog(`âš ï¸ ç›®æ ‡è·ç¦»${distance}ï¼Œè¶…å‡ºå°„ç¨‹${this.selectedUnit.range}`);
                                } else if (!this.hasLineOfSight(this.selectedUnit, clickedUnit)) {
                                    this.addGameLog('ğŸš« å°„å‡»è·¯å¾„è¢«é˜»æŒ¡ï¼æ— æ³•å°„å‡»è¯¥ç›®æ ‡');
                                } else {
                                    this.addGameLog(`âš ï¸ æ— æ³•å°„å‡»è¯¥ç›®æ ‡ (è·ç¦»:${distance}, å°„ç¨‹:${this.selectedUnit.range})`);
                                    }
                                }
                            }
                        }
                        break;
                }
                
                // åœ¨ handleSquareClick ç»“æŸæ—¶ä¹Ÿæ›´æ–°åŒå‡»è®°å½•ï¼ˆç”¨äºæ–¹æ ¼ç‚¹å‡»çš„æƒ…å†µï¼‰
                if (this.currentPhase === 'ranged' && clickedUnit && clickedUnit.faction !== this.currentPlayer) {
                    this.lastClickTime = Date.now();
                    this.lastClickedUnit = clickedUnit;
                    console.log(`ğŸ“ [æ–¹æ ¼ç‚¹å‡»] è®°å½•ç›®æ ‡ç‚¹å‡»: ${clickedUnit.name} at ${this.lastClickTime}`);
                }

                this.updateUI();
            }

            selectUnit(unit) {
                this.selectedUnit = unit;
                this.targetPosition = null;
                this.movePlan = [];
                this.currentPlanStep = 0;
                this.moveState = 'unit_selected';
                this.updateMoveButtons();
                
                console.log(`é€‰æ‹©å•ä½: ${unit.name} (${unit.type}) åœ¨ (${unit.x}, ${unit.y})`);
                console.log(`å•ä½å±æ€§: å°„å‡»${unit.rangedAttack}, æŠ•æ·${unit.throwingAttack}, å°„ç¨‹${unit.range}`);
                console.log(`å½“å‰é˜¶æ®µ: ${this.currentPhase}`);
                
                // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ï¼Œç¡®ä¿æ‰€æœ‰å•ä½éƒ½æ˜¾ç¤º
                this.renderBoard();
                // æ˜¾ç¤ºæ‰€æœ‰å ä½é¢„è§ˆ
                this.showAllPlannedOccupations();
                
                // å»¶è¿Ÿæ‰§è¡Œé«˜äº®ï¼Œç¡®ä¿DOMå·²æ›´æ–°
                setTimeout(() => {
                    this.highlightCurrentStepMoves();
                }, 10);
            }

            selectAttackTarget(unit) {
                // å°„å‡»é˜¶æ®µéœ€è¦ç¡®è®¤
                if (this.currentPhase === 'ranged') {
                    this.rangedAttacker = this.selectedUnit;
                    this.rangedTarget = unit;
                    this.moveState = 'target_selected';
                    this.updateMoveButtons();
                    console.log(`é€‰æ‹©å°„å‡»ç›®æ ‡: ${unit.name} åœ¨ (${unit.x}, ${unit.y}), ç­‰å¾…ç¡®è®¤`);
                    this.addGameLog(`ğŸ¯ å·²é€‰æ‹©ç›®æ ‡ï¼š${unit.name}ï¼Œç‚¹å‡»"ç¡®è®¤å°„å‡»"æŒ‰é’®æ‰§è¡Œå°„å‡»`);
                    
                    // å»¶è¿Ÿæ‰§è¡Œé«˜äº®æ›´æ–°
                    setTimeout(() => {
                        this.highlightAttackTarget(unit);
                    }, 10);
                } else {
                    // å…¶ä»–é˜¶æ®µçš„æ­£å¸¸å¤„ç†
                    this.targetPosition = { x: unit.x, y: unit.y, action: 'attack', target: unit };
                    this.moveState = 'target_selected';
                    this.updateMoveButtons();
                    
                    console.log(`é€‰æ‹©æ”»å‡»ç›®æ ‡: ${unit.name} åœ¨ (${unit.x}, ${unit.y})`);
                    
                    // å»¶è¿Ÿæ‰§è¡Œé«˜äº®æ›´æ–°
                    setTimeout(() => {
                        this.highlightAttackTarget(unit);
                    }, 10);
                }
            }

            highlightAttackTarget(unit) {
                this.clearHighlights();
                this.highlightUnitElement(this.selectedUnit, 'selected');
                this.highlightUnitElement(unit, 'target-selected');
            }

            startMovePlanning(x, y) {
                if (!this.canMoveToStep(this.selectedUnit, x, y, 0)) {
                    console.log('æ— æ³•ç§»åŠ¨åˆ°è¯¥ä½ç½®');
                    return;
                }
                
                this.movePlan = [{
                    startX: this.selectedUnit.x,
                    startY: this.selectedUnit.y,
                    endX: x,
                    endY: y
                }];
                this.currentPlanStep = 0;
                this.moveState = 'planning';
                
                console.log(`å¼€å§‹è§„åˆ’ç¬¬1æ­¥: (${this.selectedUnit.x}, ${this.selectedUnit.y}) â†’ (${x}, ${y})`);
                
                this.updateMoveButtons();
                // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ï¼Œç¡®ä¿æ‰€æœ‰å•ä½éƒ½æ˜¾ç¤º
                this.renderBoard();
                // æ˜¾ç¤ºæ‰€æœ‰å ä½é¢„è§ˆ
                this.showAllPlannedOccupations();
                this.highlightCurrentStepMoves();
            }

            addMoveStep(x, y) {
                if (this.movePlan.length >= 3) {
                    console.log('æœ€å¤šåªèƒ½è§„åˆ’3æ­¥');
                    return;
                }

                const lastStep = this.movePlan[this.movePlan.length - 1];
                const stepNumber = this.movePlan.length;
                
                if (!this.canMoveToStep(this.selectedUnit, x, y, stepNumber)) {
                    console.log(`ç¬¬${stepNumber + 1}æ­¥æ— æ³•ç§»åŠ¨åˆ°è¯¥ä½ç½®`);
                    return;
                }

                this.movePlan.push({
                    startX: lastStep.endX,
                    startY: lastStep.endY,
                    endX: x,
                    endY: y
                });

                console.log(`æ·»åŠ ç¬¬${this.movePlan.length}æ­¥: (${lastStep.endX}, ${lastStep.endY}) â†’ (${x}, ${y})`);
                
                // å¦‚æœå·²è§„åˆ’ä¸‰æ­¥ï¼Œè‡ªåŠ¨å®Œæˆè§„åˆ’
                if (this.movePlan.length >= 3) {
                    console.log('å·²è§„åˆ’ä¸‰æ­¥ï¼Œè‡ªåŠ¨å®Œæˆè§„åˆ’');
                    this.finishPlanning();
                    return;
                }
                
                this.updateMoveButtons();
                // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ï¼Œç¡®ä¿æ‰€æœ‰å•ä½éƒ½æ˜¾ç¤º
                this.renderBoard();
                // æ˜¾ç¤ºæ‰€æœ‰å ä½é¢„è§ˆ
                this.showAllPlannedOccupations();
                this.highlightCurrentStepMoves();
            }

            addPlanStep() {
                // å‡†å¤‡æ·»åŠ ä¸‹ä¸€æ­¥ï¼Œæ›´æ–°é«˜äº®æ˜¾ç¤º
                console.log(`å‡†å¤‡è§„åˆ’ç¬¬${this.movePlan.length + 1}æ­¥`);
                this.highlightCurrentStepMoves();
            }

            finishPlanning() {
                if (this.movePlan.length === 0) {
                    console.log('è¯·è‡³å°‘è§„åˆ’ä¸€æ­¥ç§»åŠ¨');
                    return;
                }
                
                // ä¿å­˜å½“å‰å•ä½çš„è§„åˆ’ï¼ˆåŒ…å«å•ä½ä¿¡æ¯ç”¨äºæ¸²æŸ“ï¼‰
                this.allUnitPlans.set(this.selectedUnit.id, {
                    unit: this.selectedUnit,
                    plan: [...this.movePlan]
                });
                
                const unitTypeName = this.getUnitTypeName(this.selectedUnit.type);
                this.addGameLog(`âœ… ${unitTypeName}å®Œæˆç§»åŠ¨è§„åˆ’ï¼Œå…±${this.movePlan.length}æ­¥`);
                
                // é‡ç½®å½“å‰è§„åˆ’çŠ¶æ€ï¼Œå‡†å¤‡è§„åˆ’ä¸‹ä¸€ä¸ªå•ä½
                this.selectedUnit = null;
                this.movePlan = [];
                this.moveState = 'none';
                this.updateMoveButtons();
                this.clearHighlights();
                
                // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ï¼Œç¡®ä¿æ‰€æœ‰å•ä½éƒ½æ˜¾ç¤ºåœ¨åˆå§‹ä½ç½®
                this.renderBoard();
                // æ˜¾ç¤ºæ‰€æœ‰å ä½é¢„è§ˆ
                this.showAllPlannedOccupations();
                this.updateUI();
            }

            finishAllPlanning() {
                if (this.allUnitPlans.size === 0) {
                    console.log('è¯·è‡³å°‘ä¸ºä¸€ä¸ªå•ä½è§„åˆ’ç§»åŠ¨');
                    return;
                }
                
                this.planningPhase = 'executing';
                this.moveState = 'all_planned';
                this.updateMoveButtons();
                this.clearHighlights();
                
                // ä¿æŒæ˜¾ç¤ºæ‰€æœ‰è§„åˆ’è·¯å¾„
                this.drawAllMovePaths();
                
                this.addGameLog(`ğŸ¯ æ‰€æœ‰è§„åˆ’å®Œæˆï¼Œå…±${this.allUnitPlans.size}ä¸ªå•ä½æœ‰ç§»åŠ¨è®¡åˆ’ï¼Œå‡†å¤‡ç»Ÿä¸€æ‰§è¡Œ`);
            }

            async executePlan() {
                if (this.moveState === 'ready_to_execute' && this.movePlan.length > 0) {
                    // æŠ•æ·2D6
                    const dice1 = Math.floor(Math.random() * 6) + 1;
                    const dice2 = Math.floor(Math.random() * 6) + 1;
                    const diceTotal = dice1 + dice2;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                    const hasGeneral = this.units.some(u => 
                        u.type === 'general' && 
                        u.faction === this.selectedUnit.faction && 
                        u.hp > 0
                    );
                    
                    // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                    const leadership = this.getNearestGeneralLeadership(this.selectedUnit);
                    const result = diceTotal - leadership;
                    
                    // ç§»é™¤showDiceResultè°ƒç”¨ï¼Œç›´æ¥åœ¨è¿™é‡Œå¤„ç†
                    
                    // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                    let stepsToExecute = 0;
                    if (result <= -3) {
                        stepsToExecute = this.movePlan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                    } else if (result === -2) {
                        stepsToExecute = Math.min(2, this.movePlan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                    } else if (result >= -1 && result <= 1) {
                        stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                    } else if (result >= 2) {
                        stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                    }
                    
                    console.log(`2D6: ${dice1}+${dice2}=${diceTotal}, é¢†å¯¼åŠ›: ${leadership}, ç»“æœ: ${result}, æ‰§è¡Œæ­¥æ•°: ${stepsToExecute}`);
                    
                    // ç”Ÿæˆéª°å­ç»“æœæ–‡æœ¬
                    let resultText = `2D6æŠ•æ·ç»“æœä¸º${diceTotal}`;
                    if (hasGeneral) {
                        resultText += `ï¼Œ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                    } else {
                        resultText += `ï¼Œæ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                    }
                    
                    if (result <= -3) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${this.movePlan.length}æ­¥ç§»åŠ¨`;
                    } else if (result === -2) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, this.movePlan.length)}æ­¥ç§»åŠ¨`;
                    } else if (result >= -1 && result <= 1) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                    } else if (result >= 2) {
                        resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                    }
                    
                    // æ˜¾ç¤ºéª°å­ç»“æœåˆ°æ—¥å¿—
                    this.addGameLog(resultText);
                    
                    // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»ï¼‰
                    await this.executeUnitPlanWithAnimation(this.selectedUnit, this.movePlan, stepsToExecute);
                    
                    // é‡ç½®çŠ¶æ€
                    this.resetMoveState();
                    this.renderBoard();
                    this.updateUI();
                } else if (this.moveState === 'target_selected') {
                    // æ”»å‡»
                    this.executeAttack(this.selectedUnit, this.targetPosition.target);
                    this.resetMoveState();
                    setTimeout(() => {
                        this.renderBoard();
                        this.updateUI();
                    }, 1000);
                    this.updateUI();
                }
            }

            cancelMove() {
                this.resetMoveState();
                // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ï¼Œç¡®ä¿æ‰€æœ‰å•ä½éƒ½æ˜¾ç¤º
                this.renderBoard();
                // æ˜¾ç¤ºæ‰€æœ‰å ä½é¢„è§ˆ
                this.showAllPlannedOccupations();
                this.updateUI();
            }

            resetMoveState() {
                this.selectedUnit = null;
                this.targetPosition = null;
                this.movePlan = [];
                this.currentPlanStep = 0;
                this.moveState = 'none';
                this.rangedAttacker = null;
                this.rangedTarget = null;
                this.updateMoveButtons();
                this.clearHighlights();
                this.clearMovePath();
                this.clearPlannedOccupations();
                this.hideDiceResult();
            }

            resetAllPlans() {
                this.allUnitPlans.clear();
                this.planningPhase = 'planning';
                this.clearPlannedOccupations();
                this.resetMoveState();
            }

            updateMoveButtons() {
                console.log(`æ›´æ–°æŒ‰é’®: é˜¶æ®µ=${this.currentPhase}, çŠ¶æ€=${this.moveState}, éƒ¨ç½²é˜¶æ®µ=${this.deploymentPhase}`);
                
                const addStepBtn = document.getElementById('add-step-btn');
                const finishPlanBtn = document.getElementById('finish-plan-btn');
                const executeBtn = document.getElementById('execute-plan-btn');
                const finishAllBtn = document.getElementById('finish-all-plans-btn');
                const executeAllBtn = document.getElementById('execute-all-btn');
                const cancelBtn = document.getElementById('cancel-move-btn');
                const nextPhaseBtn = document.getElementById('next-phase-btn');
                const confirmDeployBtn = document.getElementById('confirm-deployment-btn');

                const finishAttackerSupportBtn = document.getElementById('finish-attacker-support-btn');
                const finishDefenderSupportBtn = document.getElementById('finish-defender-support-btn');
                const defenderRetreatBtn = document.getElementById('defender-retreat-btn');
                const defenderStandBtn = document.getElementById('defender-stand-btn');
                const executeChargeBtn = document.getElementById('execute-charge-btn');
                const confirmRangedBtn = document.getElementById('confirm-ranged-attack-btn');
                
                // éšè—æ‰€æœ‰ç§»åŠ¨å’Œè¿‘æˆ˜ç›¸å…³æŒ‰é’®
                [addStepBtn, finishPlanBtn, executeBtn, finishAllBtn, executeAllBtn, cancelBtn,
                 finishAttackerSupportBtn, finishDefenderSupportBtn, defenderRetreatBtn, defenderStandBtn, executeChargeBtn, confirmRangedBtn].forEach(btn => {
                    btn.style.display = 'none';
                });
                
                // è¿‘æˆ˜é˜¶æ®µçš„æŒ‰é’®æ˜¾ç¤º
                if (this.currentPhase === 'melee') {
                    switch (this.meleeSubPhase) {
                        case 'select_attacker':
                            // é€‰æ‹©å†²é”‹å•ä½é˜¶æ®µï¼Œä¸æ˜¾ç¤ºç‰¹æ®ŠæŒ‰é’®
                            break;
                        case 'select_target':
                            // é€‰æ‹©ç›®æ ‡é˜¶æ®µï¼Œä¸æ˜¾ç¤ºç‰¹æ®ŠæŒ‰é’®
                            break;
                        case 'defender_choose_retreat':
                            // é˜²å¾¡æ–¹é€‰æ‹©æ’¤é€€æˆ–æˆ˜æ–—
                            defenderRetreatBtn.style.display = 'inline-block';
                            defenderStandBtn.style.display = 'inline-block';
                            break;
                        case 'select_attacker_support':
                            finishAttackerSupportBtn.style.display = 'inline-block';
                            break;
                        case 'select_defender_support':
                            finishDefenderSupportBtn.style.display = 'inline-block';
                            break;
                        case 'execute_combat':
                            executeChargeBtn.style.display = 'inline-block';
                            break;
                    }
                    confirmDeployBtn.style.display = 'none';
                    
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æŒç»­è¿‘æˆ˜å•ä½å¾…å¤„ç†
                    const hasPendingSustainedMelee = this.getAvailableSustainedMeleeUnits().length > 0;
                    
                    if (hasPendingSustainedMelee && this.meleeSubPhase === 'select_attacker') {
                        // è¿˜æœ‰æŒç»­è¿‘æˆ˜æœªå®Œæˆï¼Œç¦ç”¨é˜¶æ®µåˆ‡æ¢
                        nextPhaseBtn.style.display = 'inline-block';
                        nextPhaseBtn.disabled = true;
                        nextPhaseBtn.title = 'æ‰€æœ‰æŒç»­è¿‘æˆ˜å®Œæˆåæ‰èƒ½è¿›å…¥ä¸‹ä¸€é˜¶æ®µ';
                    } else {
                        // æŒç»­è¿‘æˆ˜å·²å®Œæˆæˆ–æ­£åœ¨è¿›è¡Œä¸­ï¼Œå…è®¸æ­£å¸¸æ“ä½œ
                        nextPhaseBtn.style.display = 'inline-block';
                        nextPhaseBtn.disabled = false;
                        nextPhaseBtn.title = '';
                    }
                    return;
                }
                
                // æ ¹æ®é˜¶æ®µæ˜¾ç¤ºç›¸åº”æŒ‰é’®
                if (this.currentPhase === 'deployment') {
                    // éƒ¨ç½²é˜¶æ®µï¼Œåªæ˜¾ç¤ºç¡®è®¤éƒ¨ç½²æŒ‰é’®ï¼Œéšè—å…¶ä»–æ‰€æœ‰æŒ‰é’®
                    confirmDeployBtn.style.display = 'inline-block';
                    nextPhaseBtn.style.display = 'none';
                    return;
                } else if (this.currentPhase === 'turning') {
                    // è½¬å‘é˜¶æ®µï¼Œåªæ˜¾ç¤ºä¸‹ä¸€é˜¶æ®µæŒ‰é’®
                    confirmDeployBtn.style.display = 'none';
                    nextPhaseBtn.style.display = 'inline-block';
                    nextPhaseBtn.disabled = false;
                    // æ³¨æ„ï¼šæŒ‰é’®æ–‡æœ¬åœ¨åé¢ç»Ÿä¸€è®¾ç½®
                    // è¿™é‡Œä¸æå‰returnï¼Œè®©å®ƒç»§ç»­æ‰§è¡Œåé¢çš„é€»è¾‘
                } else if (this.currentPhase === 'movement') {
                    // ç§»åŠ¨é˜¶æ®µï¼Œæ ¹æ®moveStateæ˜¾ç¤ºå¯¹åº”æŒ‰é’®
                    confirmDeployBtn.style.display = 'none';
                    nextPhaseBtn.style.display = 'inline-block';
                    nextPhaseBtn.disabled = false;
                    nextPhaseBtn.title = '';
                    
                    // æ ¹æ®moveStateæ˜¾ç¤ºç§»åŠ¨è§„åˆ’æŒ‰é’®
                    if (this.moveState === 'planning' && this.movePlan.length > 0) {
                        // æ­£åœ¨è§„åˆ’ï¼Œæ˜¾ç¤ºæ·»åŠ æ­¥éª¤ã€å®Œæˆå•ä½è§„åˆ’å’Œå–æ¶ˆæŒ‰é’®
                        addStepBtn.style.display = 'inline-block';
                        finishPlanBtn.style.display = 'inline-block';
                        cancelBtn.style.display = 'inline-block';
                    }
                    
                    // å¦‚æœæœ‰å·²å®Œæˆè§„åˆ’çš„å•ä½ï¼Œæ˜¾ç¤ºå®Œæˆæ‰€æœ‰è§„åˆ’æŒ‰é’®
                    if (this.allUnitPlans.size > 0 && this.planningPhase === 'planning') {
                        finishAllBtn.style.display = 'inline-block';
                    }
                    
                    // å¦‚æœå¤„äºæ‰§è¡ŒçŠ¶æ€ï¼Œæ˜¾ç¤ºç»Ÿä¸€æ‰§è¡ŒæŒ‰é’®
                    if (this.moveState === 'all_planned' || (this.allUnitPlans.size > 0 && this.planningPhase === 'executing')) {
                        executeAllBtn.style.display = 'inline-block';
                    }
                } else if (this.currentPhase === 'ranged') {
                    // å°„å‡»é˜¶æ®µï¼Œä¸‹ä¸€é˜¶æ®µæŒ‰é’®æ°¸è¿œå¯ç”¨
                    confirmDeployBtn.style.display = 'none';
                    nextPhaseBtn.style.display = 'inline-block';
                    nextPhaseBtn.disabled = false;
                    nextPhaseBtn.title = '';
                    
                    // å¦‚æœå·²é€‰æ‹©å°„å‡»ç›®æ ‡ï¼Œæ˜¾ç¤ºç¡®è®¤å°„å‡»æŒ‰é’®
                    const confirmRangedBtn = document.getElementById('confirm-ranged-attack-btn');
                    if (this.moveState === 'target_selected' && this.rangedAttacker && this.rangedTarget) {
                        confirmRangedBtn.style.display = 'inline-block';
                    } else {
                        confirmRangedBtn.style.display = 'none';
                    }
                } else {
                    // å…¶ä»–é˜¶æ®µï¼Œæ˜¾ç¤ºä¸‹ä¸€é˜¶æ®µæŒ‰é’®
                    confirmDeployBtn.style.display = 'none';
                    nextPhaseBtn.style.display = 'inline-block';
                }

                // è®¾ç½®ä¸‹ä¸€é˜¶æ®µæŒ‰é’®æ–‡æœ¬
                if (this.currentPhase === 'movement') {
                    nextPhaseBtn.textContent = 'ä¸‹ä¸€é˜¶æ®µ';
                } else if (this.currentPhase === 'ranged') {
                    nextPhaseBtn.textContent = 'ä¸‹ä¸€é˜¶æ®µ';
                } else if (this.currentPhase === 'turning') {
                    nextPhaseBtn.textContent = 'ä¸‹ä¸€é˜¶æ®µ';
                } else if (this.currentPhase === 'melee') {
                    nextPhaseBtn.textContent = 'ç»“æŸå›åˆ';
                } else {
                    nextPhaseBtn.textContent = 'ä¸‹ä¸€é˜¶æ®µ';
                }
            }

            highlightPossibleMoves(unit) {
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                this.clearHighlights();

                // é«˜äº®é€‰ä¸­çš„å•ä½
                const selectedUnit = document.querySelector(`[data-unit-id="${unit.id}"]`);
                if (selectedUnit) {
                    selectedUnit.classList.add('selected');
                }

                // é«˜äº®å¯èƒ½çš„ç§»åŠ¨ä½ç½®
                const possibleMoves = this.getPossibleMoves(unit);
                possibleMoves.forEach(pos => {
                    this.highlightArea(pos.x, pos.y, this.unitSizes[unit.type], 'possible-move');
                });

                // é«˜äº®å¯èƒ½çš„æ”»å‡»ç›®æ ‡
                const attackTargets = this.getPossibleAttacks(unit);
                attackTargets.forEach(target => {
                    const targetUnit = target.unit;
                    if (targetUnit) {
                        const targetElement = document.querySelector(`[data-unit-id="${targetUnit.id}"]`);
                        if (targetElement) {
                            targetElement.style.boxShadow = '0 0 20px rgba(46, 204, 113, 0.8)';
                        }
                    }
                });

                // å¦‚æœå·²é€‰æ‹©ç›®æ ‡ä½ç½®ï¼Œé«˜äº®æ˜¾ç¤º
                if (this.targetPosition) {
                    if (this.targetPosition.action === 'move') {
                        this.highlightArea(this.targetPosition.x, this.targetPosition.y, this.unitSizes[unit.type], 'target-selected');
                    } else if (this.targetPosition.target) {
                        const targetElement = document.querySelector(`[data-unit-id="${this.targetPosition.target.id}"]`);
                        if (targetElement) {
                            targetElement.style.boxShadow = '0 0 25px rgba(155, 89, 182, 1)';
                        }
                    }
                }
            }

            highlightArea(x, y, size, className) {
                for (let dy = 0; dy < size.height; dy++) {
                    for (let dx = 0; dx < size.width; dx++) {
                        const targetX = x + dx;
                        const targetY = y + dy;
                        const square = document.querySelector(`[data-x="${targetX}"][data-y="${targetY}"]`);
                        if (square) {
                            square.classList.add(className);
                            console.log(`é«˜äº®æ ¼å­ (${targetX}, ${targetY}) æ·»åŠ ç±»: ${className}`);
                        } else {
                            console.log(`æœªæ‰¾åˆ°æ ¼å­ (${targetX}, ${targetY})`);
                        }
                    }
                }
            }

            highlightUnitElement(unit, className) {
                // é«˜äº®å•ä½å ç”¨çš„æ‰€æœ‰æ ¼å­
                const size = this.getUnitSizeWithDirection(unit);
                for (let dy = 0; dy < size.height; dy++) {
                    for (let dx = 0; dx < size.width; dx++) {
                        const targetX = unit.x + dx;
                        const targetY = unit.y + dy;
                        const square = document.querySelector(`[data-x="${targetX}"][data-y="${targetY}"]`);
                        if (square) {
                            square.classList.add(className);
                            console.log(`é«˜äº®å•ä½æ ¼å­ (${targetX}, ${targetY}) æ·»åŠ ç±»: ${className}`);
                        }
                    }
                }
                
                // ä¹Ÿé«˜äº®å•ä½å…ƒç´ æœ¬èº«
                const unitElements = document.querySelectorAll('.unit-large');
                unitElements.forEach(element => {
                    const elementUnit = this.units.find(u => 
                        u.x === parseInt(element.dataset.x) && 
                        u.y === parseInt(element.dataset.y)
                    );
                    if (elementUnit && elementUnit.id === unit.id) {
                        element.classList.add(className);
                        console.log(`é«˜äº®å•ä½å…ƒç´ : ${unit.type}`);
                    }
                });
            }

            getPossibleAttacks(unit) {
                const attacks = [];
                const directions = this.getSquareDirections();

                directions.forEach(dir => {
                    const newX = unit.x + dir.dx;
                    const newY = unit.y + dir.dy;
                    if (this.isValidPosition(newX, newY)) {
                        const targetUnit = this.gameBoard[newY][newX].unit;
                        if (targetUnit && targetUnit.faction !== unit.faction) {
                            // æ£€æŸ¥æ”»å‡»æ–¹å‘å½±å“
                            const attackBonus = this.getAttackBonus(unit, targetUnit);
                            attacks.push({ x: newX, y: newY, unit: targetUnit, bonus: attackBonus });
                        }
                    }
                });

                return attacks;
            }

            getPossibleMoves(unit) {
                const moves = [];
                
                // æ­£æ–¹å½¢ç½‘æ ¼çš„ç§»åŠ¨è®¡ç®—
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        if (this.canMoveTo(unit, x, y)) {
                            moves.push({ x, y });
                        }
                    }
                }

                return moves;
            }

            canMoveToStep(unit, x, y, stepNumber) {
                // è·å–å•ä½ç§»åŠ¨åŠ›
                const moveDistance = this.getUnitMoveDistance(unit);
                const size = this.unitSizes[unit.type];
                
                // è®¡ç®—èµ·å§‹ä½ç½®ï¼ˆå•ä½ä¸­å¿ƒç‚¹ï¼‰
                let centerX, centerY;
                if (stepNumber === 0) {
                    centerX = unit.x + Math.floor(size.width / 2);
                    centerY = unit.y + Math.floor(size.height / 2);
                } else if (this.movePlan.length >= stepNumber) {
                    const prevStep = this.movePlan[stepNumber - 1];
                    centerX = prevStep.endX + Math.floor(size.width / 2);
                    centerY = prevStep.endY + Math.floor(size.height / 2);
                } else {
                    return false;
                }
                
                // æ£€æŸ¥ä»ä¸­å¿ƒç‚¹åˆ°ç›®æ ‡ä½ç½®çš„è·ç¦»
                const distance = this.getDistance(centerX, centerY, x, y);
                if (distance > moveDistance) {
                    return false;
                }
                
                // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦åœ¨åœ°å›¾è¾¹ç•Œå†…
                if (!this.isValidUnitPosition(x, y, size)) {
                    return false;
                }
                
                // æ£€æŸ¥ç›®æ ‡åŒºåŸŸæ˜¯å¦è¢«å½“å‰å­˜åœ¨çš„å•ä½å ç”¨
                if (this.isAreaOccupiedByOthers(x, y, size.width, size.height, unit.id)) {
                    return false;
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å·²è§„åˆ’çš„å ä½å†²çª
                const conflictCheck = this.checkPlannedOccupationConflict(x, y, size.width, size.height, unit.id);
                if (conflictCheck.conflict) {
                    return false;
                }
                
                return true;
            }

            isAreaOccupiedByOthers(x, y, width, height, excludeUnitId) {
                // æ£€æŸ¥åŒºåŸŸæ˜¯å¦è¢«å…¶ä»–å•ä½å ç”¨
                for (let checkY = y; checkY < y + height; checkY++) {
                    for (let checkX = x; checkX < x + width; checkX++) {
                        if (checkX < 0 || checkX >= this.gridWidth || checkY < 0 || checkY >= this.gridHeight) {
                            return true; // è¶Šç•Œè§†ä¸ºè¢«å ç”¨
                        }
                        
                        const unitAtPos = this.findUnitAtPosition(checkX, checkY);
                        if (unitAtPos && unitAtPos.id !== excludeUnitId) {
                            return true;
                        }
                    }
                }
                return false;
            }

            getUnitMoveDistance(unit) {
                // ç›´æ¥è¿”å›å•ä½çš„movementå±æ€§
                return unit.movement || 3; // é»˜è®¤å€¼3ï¼Œé˜²æ­¢undefined
            }

            highlightCurrentStepMoves() {
                console.log('å¼€å§‹æ‰§è¡ŒhighlightCurrentStepMoves');
                this.clearHighlights();
                
                if (!this.selectedUnit) {
                    console.log('æ²¡æœ‰é€‰ä¸­çš„å•ä½');
                    return;
                }
                
                console.log(`é€‰ä¸­å•ä½: ${this.selectedUnit.type} åœ¨ (${this.selectedUnit.x}, ${this.selectedUnit.y})`);
                
                // é«˜äº®é€‰ä¸­çš„å•ä½
                this.highlightUnitElement(this.selectedUnit, 'selected');
                
                // åœ¨å°„å‡»é˜¶æ®µï¼Œé«˜äº®å°„ç¨‹èŒƒå›´å†…çš„æ–¹æ ¼å’Œæ•Œæ–¹å•ä½
                if (this.currentPhase === 'ranged') {
                    console.log(`å°„å‡»é˜¶æ®µï¼Œé«˜äº®å°„ç¨‹èŒƒå›´ï¼Œå°„ç¨‹: ${this.selectedUnit.range}`);
                    
                    // è·å–å•ä½ä¸­å¿ƒä½ç½®
                    const size = this.getUnitSizeWithDirection(this.selectedUnit);
                    const centerX = this.selectedUnit.x + Math.floor(size.width / 2);
                    const centerY = this.selectedUnit.y + Math.floor(size.height / 2);
                    
                    let rangeSquareCount = 0;
                    let targetCount = 0;
                    
                    // é«˜äº®å°„ç¨‹èŒƒå›´å†…çš„æ‰€æœ‰æ–¹æ ¼
                    const rangeDistance = this.selectedUnit.range;
                    for (let x = Math.max(0, centerX - rangeDistance); x <= Math.min(this.gridWidth - 1, centerX + rangeDistance); x++) {
                        for (let y = Math.max(0, centerY - rangeDistance); y <= Math.min(this.gridHeight - 1, centerY + rangeDistance); y++) {
                            const distance = this.getDistance(centerX, centerY, x, y);
                            if (distance <= rangeDistance) {
                                const square = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                                if (square) {
                                    square.classList.add('possible-move');
                                    rangeSquareCount++;
                                }
                            }
                        }
                    }
                    
                    console.log(`é«˜äº®äº†${rangeSquareCount}ä¸ªå°„ç¨‹èŒƒå›´å†…çš„æ–¹æ ¼`);
                    
                    // éå†æ‰€æœ‰æ•Œæ–¹å•ä½ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨å°„ç¨‹å†…
                    this.units.forEach(enemyUnit => {
                        if (enemyUnit.faction !== this.selectedUnit.faction && enemyUnit.hp > 0) {
                            // è®¡ç®—åˆ°æ•Œæ–¹å•ä½çš„è·ç¦»
                            const enemySize = this.getUnitSizeWithDirection(enemyUnit);
                            const enemyCenterX = enemyUnit.x + Math.floor(enemySize.width / 2);
                            const enemyCenterY = enemyUnit.y + Math.floor(enemySize.height / 2);
                            const distance = this.getDistance(centerX, centerY, enemyCenterX, enemyCenterY);
                            
                            // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”»å‡»ï¼ˆåœ¨å°„ç¨‹å†…ä¸”ç¬¦åˆæ”»å‡»æ¡ä»¶ï¼‰
                            if (this.canAttackInCurrentPhase(this.selectedUnit, enemyUnit)) {
                                // é«˜äº®è¯¥æ•Œæ–¹å•ä½
                                const enemyElement = document.querySelector(`[data-unit-id="${enemyUnit.id}"]`);
                                if (enemyElement) {
                                    enemyElement.style.boxShadow = '0 0 20px rgba(46, 204, 113, 0.8)';
                                    targetCount++;
                                }
                                console.log(`å¯æ”»å‡»ç›®æ ‡: ${enemyUnit.name}, è·ç¦»: ${distance}`);
                            } else if (distance <= this.selectedUnit.range) {
                                // åœ¨å°„ç¨‹å†…ä½†ä¸èƒ½æ”»å‡»ï¼ˆä¾‹å¦‚å¤„äºè¿‘æˆ˜çŠ¶æ€ï¼‰
                                console.log(`åœ¨å°„ç¨‹å†…ä½†ä¸å¯æ”»å‡»: ${enemyUnit.name}, è·ç¦»: ${distance}`);
                            }
                        }
                    });
                    
                    console.log(`é«˜äº®äº†${targetCount}ä¸ªå¯æ”»å‡»ç›®æ ‡`);
                    return;
                }
                
                // ç§»åŠ¨é˜¶æ®µï¼šé«˜äº®ä¸‹ä¸€æ­¥å¯ç§»åŠ¨çš„æ ¼å­
                if (this.movePlan.length < 3) {
                    // è®¡ç®—å½“å‰æ­¥éª¤çš„èµ·å§‹ä½ç½®ï¼ˆå•ä½ä¸­å¿ƒç‚¹ï¼‰
                    let centerX, centerY;
                    if (this.movePlan.length === 0) {
                        // ç¬¬ä¸€æ­¥ï¼šä»¥å½“å‰å•ä½ä½ç½®ä¸ºä¸­å¿ƒ
                        const size = this.unitSizes[this.selectedUnit.type];
                        centerX = this.selectedUnit.x + Math.floor(size.width / 2);
                        centerY = this.selectedUnit.y + Math.floor(size.height / 2);
                    } else {
                        // åç»­æ­¥éª¤ï¼šä»¥ä¸Šä¸€æ­¥è§„åˆ’çš„ç»ˆç‚¹ä¸ºä¸­å¿ƒ
                        const lastStep = this.movePlan[this.movePlan.length - 1];
                        const size = this.unitSizes[this.selectedUnit.type];
                        centerX = lastStep.endX + Math.floor(size.width / 2);
                        centerY = lastStep.endY + Math.floor(size.height / 2);
                    }
                    
                    console.log(`é«˜äº®ç¬¬${this.movePlan.length + 1}æ­¥ï¼Œä¸­å¿ƒä½ç½®: (${centerX}, ${centerY})`);
                    
                    // è·å–ç§»åŠ¨åŠ›
                    const moveDistance = this.getUnitMoveDistance(this.selectedUnit);
                    let highlightCount = 0;
                    
                    // é«˜äº®é€»è¾‘ï¼šåªé«˜äº®å®é™…å¯ä»¥è§„åˆ’çš„ä½ç½®
                    const stepNumber = this.movePlan.length;
                    for (let x = Math.max(0, centerX - moveDistance); x <= Math.min(this.gridWidth - 1, centerX + moveDistance); x++) {
                        for (let y = Math.max(0, centerY - moveDistance); y <= Math.min(this.gridHeight - 1, centerY + moveDistance); y++) {
                            const distance = this.getDistance(centerX, centerY, x, y);
                            if (distance <= moveDistance) {
                                // ä½¿ç”¨canMoveToStepç¡®ä¿é«˜äº®çš„æ ¼å­å®é™…å¯ä»¥é€‰æ‹©
                                if (this.canMoveToStep(this.selectedUnit, x, y, stepNumber)) {
                                    const square = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                                    if (square) {
                                        square.classList.add('possible-move');
                                        highlightCount++;
                                    }
                                }
                            }
                        }
                    }
                    
                    console.log(`é«˜äº®äº†${highlightCount}ä¸ªå¯ç§»åŠ¨ä½ç½®ï¼Œç§»åŠ¨åŠ›: ${moveDistance}`);
                } else {
                    console.log('å·²è¾¾åˆ°æœ€å¤§è§„åˆ’æ­¥æ•°ï¼Œä¸æ˜¾ç¤ºé«˜äº®');
                }
            }

            isValidUnitPosition(x, y, size) {
                // æ£€æŸ¥å•ä½æ˜¯å¦èƒ½æ”¾åœ¨è¿™ä¸ªä½ç½®ï¼ˆä¸è¶…å‡ºè¾¹ç•Œï¼‰
                return x >= 0 && y >= 0 && 
                       x + size.width <= this.gridWidth && 
                       y + size.height <= this.gridHeight;
            }

            getSquareDirections() {
                // æ­£æ–¹å½¢ç½‘æ ¼çš„8ä¸ªæ–¹å‘ï¼ˆåŒ…æ‹¬å¯¹è§’çº¿ï¼‰
                return [
                    { dx: 0, dy: -1 },   // åŒ—
                    { dx: 1, dy: -1 },   // ä¸œåŒ—
                    { dx: 1, dy: 0 },    // ä¸œ
                    { dx: 1, dy: 1 },    // ä¸œå—
                    { dx: 0, dy: 1 },    // å—
                    { dx: -1, dy: 1 },   // è¥¿å—
                    { dx: -1, dy: 0 },   // è¥¿
                    { dx: -1, dy: -1 }   // è¥¿åŒ—
                ];
            }

            handleUnitClick(unit, event) {
                console.log(`å•ä½è¢«ç‚¹å‡»: ${unit.name} åœ¨ (${unit.x}, ${unit.y}), é˜µè¥: ${unit.faction}`);
                console.log(`å½“å‰çŠ¶æ€: ç©å®¶=${this.currentPlayer}, é˜¶æ®µ=${this.currentPhase}, ç§»åŠ¨çŠ¶æ€=${this.moveState}`);
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºåŒå‡» - é’ˆå¯¹å°„å‡»é˜¶æ®µçš„ç‰¹æ®Šå¤„ç†
                const currentTime = Date.now();
                const timeDiff = currentTime - this.lastClickTime;
                const isSameUnit = this.lastClickedUnit && this.lastClickedUnit.id === unit.id;
                
                console.log(`åŒå‡»æ£€æµ‹: æ—¶é—´å·®=${timeDiff}ms, ç›¸åŒå•ä½=${isSameUnit}, ä¸Šæ¬¡ç‚¹å‡»å•ä½=${this.lastClickedUnit?.name}`);
                console.log(`é€‰ä¸­çš„æ”»å‡»å•ä½: ${this.selectedUnit?.name}, ç§»åŠ¨çŠ¶æ€: ${this.moveState}`);
                
                // åœ¨å°„å‡»é˜¶æ®µï¼Œå¦‚æœåŒå‡»æ•Œæ–¹å•ä½ï¼ˆå·²é€‰æ‹©æ”»å‡»è€…æˆ–å·²é€‰æ‹©ç›®æ ‡ï¼‰ï¼Œç›´æ¥æ‰§è¡Œå°„å‡»
                if (this.currentPhase === 'ranged' && 
                    (this.moveState === 'target_selected' || this.moveState === 'unit_selected') && 
                    this.selectedUnit && 
                    unit.faction !== this.currentPlayer && 
                    isSameUnit && 
                    timeDiff < 600 && timeDiff > 10) { // 10-600mså†…çš„åŒå‡»
                    
                    console.log(`âœ¨ æ£€æµ‹åˆ°åŒå‡»å°„å‡»: ${this.selectedUnit.name} â†’ ${unit.name}`);
                    
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”»å‡»è¯¥ç›®æ ‡
                    if (this.canAttackInCurrentPhase(this.selectedUnit, unit)) {
                        console.log('ğŸ¯ åŒå‡»å°„å‡»ç›®æ ‡æœ‰æ•ˆï¼Œæ‰§è¡Œå°„å‡»');
                        this.addGameLog(`âš¡ åŒå‡»å¿«é€Ÿå°„å‡»: ${this.selectedUnit.name} â†’ ${unit.name}`);
                        
                        // ç›´æ¥æ‰§è¡Œæ”»å‡»
                        this.executeAttack(this.selectedUnit, unit);
                        this.resetMoveState();
                        setTimeout(() => {
                            this.renderBoard();
                            this.updateUI();
                        }, 1000);
                        
                        // é‡ç½®åŒå‡»æ£€æµ‹å˜é‡å¹¶ç«‹å³è¿”å›ï¼Œä¸æ‰§è¡Œåç»­é€»è¾‘
                        this.lastClickTime = 0;
                        this.lastClickedUnit = null;
                        return; // å…³é”®ï¼šç«‹å³è¿”å›ï¼Œä¸æ‰§è¡ŒhandleSquareClick
                    } else {
                        console.log('âŒ åŒå‡»å°„å‡»ç›®æ ‡æ— æ•ˆ');
                        this.addGameLog(`âŒ æ— æ³•å°„å‡»è¯¥ç›®æ ‡: ${unit.name}`);
                        // åŒå‡»å¤±è´¥ï¼Œé‡ç½®å˜é‡ä½†ç»§ç»­æ­£å¸¸æµç¨‹
                        this.lastClickTime = 0;
                        this.lastClickedUnit = null;
                    }
                }
                
                // æ­£å¸¸çš„å•å‡»å¤„ç†é€»è¾‘
                // è½¬å‘åˆ°handleSquareClickå¤„ç†
                    this.handleSquareClick(unit.x, unit.y, event);
                
                // åœ¨handleSquareClickä¹‹åæ›´æ–°åŒå‡»æ£€æµ‹çŠ¶æ€
                // åœ¨å°„å‡»é˜¶æ®µï¼Œé€‰æ‹©æ•Œæ–¹å•ä½åè®°å½•åŒå‡»ä¿¡æ¯
                if (this.currentPhase === 'ranged' && 
                    unit.faction !== this.currentPlayer) {
                    
                    // è®°å½•è¿™æ¬¡ç‚¹å‡»ç”¨äºä¸‹æ¬¡åŒå‡»æ£€æµ‹ï¼ˆä½¿ç”¨æ–°çš„æ—¶é—´æˆ³ï¼‰
                    this.lastClickTime = Date.now();
                    this.lastClickedUnit = unit;
                    console.log(`ğŸ“ è®°å½•ç›®æ ‡ç‚¹å‡»: ${unit.name} at ${this.lastClickTime}ï¼Œå†æ¬¡ç‚¹å‡»å¯è§¦å‘åŒå‡»å°„å‡»`);
                } else {
                    // å…¶ä»–æƒ…å†µæ¸…é™¤åŒå‡»è®°å½•
                    this.lastClickTime = 0;
                    this.lastClickedUnit = null;
                }
            }

            handleKeyPress(event) {
                // æ£€æµ‹ç©ºæ ¼é”®
                if (event.code === 'Space') {
                    event.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
                    
                    const currentTime = Date.now();
                    const timeDiff = currentTime - this.lastSpaceKeyTime;
                    
                    console.log(`ç©ºæ ¼é”®æŒ‰ä¸‹ï¼Œæ—¶é—´å·®=${timeDiff}ms, å½“å‰é˜¶æ®µ=${this.currentPhase}, ç§»åŠ¨çŠ¶æ€=${this.moveState}`);
                    
                    // æ£€æµ‹åŒå‡»ç©ºæ ¼é”®ï¼ˆé—´éš”å°äº600msï¼‰
                    if (timeDiff > 10 && timeDiff < 600) {
                        console.log(`æ£€æµ‹åˆ°åŒå‡»ç©ºæ ¼é”®`);
                        
                        // åœ¨è½¬å‘é˜¶æ®µï¼ŒåŒå‡»ç©ºæ ¼é”®å¿«é€Ÿå®Œæˆè½¬å‘é˜¶æ®µ
                        if (this.currentPhase === 'turning') {
                            console.log(`è½¬å‘é˜¶æ®µåŒå‡»ç©ºæ ¼é”®ï¼Œå¿«é€Ÿè¿›å…¥ä¸‹ä¸€é˜¶æ®µ`);
                            this.addGameLog(`âš¡ é€šè¿‡åŒå‡»ç©ºæ ¼é”®å¿«é€Ÿå®Œæˆè½¬å‘é˜¶æ®µ`);
                            this.nextPhase();
                            
                            // é‡ç½®æ—¶é—´ï¼Œé˜²æ­¢ä¸‰è¿å‡»
                            this.lastSpaceKeyTime = 0;
                            return;
                        }
                        
                        // åœ¨ç§»åŠ¨é˜¶æ®µï¼ŒåŒå‡»ç©ºæ ¼é”®å®Œæˆæ‰€æœ‰è§„åˆ’å¹¶æ‰§è¡Œ
                        if (this.currentPhase === 'movement') {
                            // å¦‚æœå½“å‰æœ‰æ­£åœ¨è§„åˆ’çš„å•ä½ï¼Œå…ˆå®Œæˆå®ƒçš„è§„åˆ’
                            if (this.moveState === 'planning' && this.selectedUnit && this.movePlan.length > 0) {
                                this.addGameLog(`âŒ¨ï¸ ${this.selectedUnit.name}é€šè¿‡å¿«æ·é”®å®Œæˆç§»åŠ¨è§„åˆ’`);
                                this.finishPlanning();
                            }
                            
                            // å®Œæˆæ‰€æœ‰è§„åˆ’å¹¶æ‰§è¡Œ
                            if (this.allUnitPlans.size > 0) {
                                this.addGameLog(`âš¡ é€šè¿‡åŒå‡»ç©ºæ ¼é”®å®Œæˆæ‰€æœ‰è§„åˆ’å¹¶å¼€å§‹æ‰§è¡Œ`);
                                this.finishAllPlanning();
                                
                                // ç¨ä½œå»¶è¿Ÿåæ‰§è¡Œç§»åŠ¨
                                setTimeout(async () => {
                                    const btn = document.getElementById('execute-all-btn');
                                    if (!btn.disabled) {
                                        btn.disabled = true;
                                        btn.textContent = 'æ‰§è¡Œä¸­...';
                                        
                                        try {
                                            await this.executeAllPlans();
                                        } catch (error) {
                                            console.error('æ‰§è¡Œè®¡åˆ’æ—¶å‡ºé”™:', error);
                                            this.addGameLog('âŒ æ‰§è¡Œè®¡åˆ’æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•');
                                        } finally {
                                            btn.disabled = false;
                                            btn.textContent = 'ç»Ÿä¸€æ‰§è¡Œ';
                                        }
                                    }
                                }, 100);
                            } else {
                                this.addGameLog(`âš ï¸ æ²¡æœ‰å•ä½è§„åˆ’éœ€è¦æ‰§è¡Œ`);
                            }
                            
                            // é‡ç½®æ—¶é—´ï¼Œé˜²æ­¢ä¸‰è¿å‡»
                            this.lastSpaceKeyTime = 0;
                            return;
                        }
                    }
                    
                    // å•å‡»ç©ºæ ¼é”®çš„å¤„ç†
                    
                    // å°„å‡»é˜¶æ®µï¼šå¦‚æœå·²é€‰æ‹©æ”»å‡»è€…å’Œç›®æ ‡ï¼ŒæŒ‰ç©ºæ ¼é”®æ‰§è¡Œå°„å‡»
                    if (this.currentPhase === 'ranged' && this.moveState === 'target_selected' && 
                        this.rangedAttacker && this.rangedTarget) {
                        console.log(`å°„å‡»é˜¶æ®µå•å‡»ç©ºæ ¼é”®ï¼Œå¿«é€Ÿæ‰§è¡Œå°„å‡»`);
                        this.addGameLog(`âš¡ é€šè¿‡ç©ºæ ¼é”®å¿«é€Ÿå°„å‡»: ${this.rangedAttacker.name} â†’ ${this.rangedTarget.name}`);
                        this.confirmRangedAttack();
                        
                        // é‡ç½®æ—¶é—´
                        this.lastSpaceKeyTime = currentTime;
                        return;
                    }
                    
                    // ç§»åŠ¨é˜¶æ®µï¼šå•å‡»ç©ºæ ¼é”®å®Œæˆå½“å‰å•ä½çš„ç§»åŠ¨è§„åˆ’
                    if (this.moveState === 'planning' && this.selectedUnit) {
                        console.log(`å•å‡»ç©ºæ ¼é”®ï¼Œç»“æŸå½“å‰å•ä½ç§»åŠ¨è§„åˆ’`);
                        this.addGameLog(`âŒ¨ï¸ ${this.selectedUnit.name}é€šè¿‡ç©ºæ ¼é”®å®Œæˆç§»åŠ¨è§„åˆ’`);
                        this.finishPlanning();
                    }
                    
                    // è®°å½•æœ¬æ¬¡ç©ºæ ¼é”®æŒ‰ä¸‹æ—¶é—´
                    this.lastSpaceKeyTime = currentTime;
                }
            }

            handleDirectionChange(x, y, event) {
                const unit = this.findUnitAtPosition(x, y);
                
                // æ£€æŸ¥æ˜¯å¦åœ¨è½¬å‘é˜¶æ®µï¼Œæˆ–è€…æ˜¯ç§»åŠ¨é˜¶æ®µä¸”å•ä½è¿˜æœªç§»åŠ¨
                const canChangeDirection = (this.currentPhase === 'turning') || 
                                         (this.currentPhase === 'movement' && !unit?.hasMoved);
                
                if (!canChangeDirection) {
                    if (this.currentPhase !== 'turning' && this.currentPhase !== 'movement') {
                        this.addGameLog('âš ï¸ åªèƒ½åœ¨ç§»åŠ¨é˜¶æ®µæˆ–è½¬å‘é˜¶æ®µè°ƒæ•´å•ä½æœå‘');
                    }
                    return;
                }
                
                if (unit && unit.faction === this.currentPlayer) {
                    // å¾ªç¯æ”¹å˜æ–¹å‘
                    const directions = ['north', 'east', 'south', 'west'];
                    const currentIndex = directions.indexOf(unit.direction);
                    const nextIndex = (currentIndex + 1) % directions.length;
                    const oldDirection = unit.direction;
                    unit.direction = directions[nextIndex];
                    
                    const directionNames = {
                        'north': 'ä¸Š',
                        'east': 'å³',
                        'south': 'ä¸‹',
                        'west': 'å·¦'
                    };
                    
                    this.addGameLog(`ğŸ”„ ${unit.name}è½¬å‘: ${directionNames[oldDirection]} â†’ ${directionNames[unit.direction]}`);
                    console.log(`${unit.type} è½¬å‘: ${unit.direction}`);
                    
                    // é‡æ–°æ¸²æŸ“æ•´ä¸ªæ£‹ç›˜ä»¥æ›´æ–°å•ä½æ˜¾ç¤º
                    this.renderBoard();
                    this.updateUI();
                }
            }

            // æ‹–æ‹½ç›¸å…³æ–¹æ³•
            startDrag(unit, event) {
                if (this.currentPhase !== 'deployment' || unit.faction !== this.deploymentPhase) {
                    return;
                }

                this.isDragging = true;
                this.draggedUnit = unit;
                
                const unitElement = document.querySelector(`[data-unit-id="${unit.id}"]`);
                if (unitElement) {
                    unitElement.style.cursor = 'grabbing';
                    unitElement.style.zIndex = '2000';
                    unitElement.style.opacity = '0.8';
                    
                    const rect = unitElement.getBoundingClientRect();
                    this.dragOffset.x = event.clientX - rect.left;
                    this.dragOffset.y = event.clientY - rect.top;
                }

                console.log(`å¼€å§‹æ‹–æ‹½: ${unit.name}`);
                this.addGameLog(`ğŸ“¦ å¼€å§‹æ‹–æ‹½ ${unit.name}`);
            }

            handleDrag(event) {
                if (!this.isDragging || !this.draggedUnit) {
                    return;
                }

                const container = document.getElementById('square-grid');
                const containerRect = container.getBoundingClientRect();
                
                // è®¡ç®—ç›¸å¯¹äºæ¸¸æˆå®¹å™¨çš„ä½ç½®
                const relativeX = event.clientX - containerRect.left - this.dragOffset.x;
                const relativeY = event.clientY - containerRect.top - this.dragOffset.y;

                const unitElement = document.querySelector(`[data-unit-id="${this.draggedUnit.id}"]`);
                if (unitElement) {
                    unitElement.style.left = relativeX + 'px';
                    unitElement.style.top = relativeY + 'px';
                }
            }

            endDrag(event) {
                if (!this.isDragging || !this.draggedUnit) {
                    return;
                }

                const container = document.getElementById('square-grid');
                const containerRect = container.getBoundingClientRect();
                const squareSize = 16;
                
                // è®¡ç®—æ–°çš„ç½‘æ ¼ä½ç½®
                const relativeX = event.clientX - containerRect.left - this.dragOffset.x;
                const relativeY = event.clientY - containerRect.top - this.dragOffset.y;
                
                const newGridX = Math.round(relativeX / squareSize);
                const newGridY = Math.round(relativeY / squareSize);

                // æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                if (this.isValidDeploymentPosition(this.draggedUnit, newGridX, newGridY)) {
                    // æ›´æ–°å•ä½ä½ç½®
                    this.draggedUnit.x = newGridX;
                    this.draggedUnit.y = newGridY;
                    this.addGameLog(`ğŸ“ ${this.draggedUnit.name} éƒ¨ç½²åˆ° (${newGridX}, ${newGridY})`);
                } else {
                    this.addGameLog(`âŒ æ— æ•ˆä½ç½®ï¼Œ${this.draggedUnit.name} å›åˆ°åŸä½`);
                }

                // é‡ç½®æ‹–æ‹½çŠ¶æ€
                const unitElement = document.querySelector(`[data-unit-id="${this.draggedUnit.id}"]`);
                if (unitElement) {
                    unitElement.style.cursor = 'grab';
                    unitElement.style.zIndex = '';
                    unitElement.style.opacity = '';
                }

                this.isDragging = false;
                this.draggedUnit = null;
                this.dragOffset = { x: 0, y: 0 };

                // é‡æ–°æ¸²æŸ“æ£‹ç›˜
                this.renderBoard();
                this.updateUI();
            }

            isValidDeploymentPosition(unit, x, y) {
                const size = this.getUnitSizeWithDirection(unit);
                
                // æ£€æŸ¥æ˜¯å¦åœ¨åœ°å›¾è¾¹ç•Œå†…
                if (x < 0 || y < 0 || x + size.width > this.gridWidth || y + size.height > this.gridHeight) {
                    return false;
                }

                // æ£€æŸ¥éƒ¨ç½²åŒºåŸŸé™åˆ¶
                if (unit.faction === 'rome') {
                    // ç½—é©¬éƒ¨ç½²åœ¨åœ°å›¾ä¸‹åŠéƒ¨åˆ†
                    if (y < this.gridHeight * 0.6) {
                        return false;
                    }
                } else if (unit.faction === 'carthage') {
                    // è¿¦å¤ªåŸºéƒ¨ç½²åœ¨åœ°å›¾ä¸ŠåŠéƒ¨åˆ†
                    if (y + size.height > this.gridHeight * 0.4) {
                        return false;
                    }
                }

                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å•ä½é‡å 
                for (let checkY = y; checkY < y + size.height; checkY++) {
                    for (let checkX = x; checkX < x + size.width; checkX++) {
                        const otherUnit = this.findUnitAtPosition(checkX, checkY);
                        if (otherUnit && otherUnit.id !== unit.id) {
                            return false;
                        }
                    }
                }

                return true;
            }

            confirmDeployment() {
                if (this.currentPhase !== 'deployment') {
                    return;
                }

                if (this.deploymentPhase === 'rome') {
                    this.deploymentPhase = 'carthage';
                    this.addGameLog(`âœ… ç½—é©¬éƒ¨ç½²å®Œæˆï¼Œè½®åˆ°è¿¦å¤ªåŸºéƒ¨ç½²`);
                    this.renderBoard();
                    this.updateUI();
                } else if (this.deploymentPhase === 'carthage') {
                    this.deploymentPhase = 'completed';
                    this.currentPhase = 'movement';
                    this.addGameLog(`âœ… è¿¦å¤ªåŸºéƒ¨ç½²å®Œæˆï¼Œæ¸¸æˆå¼€å§‹ï¼`);
                    this.addGameLog(`ğŸš¶ ğŸ›ï¸ ç½—é©¬å¼€å§‹è§„åˆ’å’Œç§»åŠ¨é˜¶æ®µ`);
                    this.renderBoard();
                    this.updateUI();
                }
            }

            findUnitAtPosition(x, y) {
                return this.units.find(unit => {
                    const size = this.getUnitSizeWithDirection(unit);
                    return x >= unit.x && x < unit.x + size.width &&
                           y >= unit.y && y < unit.y + size.height;
                });
            }

            isValidPosition(x, y) {
                return x >= 0 && x < this.gridWidth && y >= 0 && y < this.gridHeight;
            }

            executeMove(unit, newX, newY) {
                if (!this.canMoveTo(unit, newX, newY)) {
                    return false;
                }

                // ç§»åŠ¨å•ä½åˆ°æ–°ä½ç½®
                unit.x = newX;
                unit.y = newY;
                unit.hasMoved = true;

                console.log(`${unit.type} ç§»åŠ¨åˆ° (${newX}, ${newY})`);
                return true;
            }

            executeAttack(attacker, defender) {
                // æ ¹æ®å½“å‰é˜¶æ®µé€‰æ‹©æ”»å‡»ç±»å‹
                if (this.currentPhase === 'ranged') {
                    return this.executeRangedAttack(attacker, defender);
                } else if (this.currentPhase === 'melee') {
                    return this.executeMeleeAttack(attacker, defender);
                }
                return false;
            }

            // å°„å‡»æ”»å‡»é€»è¾‘
            executeRangedAttack(attacker, defender) {
                if (!this.canAttackInCurrentPhase(attacker, defender)) {
                    return false;
                }

                const attackerName = this.getUnitTypeName(attacker.type);
                const defenderName = this.getUnitTypeName(defender.type);
                
                // è·å–å°„å‡»æ”»å‡»æ•°å€¼ï¼ˆæŠ•æ·æˆ–å°„å‡»å±æ€§çš„è¾ƒå¤§å€¼ï¼‰
                let rangedAttackValue = Math.max(attacker.rangedAttack, attacker.throwingAttack);
                
                // ç›®æ ‡ç±»å‹ä¿®æ­£ï¼šéª‘å…µå’Œå¼“ç®­æ‰‹æ›´éš¾å‘½ä¸­
                if (defender.type === 'cavalry') {
                    rangedAttackValue = Math.max(0, rangedAttackValue - 1);
                    this.addGameLog(`ğŸ ç›®æ ‡ä¸ºéª‘å…µï¼Œå°„å‡»éª°å­æ•°-1`);
                } else if (defender.type === 'archer') {
                    rangedAttackValue = Math.max(0, rangedAttackValue - 1);
                    this.addGameLog(`ğŸ¹ ç›®æ ‡ä¸ºå¼“ç®­æ‰‹ï¼Œå°„å‡»éª°å­æ•°-1`);
                }
                
                this.addGameLog(`ğŸ¹ ${attackerName}å‘${defenderName}å°„å‡»ï¼ŒæŠ•æ·${rangedAttackValue}ä¸ªD6è¿›è¡Œå‘½ä¸­åˆ¤æ–­`);
                
                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰éª°å­å¯ä»¥æŠ•æ·
                if (rangedAttackValue <= 0) {
                    this.addGameLog(`âŒ å°„å‡»éª°å­æ•°ä¸º0ï¼Œæ— æ³•è¿›è¡Œæ”»å‡»`);
                    attacker.hasRangedAttacked = true;
                    return true;
                }
                
                // 1. å‘½ä¸­åˆ¤æ–­é˜¶æ®µ
                let hits = 0;
                const hitRolls = [];
                
                for (let i = 0; i < rangedAttackValue; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    hitRolls.push(roll);
                    
                    // åˆ¤æ–­å‘½ä¸­æ¡ä»¶
                    let hitThreshold = 4; // æ­£å¸¸çŠ¶æ€ï¼š4ã€5ã€6å‘½ä¸­
                    if (attacker.morale === 'shaken' || attacker.order === 'chaotic') {
                        hitThreshold = 5; // å£«æ°”åŠ¨æ‘‡æˆ–ç§©åºæ··ä¹±ï¼š5ã€6å‘½ä¸­
                    }
                    
                    if (roll >= hitThreshold) {
                        hits++;
                    }
                }
                
                // æ˜¾ç¤ºå‘½ä¸­åˆ¤æ–­ç»“æœ
                const statusText = attacker.morale === 'shaken' ? '(å£«æ°”åŠ¨æ‘‡)' : 
                                 attacker.order === 'chaotic' ? '(ç§©åºæ··ä¹±)' : '(æ­£å¸¸çŠ¶æ€)';
                this.addGameLog(`ğŸ² å‘½ä¸­åˆ¤æ–­${statusText}: [${hitRolls.join(', ')}] - ${hits}æ¬¡å‘½ä¸­`);
                
                if (hits === 0) {
                    this.addGameLog(`âŒ æ‰€æœ‰å°„å‡»éƒ½æœªå‘½ä¸­ç›®æ ‡`);
                    attacker.hasRangedAttacked = true;
                    
                    // æ’­æ”¾å°„å‡»åŠ¨ç”»å’ŒMISSæ•ˆæœ
                    this.showRangedAttackAnimation(attacker, defender, rangedAttackValue, () => {
                        this.showEnhancedDamageEffect(defender.x, defender.y, 0, {
                            isMiss: true,
                            attackType: 'ranged'
                        });
                    });
                    
                    return true;
                }
                
                // 2. é˜²å¾¡åˆ¤æ–­é˜¶æ®µ
                let finalDamage = 0;
                const defenseRolls = [];
                
                this.addGameLog(`ğŸ›¡ï¸ ${defenderName}è¿›è¡Œ${hits}æ¬¡é˜²å¾¡åˆ¤æ–­`);
                
                for (let i = 0; i < hits; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    defenseRolls.push(roll);
                    
                    // è®¡ç®—é˜²å¾¡é˜ˆå€¼
                    let defenseThreshold = defender.defense;
                    if (defender.morale === 'shaken' || defender.order === 'chaotic') {
                        defenseThreshold += 1; // å£«æ°”åŠ¨æ‘‡æˆ–ç§©åºæ··ä¹±æ—¶é˜²å¾¡+1
                    }
                    
                    if (roll < defenseThreshold) {
                        finalDamage++; // é˜²å¾¡å¤±è´¥ï¼Œé€ æˆ1ç‚¹ä¼¤å®³
                    }
                }
                
                // æ˜¾ç¤ºé˜²å¾¡åˆ¤æ–­ç»“æœ
                const defenderStatusText = defender.morale === 'shaken' ? '(å£«æ°”åŠ¨æ‘‡)' : 
                                          defender.order === 'chaotic' ? '(ç§©åºæ··ä¹±)' : '(æ­£å¸¸çŠ¶æ€)';
                const defenseThreshold = defender.defense + (defender.morale === 'shaken' || defender.order === 'chaotic' ? 1 : 0);
                this.addGameLog(`ğŸ² é˜²å¾¡åˆ¤æ–­${defenderStatusText}(éœ€â‰¥${defenseThreshold}): [${defenseRolls.join(', ')}] - ${finalDamage}æ¬¡é˜²å¾¡å¤±è´¥`);
                
                // 3. é€ æˆä¼¤å®³
                const totalDamage = finalDamage * 10;
                const wasShaken = defender.morale === 'shaken'; // è®°å½•å—ä¼¤å‰æ˜¯å¦å·²ç»åŠ¨æ‘‡
                defender.hp = Math.max(0, defender.hp - totalDamage);
                
                if (totalDamage > 0) {
                    this.addGameLog(`ğŸ’¥ ${defenderName}å—åˆ°${totalDamage}ç‚¹ä¼¤å®³ (${finalDamage}æ¬¡Ã—10)`);
                    
                    // æ˜¾ç¤ºå°„å‡»åŠ¨ç”»ï¼Œç„¶åæ˜¾ç¤ºå¢å¼ºæ”»å‡»æ•ˆæœ
                    this.showRangedAttackAnimation(attacker, defender, hits, () => {
                        const isCritical = finalDamage >= 3; // 3æ¬¡ä»¥ä¸Šä¼¤å®³ç®—æš´å‡»
                        this.showEnhancedDamageEffect(defender.x, defender.y, totalDamage, {
                            isCritical: isCritical,
                            comboCount: hits,
                            attackType: 'ranged'
                        });
                        this.updateUnitDisplay(defender);
                    });
                } else {
                    this.addGameLog(`ğŸ›¡ï¸ ${defenderName}æˆåŠŸé˜²å¾¡äº†æ‰€æœ‰æ”»å‡»`);
                    // å³ä½¿æ²¡æœ‰ä¼¤å®³ä¹Ÿæ˜¾ç¤ºå°„å‡»åŠ¨ç”»
                    this.showRangedAttackAnimation(attacker, defender, hits);
                }

                // æ£€æŸ¥å•ä½æ˜¯å¦HPå½’é›¶ - è¿›å…¥åŠ¨æ‘‡çŠ¶æ€ï¼ˆå°„å‡»é˜¶æ®µç›´æ¥è¿›å…¥åŠ¨æ‘‡ï¼Œä¸ä¼šç«‹å³æ¶ˆç­ï¼‰
                if (defender.hp <= 0 && defender.morale !== 'shaken') {
                    defender.morale = 'shaken';
                    this.addGameLog(`ğŸ˜° ${defenderName}å£«æ°”åŠ¨æ‘‡ï¼HPå½’é›¶`);
                    this.updateUnitDisplay(defender);
                }

                attacker.hasRangedAttacked = true;
                
                // å°„å‡»é˜¶æ®µå´©æºƒæµ‹è¯•ï¼šå½“ä¸”ä»…å½“ä¸€æ”¯åŠ¨æ‘‡çš„éƒ¨é˜Ÿè¢«è¿œç¨‹å°„å‡»å¹¶é€ æˆä¼¤å®³åæ‰§è¡Œ
                if (wasShaken && finalDamage > 0) {
                    this.addGameLog(`âš ï¸ ${defenderName}åŠ¨æ‘‡çŠ¶æ€ä¸‹å—åˆ°å°„å‡»ä¼¤å®³ï¼Œéœ€è¦è¿›è¡Œå´©æºƒæµ‹è¯•`);
                    console.log(`[executeRangedAttack] è§¦å‘å°„å‡»å´©æºƒæµ‹è¯•: å•ä½=${defenderName}, åŠ¨æ‘‡=${wasShaken}, ä¼¤å®³æ¬¡æ•°=${finalDamage}`);
                    
                    // å»¶è¿Ÿæ‰§è¡Œå´©æºƒæµ‹è¯•ï¼Œç­‰å¾…åŠ¨ç”»å®Œæˆ
                    setTimeout(() => {
                        this.performRangedRouteTest(defender, finalDamage);
                    }, 1500);
                }
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸ
                this.checkGameEnd();
                return true;
            }

            // å¤„ç†è¿‘æˆ˜é˜¶æ®µçš„ç‚¹å‡»
            handleMeleePhaseClick(clickedUnit) {
                console.log(`[è¿‘æˆ˜å¤„ç†] å­é˜¶æ®µ: ${this.meleeSubPhase}, ç‚¹å‡»å•ä½: ${clickedUnit?.name}, ç©å®¶: ${this.currentPlayer}`);
                
                switch (this.meleeSubPhase) {
                    case 'select_attacker':
                        // é€‰æ‹©è¿‘æˆ˜å•ä½ï¼ˆå†²é”‹æˆ–æŒç»­ï¼‰
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            // æ£€æŸ¥é€šç”¨æ¡ä»¶
                            if (clickedUnit.hasMeleeAttacked) {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æœ¬å›åˆå·²ç»è¿›è¡Œè¿‡è¿‘æˆ˜');
                                return false;
                            }
                            if (clickedUnit.combatStatus === 'supporting') {
                                this.addGameLog('âš ï¸ è¯¥å•ä½æ­£åœ¨æ”¯æ´ä¸­');
                                return false;
                            }
                            
                            // åˆ¤æ–­æ˜¯å†²é”‹è¿‘æˆ˜è¿˜æ˜¯æŒç»­è¿‘æˆ˜
                            if (clickedUnit.combatStatus === 'engaged') {
                                // æŒç»­è¿‘æˆ˜ï¼šå•ä½å·²å¤„äºè¿‘æˆ˜çŠ¶æ€
                                console.log(`[è¿‘æˆ˜å¤„ç†] æŒç»­è¿‘æˆ˜: ${clickedUnit.name}`);
                                
                                // æ£€æŸ¥æ˜¯å¦æœ‰åŸå¯¹æ‰‹
                                if (!clickedUnit.engagedWith) {
                                    this.addGameLog('âš ï¸ æ— æ³•æ‰¾åˆ°åŸè¿‘æˆ˜å¯¹æ‰‹');
                                    return false;
                                }
                                
                                // æ‰¾åˆ°åŸå¯¹æ‰‹
                                const opponent = this.units.find(u => u.id === clickedUnit.engagedWith);
                                if (!opponent) {
                                    this.addGameLog('âš ï¸ åŸè¿‘æˆ˜å¯¹æ‰‹å·²ä¸å­˜åœ¨');
                                    return false;
                                }
                                
                                // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦åœ¨3æ ¼å†…
                                const centerX = clickedUnit.x + Math.floor(this.getUnitSizeWithDirection(clickedUnit).width / 2);
                                const centerY = clickedUnit.y + Math.floor(this.getUnitSizeWithDirection(clickedUnit).height / 2);
                                const opponentCenterX = opponent.x + Math.floor(this.getUnitSizeWithDirection(opponent).width / 2);
                                const opponentCenterY = opponent.y + Math.floor(this.getUnitSizeWithDirection(opponent).height / 2);
                                const distance = this.getDistance(centerX, centerY, opponentCenterX, opponentCenterY);
                                
                                if (distance > 3) {
                                    this.addGameLog(`âš ï¸ åŸå¯¹æ‰‹è·ç¦»${distance}æ ¼ï¼Œå·²è¶…å‡º3æ ¼èŒƒå›´`);
                                    return false;
                                }
                                
                                // è®¾ç½®ä¸ºæŒç»­è¿‘æˆ˜
                                this.meleeType = 'sustained';
                                this.meleeAttacker = clickedUnit;
                                this.meleeTarget = opponent;
                                this.meleeSubPhase = 'select_attacker_support';
                                this.addGameLog(`âš”ï¸ æŒç»­è¿‘æˆ˜: ${clickedUnit.name} VS ${opponent.name}`);
                                this.addGameLog(`ğŸ’ª è¯·é€‰æ‹©æ”»å‡»æ–¹æ”¯æ´éƒ¨é˜Ÿï¼ˆ3æ ¼èŒƒå›´å†…ï¼Œå¯å¤šé€‰ï¼‰ï¼Œå®Œæˆåç‚¹å‡»"å®Œæˆæ”¯æ´é€‰æ‹©"æŒ‰é’®`);
                                this.renderBoard();
                                this.updateUI();
                                return true;
                            } else {
                                // å†²é”‹è¿‘æˆ˜ï¼šå•ä½æœªå¤„äºè¿‘æˆ˜çŠ¶æ€
                                console.log(`[è¿‘æˆ˜å¤„ç†] å†²é”‹è¿‘æˆ˜: ${clickedUnit.name}`);
                                
                                // æ£€æŸ¥3æ ¼å†…æ˜¯å¦æœ‰æ•Œæ–¹å•ä½
                                const nearbyEnemies = this.getUnitsInRange(clickedUnit, 3, false);
                                if (nearbyEnemies.length === 0) {
                                    this.addGameLog('âš ï¸ è¯¥å•ä½3æ ¼å†…æ²¡æœ‰æ•Œæ–¹å•ä½');
                                    return false;
                                }
                                
                                // è®¾ç½®ä¸ºå†²é”‹è¿‘æˆ˜
                                this.meleeType = 'charge';
                                this.meleeAttacker = clickedUnit;
                                this.meleeSubPhase = 'select_target';
                                this.addGameLog(`âš”ï¸ é€‰æ‹©å†²é”‹å•ä½: ${clickedUnit.name}ï¼Œè¯·é€‰æ‹©3æ ¼å†…çš„æ”»å‡»ç›®æ ‡`);
                                this.renderBoard();
                                this.updateUI();
                                return true;
                            }
                        }
                        break;
                    
                    case 'select_target':
                        // é€‰æ‹©ç›®æ ‡
                        if (clickedUnit && clickedUnit.faction !== this.currentPlayer) {
                            // æ£€æŸ¥ç›®æ ‡æ˜¯å¦åœ¨å†²é”‹å•ä½3æ ¼èŒƒå›´å†…
                            const centerX = this.meleeAttacker.x + Math.floor(this.getUnitSizeWithDirection(this.meleeAttacker).width / 2);
                            const centerY = this.meleeAttacker.y + Math.floor(this.getUnitSizeWithDirection(this.meleeAttacker).height / 2);
                            const targetCenterX = clickedUnit.x + Math.floor(this.getUnitSizeWithDirection(clickedUnit).width / 2);
                            const targetCenterY = clickedUnit.y + Math.floor(this.getUnitSizeWithDirection(clickedUnit).height / 2);
                            const distance = this.getDistance(centerX, centerY, targetCenterX, targetCenterY);
                            
                            if (distance > 3) {
                                this.addGameLog(`âš ï¸ ç›®æ ‡è·ç¦»${distance}æ ¼ï¼Œè¶…å‡º3æ ¼å†²é”‹èŒƒå›´`);
                                return false;
                            }
                            // å…è®¸æ”»å‡»æ­£åœ¨è¿‘æˆ˜ä¸­çš„æ•Œæ–¹å•ä½ï¼ˆç§»é™¤combatStatusæ£€æŸ¥ï¼‰
                            
                            this.meleeTarget = clickedUnit;
                            
                            // åˆ‡æ¢åˆ°é˜²å¾¡æ–¹ï¼Œè®©å…¶é€‰æ‹©æ˜¯å¦æ’¤é€€
                            this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome';
                            this.meleeSubPhase = 'defender_choose_retreat';
                            this.addGameLog(`ğŸ¯ é€‰æ‹©ç›®æ ‡: ${clickedUnit.name} (è·ç¦»${distance}æ ¼)`);
                            this.addGameLog(`ğŸ›¡ï¸ é˜²å¾¡æ–¹ ${clickedUnit.name}ï¼Œè¯·é€‰æ‹©ï¼šæ’¤é€€æˆ–åšå®ˆæˆ˜æ–—`);
                            this.renderBoard();
                            this.updateUI();
                            return true;
                        } else if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            // é‡æ–°é€‰æ‹©å†²é”‹å•ä½
                            this.meleeSubPhase = 'select_attacker';
                            return this.handleMeleePhaseClick(clickedUnit);
                        }
                        break;
                    
                    case 'select_attacker_support':
                        // é€‰æ‹©æ”»å‡»æ–¹æ”¯æ´éƒ¨é˜Ÿ
                        console.log(`[æ”¯æ´é€‰æ‹©] ç‚¹å‡»å•ä½: ${clickedUnit?.name}, é˜µè¥: ${clickedUnit?.faction}, å½“å‰ç©å®¶: ${this.currentPlayer}`);
                        
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            const availableSupports = this.getAvailableSupportUnits(this.meleeAttacker);
                            console.log(`[æ”¯æ´é€‰æ‹©] å¯ç”¨æ”¯æ´å•ä½æ•°: ${availableSupports.length}, å•ä½ID: [${availableSupports.map(u => u.id).join(', ')}]`);
                            console.log(`[æ”¯æ´é€‰æ‹©] ç‚¹å‡»çš„å•ä½ID: ${clickedUnit.id}`);
                            
                            if (availableSupports.find(u => u.id === clickedUnit.id)) {
                                // åˆ‡æ¢æ”¯æ´çŠ¶æ€
                                const index = this.attackerSupports.findIndex(u => u.id === clickedUnit.id);
                                if (index >= 0) {
                                    this.attackerSupports.splice(index, 1);
                                    this.addGameLog(`â– å–æ¶ˆæ”¯æ´: ${clickedUnit.name}`);
                                } else {
                                    this.attackerSupports.push(clickedUnit);
                                    this.addGameLog(`â• æ·»åŠ æ”¯æ´: ${clickedUnit.name}`);
                                }
                                this.renderBoard();
                                this.updateUI();
                                return true;
                            } else {
                                this.addGameLog(`âš ï¸ ${clickedUnit.name}ä¸èƒ½ä½œä¸ºæ”¯æ´å•ä½ï¼ˆ3æ ¼å¤–ã€å·²è¿‘æˆ˜æˆ–å·²æ”¯æ´ï¼‰`);
                                console.log(`[æ”¯æ´é€‰æ‹©] å•ä½${clickedUnit.name}ä¸åœ¨å¯ç”¨æ”¯æ´åˆ—è¡¨ä¸­`);
                            }
                        } else if (clickedUnit) {
                            this.addGameLog(`âš ï¸ åªèƒ½é€‰æ‹©å·±æ–¹å•ä½ä½œä¸ºæ”¯æ´`);
                        }
                        return false;
                    
                    case 'select_defender_support':
                        // é€‰æ‹©é˜²å®ˆæ–¹æ”¯æ´éƒ¨é˜Ÿ
                        console.log(`[é˜²å®ˆæ–¹æ”¯æ´] ç‚¹å‡»å•ä½: ${clickedUnit?.name}, é˜µè¥: ${clickedUnit?.faction}, å½“å‰ç©å®¶: ${this.currentPlayer}`);
                        
                        if (clickedUnit && clickedUnit.faction === this.currentPlayer) {
                            const availableSupports = this.getAvailableSupportUnits(this.meleeTarget);
                            console.log(`[é˜²å®ˆæ–¹æ”¯æ´] å¯ç”¨æ”¯æ´å•ä½æ•°: ${availableSupports.length}, å•ä½ID: [${availableSupports.map(u => u.id).join(', ')}]`);
                            console.log(`[é˜²å®ˆæ–¹æ”¯æ´] ç‚¹å‡»çš„å•ä½ID: ${clickedUnit.id}, ç›®æ ‡é˜µè¥: ${this.meleeTarget.faction}`);
                            
                            if (availableSupports.find(u => u.id === clickedUnit.id)) {
                                // åˆ‡æ¢æ”¯æ´çŠ¶æ€
                                const index = this.defenderSupports.findIndex(u => u.id === clickedUnit.id);
                                if (index >= 0) {
                                    this.defenderSupports.splice(index, 1);
                                    this.addGameLog(`â– å–æ¶ˆæ”¯æ´: ${clickedUnit.name}`);
                                } else {
                                    this.defenderSupports.push(clickedUnit);
                                    this.addGameLog(`â• æ·»åŠ æ”¯æ´: ${clickedUnit.name}`);
                                }
                                this.renderBoard();
                                this.updateUI();
                                return true;
                            } else {
                                this.addGameLog(`âš ï¸ ${clickedUnit.name}ä¸èƒ½ä½œä¸ºæ”¯æ´å•ä½ï¼ˆ3æ ¼å¤–ã€å·²è¿‘æˆ˜æˆ–å·²æ”¯æ´ï¼‰`);
                                console.log(`[é˜²å®ˆæ–¹æ”¯æ´] å•ä½${clickedUnit.name}ä¸åœ¨å¯ç”¨æ”¯æ´åˆ—è¡¨ä¸­`);
                            }
                        } else if (clickedUnit) {
                            this.addGameLog(`âš ï¸ åªèƒ½é€‰æ‹©é˜²å®ˆæ–¹å•ä½ä½œä¸ºæ”¯æ´`);
                        }
                        return false;
                }
                return false;
            }

            // è¿‘æˆ˜æ”»å‡»é€»è¾‘ï¼ˆæ–°çš„å†²é”‹æˆ˜æ–—ç³»ç»Ÿï¼‰
            executeMeleeAttack(attacker, defender) {
                // ä½¿ç”¨æ–°çš„å†²é”‹æˆ˜æ–—ç³»ç»Ÿ
                return this.executeChargeAttack();
            }
            
            // æ‰§è¡Œå†²é”‹æˆ˜æ–—
            executeChargeAttack() {
                if (!this.meleeAttacker || !this.meleeTarget) {
                    console.error('å†²é”‹å•ä½æˆ–ç›®æ ‡æœªè®¾ç½®');
                    return false;
                }

                const attacker = this.meleeAttacker;
                const defender = this.meleeTarget;
                
                // ç«‹å³éšè—æ‰§è¡Œå†²é”‹æŒ‰é’®ï¼ˆé€šè¿‡æ”¹å˜å­é˜¶æ®µï¼‰
                this.meleeSubPhase = 'executing'; // è®¾ç½®ä¸ºæ‰§è¡Œä¸­çŠ¶æ€
                document.getElementById('execute-charge-btn').style.display = 'none';
                
                // æ ¹æ®è¿‘æˆ˜ç±»å‹æ˜¾ç¤ºä¸åŒçš„æ—¥å¿—
                const meleeTypeName = this.meleeType === 'sustained' ? 'æŒç»­è¿‘æˆ˜' : 'å†²é”‹æˆ˜æ–—';
                this.addGameLog(`âš”ï¸ å¼€å§‹${meleeTypeName}: ${attacker.name} VS ${defender.name}`);
                
                // 1. è®¡ç®—æ”»å‡»æ–¹æ”¯æ´æˆ˜åŠ›
                let attackerSupportPower = 0;
                this.attackerSupports.forEach(support => {
                    attackerSupportPower += support.supportMelee;
                    support.combatStatus = 'supporting';
                    support.supportingUnit = attacker.id; // è®°å½•æ­£åœ¨æ”¯æ´å“ªä¸ªå•ä½
                    this.addGameLog(`ğŸ’ª ${support.name} æä¾›æ”¯æ´: +${support.supportMelee}`);
                });
                
                // 2. è®¡ç®—é˜²å®ˆæ–¹æ”¯æ´æˆ˜åŠ›
                let defenderSupportPower = 0;
                this.defenderSupports.forEach(support => {
                    defenderSupportPower += support.supportMelee;
                    support.combatStatus = 'supporting';
                    support.supportingUnit = defender.id; // è®°å½•æ­£åœ¨æ”¯æ´å“ªä¸ªå•ä½
                    this.addGameLog(`ğŸ›¡ï¸ ${support.name} æä¾›æ”¯æ´: +${support.supportMelee}`);
                });
                
                // æ›´æ–°æ‰€æœ‰æ”¯æ´å•ä½çš„æ˜¾ç¤º
                [...this.attackerSupports, ...this.defenderSupports].forEach(support => {
                    this.updateUnitDisplay(support);
                });
                
                // 3. è®¡ç®—æ”»å‡»æ–¹æˆ˜æ–—éª°å­æ•°
                // æ ¹æ®è¿‘æˆ˜ç±»å‹ä½¿ç”¨ä¸åŒçš„æˆ˜æ–—åŠ›å€¼
                const attackerMeleeValue = this.meleeType === 'sustained' ? attacker.sustainedMelee : attacker.chargeAttack;
                let attackerDice = attackerMeleeValue + attackerSupportPower;
                console.log(`[æˆ˜æ–—éª°å­] æ”»å‡»æ–¹åŸºç¡€: ${attackerMeleeValue} (${this.meleeType === 'sustained' ? 'æŒç»­' : 'å†²é”‹'}), æ”¯æ´: ${attackerSupportPower}`);
                
                // å£«æ°”å’Œç§©åºä¿®æ­£
                if (attacker.morale === 'shaken') {
                    attackerDice -= 1;
                    this.addGameLog(`ğŸ˜° æ”»å‡»æ–¹åŠ¨æ‘‡ï¼Œéª°å­æ•°-1`);
                }
                if (attacker.order === 'chaotic') {
                    attackerDice -= 1;
                    this.addGameLog(`ğŸ“‹ æ”»å‡»æ–¹æ··ä¹±ï¼Œéª°å­æ•°-1`);
                }
                
                // æ–¹å‘ä¿®æ­£
                const relativeDirection = this.getRelativeAttackDirection(attacker, defender);
                if (relativeDirection === 'side') {
                    const bonus = Math.floor(attackerMeleeValue * 0.5);
                    attackerDice += bonus;
                    this.addGameLog(`ğŸ“ æ”»å‡»ä¾§é¢ï¼Œéª°å­æ•°+${bonus}`);
                } else if (relativeDirection === 'back') {
                    attackerDice += attackerMeleeValue;
                    this.addGameLog(`ğŸ“ æ”»å‡»èƒŒé¢ï¼Œéª°å­æ•°+${attackerMeleeValue}`);
                }
                
                // ä¸Šä¸€è½®è¿‘æˆ˜èƒœåˆ©åŠ æˆï¼ˆåªæœ‰æŒç»­è¿‘æˆ˜æ‰æœ‰ï¼‰
                if (this.meleeType === 'sustained' && attacker.lastMeleeResult === 'won') {
                    attackerDice += 1;
                    this.addGameLog(`ğŸ† æ”»å‡»æ–¹ä¸Šè½®èƒœåˆ©ï¼Œéª°å­æ•°+1`);
                }
                
                attackerDice = Math.max(0, attackerDice);
                
                // 4. è®¡ç®—é˜²å®ˆæ–¹æˆ˜æ–—éª°å­æ•°
                // é˜²å®ˆæ–¹åœ¨æŒç»­è¿‘æˆ˜ä¸­ä¹Ÿä½¿ç”¨æŒç»­è¿‘æˆ˜å€¼
                const defenderMeleeValue = this.meleeType === 'sustained' ? defender.sustainedMelee : defender.chargeAttack;
                let defenderDice = defenderMeleeValue + defenderSupportPower;
                console.log(`[æˆ˜æ–—éª°å­] é˜²å®ˆæ–¹åŸºç¡€: ${defenderMeleeValue} (${this.meleeType === 'sustained' ? 'æŒç»­' : 'å†²é”‹'}), æ”¯æ´: ${defenderSupportPower}`);
                
                if (defender.morale === 'shaken') {
                    defenderDice -= 1;
                    this.addGameLog(`ğŸ˜° é˜²å®ˆæ–¹åŠ¨æ‘‡ï¼Œéª°å­æ•°-1`);
                }
                if (defender.order === 'chaotic') {
                    defenderDice -= 1;
                    this.addGameLog(`ğŸ“‹ é˜²å®ˆæ–¹æ··ä¹±ï¼Œéª°å­æ•°-1`);
                }
                
                defenderDice = Math.max(0, defenderDice);
                
                this.addGameLog(`ğŸ² æ”»å‡»æ–¹éª°å­æ•°: ${attackerDice}, é˜²å®ˆæ–¹éª°å­æ•°: ${defenderDice}`);
                
                // 5. æŠ•æ·å‘½ä¸­åˆ¤å®š
                let attackerHits = 0;
                const attackerRolls = [];
                for (let i = 0; i < attackerDice; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    attackerRolls.push(roll);
                    if (roll >= 4) attackerHits++;
                }
                
                let defenderHits = 0;
                const defenderRolls = [];
                for (let i = 0; i < defenderDice; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    defenderRolls.push(roll);
                    if (roll >= 4) defenderHits++;
                }
                
                this.addGameLog(`ğŸ² æ”»å‡»æ–¹æŠ•æ·: [${attackerRolls.join(', ')}] - ${attackerHits}æ¬¡å‘½ä¸­`);
                this.addGameLog(`ğŸ² é˜²å®ˆæ–¹æŠ•æ·: [${defenderRolls.join(', ')}] - ${defenderHits}æ¬¡å‘½ä¸­`);
                
                // 6. é˜²å¾¡åˆ¤å®šè®¡ç®—ä¼¤å®³
                let attackerDamageCount = 0;
                const attackerDefenseRolls = [];
                for (let i = 0; i < attackerHits; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    attackerDefenseRolls.push(roll);
                    if (roll < defender.defense) attackerDamageCount++;
                }
                
                let defenderDamageCount = 0;
                const defenderDefenseRolls = [];
                for (let i = 0; i < defenderHits; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    defenderDefenseRolls.push(roll);
                    if (roll < attacker.defense) defenderDamageCount++;
                }
                
                this.addGameLog(`ğŸ›¡ï¸ é˜²å®ˆæ–¹é˜²å¾¡åˆ¤å®š: [${attackerDefenseRolls.join(', ')}] - ${attackerDamageCount}æ¬¡é˜²å¾¡å¤±è´¥`);
                this.addGameLog(`ğŸ›¡ï¸ æ”»å‡»æ–¹é˜²å¾¡åˆ¤å®š: [${defenderDefenseRolls.join(', ')}] - ${defenderDamageCount}æ¬¡é˜²å¾¡å¤±è´¥`);
                
                // 7. é€ æˆä¼¤å®³
                const attackerTotalDamage = attackerDamageCount * 10;
                const defenderTotalDamage = defenderDamageCount * 10;
                
                defender.hp = Math.max(0, defender.hp - attackerTotalDamage);
                attacker.hp = Math.max(0, attacker.hp - defenderTotalDamage);
                
                this.addGameLog(`ğŸ’¥ ${defender.name}å—åˆ°${attackerTotalDamage}ç‚¹ä¼¤å®³ (${attackerDamageCount}æ¬¡Ã—10)`);
                this.addGameLog(`ğŸ’¥ ${attacker.name}å—åˆ°${defenderTotalDamage}ç‚¹ä¼¤å®³ (${defenderDamageCount}æ¬¡Ã—10)`);
                
                // æ’­æ”¾å†²é”‹åŠ¨ç”»å’Œæ”»å‡»æ•ˆæœ
                this.showMeleeChargeAnimation(attacker, defender, () => {
                    // å†²é”‹åŠ¨ç”»å®Œæˆåæ˜¾ç¤ºä¼¤å®³æ•ˆæœ
                    if (attackerTotalDamage > 0) {
                        const isCritical = attackerDamageCount >= 4; // 4æ¬¡ä»¥ä¸Šä¼¤å®³ç®—æš´å‡»
                        this.showEnhancedDamageEffect(defender.x, defender.y, attackerTotalDamage, {
                            isCritical: isCritical,
                            comboCount: attackerDamageCount,
                            attackType: 'melee'
                        });
                this.updateUnitDisplay(defender);
                    }
                    if (defenderTotalDamage > 0) {
                        const isCritical = defenderDamageCount >= 4;
                    setTimeout(() => {
                            this.showEnhancedDamageEffect(attacker.x, attacker.y, defenderTotalDamage, {
                                isCritical: isCritical,
                                comboCount: defenderDamageCount,
                                attackType: 'melee'
                            });
                            this.updateUnitDisplay(attacker);
                        }, 200); // ç¨å¾®å»¶è¿Ÿï¼Œè®©ä¸¤ä¸ªä¼¤å®³æ•°å­—ä¸é‡å 
                    }
                });
                
                // 8. åˆ¤å®šèƒœè´Ÿ
                if (attackerDamageCount > defenderDamageCount) {
                    this.addGameLog(`ğŸ† æ”»å‡»æ–¹è·èƒœï¼`);
                    attacker.lastMeleeResult = 'won';
                    defender.lastMeleeResult = 'lost';
                } else if (attackerDamageCount < defenderDamageCount) {
                    this.addGameLog(`ğŸ›¡ï¸ é˜²å®ˆæ–¹è·èƒœï¼`);
                    attacker.lastMeleeResult = 'lost';
                    defender.lastMeleeResult = 'won';
                } else {
                    this.addGameLog(`âš–ï¸ åŠ¿å‡åŠ›æ•Œï¼`);
                    attacker.lastMeleeResult = 'draw';
                    defender.lastMeleeResult = 'draw';
                }
                
                // 9. æ›´æ–°å•ä½çŠ¶æ€
                attacker.hasMeleeAttacked = true;
                attacker.combatStatus = 'engaged';
                defender.combatStatus = 'engaged';
                
                // è®¾ç½®è¿‘æˆ˜å…³ç³»
                attacker.engagedWith = defender.id;
                defender.engagedWith = attacker.id;
                
                // 10. è®°å½•æœ¬è½®ä¼¤å®³ï¼ˆç”¨äºå´©æºƒæµ‹è¯•ï¼‰
                attacker.lastBattleDamage = defenderDamageCount; // è‡ªå·±å—åˆ°çš„ä¼¤å®³
                defender.lastBattleDamage = attackerDamageCount; // è‡ªå·±å—åˆ°çš„ä¼¤å®³
                const damageDiff = attackerDamageCount - defenderDamageCount; // æ•Œæ–¹-å·±æ–¹

                // 11. æ£€æŸ¥HPå½’é›¶ - å˜ä¸ºåŠ¨æ‘‡
                if (defender.hp <= 0 && defender.morale !== 'shaken') {
                    defender.morale = 'shaken';
                    this.addGameLog(`ğŸ˜° ${defender.name}å£«æ°”åŠ¨æ‘‡ï¼`);
                    this.updateUnitDisplay(defender);
                }
                if (attacker.hp <= 0 && attacker.morale !== 'shaken') {
                    attacker.morale = 'shaken';
                    this.addGameLog(`ğŸ˜° ${attacker.name}å£«æ°”åŠ¨æ‘‡ï¼`);
                    this.updateUnitDisplay(attacker);
                }
                
                // ä¿å­˜æ”¯æ´å•ä½åˆ—è¡¨çš„å‰¯æœ¬ï¼ˆå› ä¸ºåç»­ä¼šè¢«é‡ç½®ï¼‰
                const savedAttackerSupports = [...this.attackerSupports];
                const savedDefenderSupports = [...this.defenderSupports];
                
                // 12-14. æ‰§è¡Œå´©æºƒæµ‹è¯•
                setTimeout(() => {
                    // è®°å½•éœ€è¦æµ‹è¯•çš„å•ä½ï¼Œå¹¶è®°å½•æ¯ä¸ªå•ä½ç›¸å…³çš„æ”¯æ´å•ä½åˆ—è¡¨
                    const unitsToTest = [];
                    
                    console.log(`\n[å´©æºƒæµ‹è¯•] æ£€æŸ¥æ¡ä»¶:`);
                    console.log(`æ”»å‡»è€…: ${attacker.name}, morale=${attacker.morale}, hp=${attacker.hp}, result=${attacker.lastMeleeResult}`);
                    console.log(`é˜²å®ˆè€…: ${defender.name}, morale=${defender.morale}, hp=${defender.hp}, result=${defender.lastMeleeResult}`);
                    console.log(`ä¼¤å®³æ•°: æ”»å‡»è€…å—=${defenderDamageCount}, é˜²å®ˆè€…å—=${attackerDamageCount}`);
                    console.log(`ä¼¤å®³å·®: damageDiff=${damageDiff}`);
                    
                    // 12. åŠ¨æ‘‡éƒ¨é˜Ÿå—ä¼¤æµ‹è¯•
                    if (attacker.morale === 'shaken' && defenderDamageCount > 0) {
                        console.log(`[å´©æºƒæµ‹è¯•] æ”»å‡»è€…${attacker.name}è§¦å‘åŠ¨æ‘‡éƒ¨é˜Ÿå—ä¼¤æµ‹è¯•`);
                        unitsToTest.push({ 
                            unit: attacker, 
                            reason: 'shaken_damaged', 
                            damageDiff: -damageDiff,
                            relatedSupports: savedAttackerSupports // ä¸»æˆ˜å•ä½çš„æ”¯æ´å•ä½åˆ—è¡¨
                        });
                    }
                    if (defender.morale === 'shaken' && attackerDamageCount > 0) {
                        console.log(`[å´©æºƒæµ‹è¯•] é˜²å®ˆè€…${defender.name}è§¦å‘åŠ¨æ‘‡éƒ¨é˜Ÿå—ä¼¤æµ‹è¯•`);
                        unitsToTest.push({ 
                            unit: defender, 
                            reason: 'shaken_damaged', 
                            damageDiff: damageDiff,
                            relatedSupports: savedDefenderSupports // ä¸»æˆ˜å•ä½çš„æ”¯æ´å•ä½åˆ—è¡¨
                        });
                    }
                    
                    // 13. æˆ˜è´¥æµ‹è¯•
                    if (attacker.lastMeleeResult === 'lost') {
                        if (!unitsToTest.find(t => t.unit.id === attacker.id)) {
                            console.log(`[å´©æºƒæµ‹è¯•] æ”»å‡»è€…${attacker.name}è§¦å‘æˆ˜è´¥æµ‹è¯•`);
                            unitsToTest.push({ 
                                unit: attacker, 
                                reason: 'defeated', 
                                damageDiff: -damageDiff,
                                relatedSupports: savedAttackerSupports // ä¸»æˆ˜å•ä½çš„æ”¯æ´å•ä½åˆ—è¡¨
                            });
                        }
                    }
                    if (defender.lastMeleeResult === 'lost') {
                        if (!unitsToTest.find(t => t.unit.id === defender.id)) {
                            console.log(`[å´©æºƒæµ‹è¯•] é˜²å®ˆè€…${defender.name}è§¦å‘æˆ˜è´¥æµ‹è¯•`);
                            unitsToTest.push({ 
                                unit: defender, 
                                reason: 'defeated', 
                                damageDiff: damageDiff,
                                relatedSupports: savedDefenderSupports // ä¸»æˆ˜å•ä½çš„æ”¯æ´å•ä½åˆ—è¡¨
                            });
                        }
                    }
                    
                    console.log(`[å´©æºƒæµ‹è¯•] ç¬¬ä¸€è½®ï¼šä¸»æˆ˜å•ä½æµ‹è¯•ï¼Œå…± ${unitsToTest.length} ä¸ªå•ä½`);
                    
                    // ç¬¬ä¸€è½®ï¼šæ‰§è¡Œä¸»æˆ˜å•ä½çš„å´©æºƒæµ‹è¯•
                    if (unitsToTest.length > 0) {
                        this.performRouteTests(unitsToTest);
                    }
                    
                    // ç¬¬äºŒè½®ï¼šæ£€æŸ¥æ”¯æ´å•ä½æ˜¯å¦éœ€è¦æµ‹è¯•ï¼ˆåŸºäºä¸»æˆ˜å•ä½æµ‹è¯•åçš„å®é™…çŠ¶æ€ï¼‰
                    const checkSupportedUnitStatusAfterTest = (supportList, supportedUnit, oppositeDamageDiff) => {
                        // è§¦å‘æ¡ä»¶ï¼šä¸»æˆ˜å•ä½åœ¨æµ‹è¯•ååŠ¨æ‘‡æˆ–è¢«æ¶ˆç­ï¼ˆHP<=0ï¼‰
                        // æ³¨æ„ï¼šä¸åŒ…æ‹¬å•çº¯çš„"æˆ˜è´¥"ï¼Œå› ä¸ºæˆ˜è´¥ä½†åšå®ˆçš„å•ä½ä¸ä¼šå½±å“æ”¯æ´å•ä½
                        const shouldTrigger = supportedUnit.morale === 'shaken' || supportedUnit.hp <= 0;
                        
                        if (shouldTrigger) {
                            const reason = supportedUnit.morale === 'shaken' ? 'è¢«æ”¯æ´å•ä½åŠ¨æ‘‡' :
                                         supportedUnit.hp <= 0 ? 'è¢«æ”¯æ´å•ä½è¢«æ¶ˆç­' : 'æœªçŸ¥';
                            console.log(`[å´©æºƒæµ‹è¯•] ${supportedUnit.name}çš„æ”¯æ´å•ä½éœ€è¦è¿›è¡Œæµ‹è¯• (åŸå› : ${reason})`);
                            
                            const supportUnitsToTest = [];
                            supportList.forEach(support => {
                                console.log(`[å´©æºƒæµ‹è¯•] æ”¯æ´å•ä½${support.name}è§¦å‘æµ‹è¯•`);
                                supportUnitsToTest.push({ 
                                    unit: support, 
                                    reason: 'supported_unit_failed', 
                                    damageDiff: oppositeDamageDiff,
                                    relatedSupports: []
                                });
                            });
                            
                            if (supportUnitsToTest.length > 0) {
                                console.log(`[å´©æºƒæµ‹è¯•] ç¬¬äºŒè½®ï¼šæ”¯æ´å•ä½æµ‹è¯•ï¼Œå…± ${supportUnitsToTest.length} ä¸ªå•ä½`);
                                this.performRouteTests(supportUnitsToTest);
                            }
                        }
                    };
                    
                    // å»¶è¿Ÿæ‰§è¡Œç¬¬äºŒè½®æµ‹è¯•ï¼Œç¡®ä¿ç¬¬ä¸€è½®æµ‹è¯•å®Œæˆ
                    const firstRoundDelay = unitsToTest.length > 0 ? (unitsToTest.length * 1500 + 500) : 500;
                    setTimeout(() => {
                        checkSupportedUnitStatusAfterTest(savedAttackerSupports, attacker, -damageDiff);
                        checkSupportedUnitStatusAfterTest(savedDefenderSupports, defender, damageDiff);
                    }, firstRoundDelay)
                    
                    // è®¡ç®—å´©æºƒæµ‹è¯•æ€»æ—¶é•¿ï¼ˆåŒ…æ‹¬ä¸¤è½®ï¼‰ï¼Œç„¶åé‡ç½®çŠ¶æ€å¹¶æ£€æŸ¥æŒç»­è¿‘æˆ˜
                    // ç¬¬ä¸€è½® + å¯èƒ½çš„ç¬¬äºŒè½®ï¼ˆå‡è®¾æœ€å¤š4ä¸ªæ”¯æ´å•ä½ï¼‰
                    const maxSupportTests = Math.min(savedAttackerSupports.length + savedDefenderSupports.length, 4);
                    const totalTestDelay = firstRoundDelay + (maxSupportTests > 0 ? maxSupportTests * 1500 + 500 : 0);
                    setTimeout(() => {
                        const wasChargeType = this.meleeType === 'charge';
                        this.resetChargeState();
                        
                        // å¦‚æœæ˜¯å†²é”‹è¿‘æˆ˜ï¼Œå†²é”‹å®Œæˆåè‡ªåŠ¨æ£€æŸ¥æŒç»­è¿‘æˆ˜
                        if (wasChargeType) {
                            console.log('[è¿‘æˆ˜ç³»ç»Ÿ] å†²é”‹è¿‘æˆ˜å®Œæˆï¼Œæ£€æŸ¥æŒç»­è¿‘æˆ˜...');
                            setTimeout(() => {
                                this.autoStartNextSustainedMelee();
                            }, 500);
                        } else {
                            // å¦‚æœæ˜¯æŒç»­è¿‘æˆ˜ï¼ŒæŒç»­è¿‘æˆ˜å®Œæˆåæ£€æŸ¥ä¸‹ä¸€ä¸ªæŒç»­è¿‘æˆ˜
                            console.log('[è¿‘æˆ˜ç³»ç»Ÿ] æŒç»­è¿‘æˆ˜å®Œæˆï¼Œæ£€æŸ¥ä¸‹ä¸€ä¸ªæŒç»­è¿‘æˆ˜...');
                            setTimeout(() => {
                                this.autoStartNextSustainedMelee();
                            }, 500);
                        }
                    }, totalTestDelay);
                    
                }, 2000); // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†è¿›è¡Œæµ‹è¯•
                
                this.checkGameEnd();
                return true;
            }
            
            // è·å–ç›¸å¯¹æ”»å‡»æ–¹å‘ï¼ˆç”¨äºè®¡ç®—æ–¹å‘åŠ æˆï¼‰
            getRelativeAttackDirection(attacker, defender) {
                // è®¡ç®—æ”»å‡»è€…ç›¸å¯¹äºé˜²å®ˆè€…çš„æ–¹å‘ï¼ˆæ”»å‡»æ¥è‡ªå“ªä¸ªæ–¹å‘ï¼‰
                const dx = attacker.x - defender.x;
                const dy = attacker.y - defender.y;
                
                let attackDirection = '';
                if (Math.abs(dx) > Math.abs(dy)) {
                    attackDirection = dx > 0 ? 'east' : 'west';
                } else {
                    attackDirection = dy > 0 ? 'south' : 'north';
                }
                
                console.log(`[æ”»å‡»æ–¹å‘] æ”»å‡»è€…(${attacker.x}, ${attacker.y}) -> é˜²å®ˆè€…(${defender.x}, ${defender.y}), dx=${dx}, dy=${dy}, æ”»å‡»æ¥è‡ª: ${attackDirection}, é˜²å®ˆè€…æœå‘: ${defender.direction}`);
                
                // è®¡ç®—ç›¸å¯¹æ–¹å‘
                const directionMap = {
                    'north': { front: 'north', back: 'south', side: ['east', 'west'] },
                    'south': { front: 'south', back: 'north', side: ['east', 'west'] },
                    'east': { front: 'east', back: 'west', side: ['north', 'south'] },
                    'west': { front: 'west', back: 'east', side: ['north', 'south'] }
                };
                
                const defenderDir = directionMap[defender.direction];
                let result = 'front';
                if (attackDirection === defenderDir.back) result = 'back';
                else if (defenderDir.side.includes(attackDirection)) result = 'side';
                
                console.log(`[æ”»å‡»æ–¹å‘] åˆ¤å®šç»“æœ: ${result} (æ­£é¢=${defenderDir.front}, èƒŒé¢=${defenderDir.back}, ä¾§é¢=[${defenderDir.side.join(', ')}])`);
                return result;
            }
            
            // æ‰§è¡Œå´©æºƒæµ‹è¯•
            performRouteTests(unitsToTest) {
                if (unitsToTest.length === 0) {
                    return;
                }
                
                this.addGameLog(`\nğŸ² å¼€å§‹å´©æºƒæµ‹è¯•...`);
                
                unitsToTest.forEach((testData, index) => {
                    setTimeout(() => {
                        this.performSingleRouteTest(testData.unit, testData.reason, testData.damageDiff, testData.relatedSupports);
                    }, index * 1500); // æ¯ä¸ªæµ‹è¯•é—´éš”1.5ç§’
                });
            }
            
            // å•ä¸ªå•ä½çš„å´©æºƒæµ‹è¯•
            performSingleRouteTest(unit, reason, damageDiff, relatedSupports = []) {
                // æ£€æŸ¥å•ä½æ˜¯å¦è¿˜å­˜åœ¨
                if (!this.units.find(u => u.id === unit.id)) {
                    console.log(`[performSingleRouteTest] å•ä½${unit.name}å·²ä¸å­˜åœ¨ï¼Œè·³è¿‡æµ‹è¯•`);
                    return;
                }
                
                const reasonText = {
                    'shaken_damaged': 'åŠ¨æ‘‡éƒ¨é˜Ÿå—ä¼¤',
                    'defeated': 'è¿‘æˆ˜è¢«å‡»è´¥',
                    'supported_unit_failed': 'è¢«æ”¯æ´å•ä½åŠ¨æ‘‡/æ¶ˆç­'
                }[reason] || reason;
                
                this.addGameLog(`\nğŸ¯ ${unit.name} è¿›è¡Œå´©æºƒæµ‹è¯• (åŸå› : ${reasonText})`);
                console.log(`[performSingleRouteTest] å¼€å§‹æµ‹è¯•: ${unit.name}, reason=${reason}, damageDiff=${damageDiff}`);
                
                // æŠ•æ·2D6
                const dice1 = Math.floor(Math.random() * 6) + 1;
                const dice2 = Math.floor(Math.random() * 6) + 1;
                const baseRoll = dice1 + dice2;
                
                this.addGameLog(`ğŸ² æŠ•æ·2D6: ${dice1} + ${dice2} = ${baseRoll}`);
                this.addGameLog(`ğŸ“Š ä¼¤å®³å·®å€¼ä¿®æ­£: ${damageDiff > 0 ? '+' : ''}${damageDiff}`);
                
                const finalRoll = baseRoll - damageDiff;
                this.addGameLog(`ğŸ“Š æœ€ç»ˆç»“æœ: ${baseRoll} - ${damageDiff} = ${finalRoll}`);
                
                // æŸ¥è¡¨åˆ¤å®šç»“æœ
                console.log(`[performSingleRouteTest] è°ƒç”¨ getRouteTestResult`);
                const result = this.getRouteTestResult(unit, finalRoll);
                console.log(`[performSingleRouteTest] è°ƒç”¨ applyRouteResult, result=`, result);
                this.applyRouteResult(unit, result, relatedSupports);
                console.log(`[performSingleRouteTest] applyRouteResult å®Œæˆ`);
            }
            
            // è·å–å•ä½ç±»åˆ«ï¼ˆç”¨äºå´©æºƒæµ‹è¯•ï¼‰
            getUnitCategory(unit) {
                // éª‘å…µï¼šè¿¦å¤ªåŸºéª‘å…µã€ç½—é©¬è´µæ—éª‘å…µã€ç½—é©¬å°†å†›ã€è¿¦å¤ªåŸºå°†å†›
                if (unit.type === 'cavalry' || unit.type === 'general') {
                    return 'cavalry';
                }
                // æ­¥å…µï¼šè¿¦å¤ªåŸºæ­¥å…µã€ç½—é©¬å†›å›¢å…µã€ç½—é©¬åå¤‡å…µ
                if (unit.type === 'infantry') {
                    return 'infantry';
                }
                // å¼“ç®­å…µ
                if (unit.type === 'archer') {
                    return 'archer';
                }
                // æˆ˜è±¡æŒ‰éª‘å…µå¤„ç†
                if (unit.type === 'elephant') {
                    return 'cavalry';
                }
                // é»˜è®¤æŒ‰æ­¥å…µå¤„ç†
                return 'infantry';
            }
            
            // æ ¹æ®éª°å­ç»“æœæŸ¥è¡¨
            getRouteTestResult(unit, roll) {
                const category = this.getUnitCategory(unit);
                const isShaken = unit.morale === 'shaken';
                console.log(`[getRouteTestResult] å•ä½=${unit.name}, ç±»åˆ«=${category}, åŠ¨æ‘‡=${isShaken}, éª°å€¼=${roll}`);
                
                let result;
                
                // å´©æºƒæµ‹è¯•ç»“æœè¡¨
                if (roll >= 10) {
                    result = { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                } else if (roll === 9) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_ordered', disorder: false, withSupports: true, text: 'éª‘å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æœ‰åºåé€€' };
                    } else if (category === 'archer') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'å¼“ç®­å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else { // infantry
                        result = { action: 'hold', disorder: false, text: 'æ­¥å…µåšå®ˆ' };
                    }
                } else if (roll === 8) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_ordered', disorder: false, withSupports: true, text: 'éª‘å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æœ‰åºåé€€' };
                    } else if (category === 'archer') {
                        if (isShaken) {
                            result = { action: 'destroyed', text: 'å¼“ç®­å…µåŠ¨æ‘‡è¢«æ¶ˆç­' };
                        } else {
                            result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'å¼“ç®­å…µæ··ä¹±åœ°åé€€' };
                        }
                    } else { // infantry
                        result = { action: 'hold', disorder: false, text: 'æ­¥å…µåšå®ˆ' };
                    }
                } else if (roll === 7 || roll === 6) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: true, text: 'éª‘å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æ··ä¹±åœ°åé€€' };
                    } else if (category === 'archer') {
                        result = { action: 'destroyed', text: 'å¼“ç®­å…µè¢«æ¶ˆç­' };
                    } else { // infantry
                        result = { action: 'retreat_ordered', disorder: false, withSupports: true, text: 'æ­¥å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æœ‰åºåé€€' };
                    }
                } else if (roll === 5) {
                    if (category === 'cavalry') {
                        if (isShaken) {
                            result = { action: 'destroyed', text: 'éª‘å…µåŠ¨æ‘‡è¢«æ¶ˆç­' };
                        } else {
                            result = { action: 'retreat_disordered', disorder: true, withSupports: true, text: 'éª‘å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æ··ä¹±åé€€' };
                        }
                    } else if (category === 'archer') {
                        result = { action: 'destroyed', text: 'å¼“ç®­å…µè¢«æ¶ˆç­' };
                    } else { // infantry
                        result = { action: 'retreat_disordered', disorder: true, withSupports: true, text: 'æ­¥å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æ··ä¹±åœ°åé€€' };
                    }
                } else if (roll === 4) {
                    if (category === 'archer') {
                        result = { action: 'destroyed', text: 'å¼“ç®­å…µè¢«æ¶ˆç­' };
                    } else { // infantry or cavalry
                        if (isShaken) {
                            result = { action: 'destroyed', text: 'åŠ¨æ‘‡è¢«æ¶ˆç­' };
                        } else {
                            result = { action: 'retreat_disordered', disorder: true, withSupports: true, text: 'å’Œæ”¯æ´å•ä½ä¸€èµ·æ··ä¹±åé€€' };
                        }
                    }
                } else if (roll === 3) {
                    if (category === 'cavalry' || category === 'archer') {
                        result = { action: 'destroyed', text: 'è¢«æ¶ˆç­' };
                    } else { // infantry
                        if (isShaken) {
                            result = { action: 'destroyed', text: 'æ­¥å…µåŠ¨æ‘‡è¢«æ¶ˆç­' };
                        } else {
                            result = { action: 'retreat_disordered', disorder: true, withSupports: true, text: 'æ­¥å…µå’Œæ”¯æ´å•ä½ä¸€èµ·æ··ä¹±åé€€' };
                        }
                    }
                } else { // roll <= 2
                    result = { action: 'destroyed', text: 'è¢«æ¶ˆç­' };
                }
                
                console.log(`[getRouteTestResult] ç»“æœ: action=${result.action}, text=${result.text}`);
                return result;
            }
            
            // åº”ç”¨å´©æºƒæµ‹è¯•ç»“æœ
            applyRouteResult(unit, result, relatedSupports = []) {
                this.addGameLog(`âœ… ç»“æœ: ${result.text}`);
                console.log(`[applyRouteResult] å•ä½=${unit.name}, action=${result.action}, disorder=${result.disorder}, withSupports=${result.withSupports}`);
                
                switch (result.action) {
                    case 'hold':
                        // åšå®ˆåŸåœ°
                        console.log(`[applyRouteResult] æ‰§è¡Œåšå®ˆåŸåœ°`);
                        if (result.disorder) {
                            unit.order = 'chaotic';
                            this.addGameLog(`ğŸ“‹ ${unit.name}è¿›å…¥æ··ä¹±çŠ¶æ€`);
                        }
                        // æ¸…é™¤æ”¯æ´çŠ¶æ€ï¼ˆé€šè¿‡äº†å´©æºƒæµ‹è¯•ï¼Œä¸å†æ”¯æ´ï¼‰
                        if (unit.combatStatus === 'supporting') {
                            console.log(`[applyRouteResult] æ¸…é™¤åšå®ˆå•ä½${unit.name}çš„æ”¯æ´çŠ¶æ€`);
                            unit.combatStatus = 'not_engaged';
                            unit.supportingUnit = null;
                            this.addGameLog(`ğŸƒ ${unit.name}è„±ç¦»æ”¯æ´çŠ¶æ€`);
                        }
                        this.updateUnitDisplay(unit);
                        break;
                        
                    case 'retreat_ordered':
                        // æœ‰åºåé€€
                        console.log(`[applyRouteResult] æ‰§è¡Œæœ‰åºåé€€`);
                        const orderedResult = this.retreatUnit(unit, false, result.withSupports, relatedSupports, true);
                        if (orderedResult.destroyed) {
                            // å•ä½å› æ— æ³•æ’¤é€€è¢«æ¶ˆç­ï¼Œæ‰§è¡Œæ¶ˆç­é€»è¾‘
                            const isGeneral = unit.type === 'general';
                            const generalFaction = unit.faction;
                            this.showDeathEffect(unit.x, unit.y);
                            if (isGeneral) {
                                setTimeout(async () => {
                                    await this.performGeneralDeathTest(generalFaction);
                                    this.checkGameEnd();
                                }, 800);
                            } else {
                                setTimeout(() => {
                                    this.checkGameEnd();
                                }, 800);
                            }
                        }
                        break;
                        
                    case 'retreat_disordered':
                        // æ··ä¹±åé€€
                        console.log(`[applyRouteResult] æ‰§è¡Œæ··ä¹±åé€€`);
                        const disorderedResult = this.retreatUnit(unit, true, result.withSupports, relatedSupports, true);
                        if (disorderedResult.destroyed) {
                            // å•ä½å› æ— æ³•æ’¤é€€è¢«æ¶ˆç­ï¼Œæ‰§è¡Œæ¶ˆç­é€»è¾‘
                            const isGeneral = unit.type === 'general';
                            const generalFaction = unit.faction;
                            this.showDeathEffect(unit.x, unit.y);
                            if (isGeneral) {
                                setTimeout(async () => {
                                    await this.performGeneralDeathTest(generalFaction);
                                    this.checkGameEnd();
                                }, 800);
                            } else {
                                setTimeout(() => {
                                    this.checkGameEnd();
                                }, 800);
                            }
                        }
                        break;
                        
                    case 'destroyed':
                        // è¢«æ¶ˆç­
                        console.log(`[applyRouteResult] å•ä½è¢«æ¶ˆç­`);
                        this.addGameLog(`ğŸ’€ ${unit.name}è¢«æ¶ˆç­ï¼`);
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯å°†é¢†
                        const isGeneral = unit.type === 'general';
                        const generalFaction = unit.faction;
                        
                        this.showDeathEffect(unit.x, unit.y);
                        setTimeout(async () => {
                            this.removeUnit(unit);
                            // æ£€æŸ¥å¹¶è§£é™¤å¯¹æ‰‹çš„è¿‘æˆ˜çŠ¶æ€
                            this.checkAndDisengageUnits();
                            
                            // å¦‚æœè¢«æ¶ˆç­çš„æ˜¯å°†é¢†ï¼Œè§¦å‘å°†é¢†é˜µäº¡æµ‹è¯•
                            if (isGeneral) {
                                await this.performGeneralDeathTest(generalFaction);
                            }
                            
                            this.checkGameEnd();
                        }, 800);
                        break;
                        
                    default:
                        console.error(`[applyRouteResult] æœªçŸ¥çš„action: ${result.action}`);
                        break;
                }
            }
            
            // å°†é¢†é˜µäº¡æµ‹è¯•ï¼šå½“æœ¬é˜µè¥å°†é¢†è¢«æ¶ˆç­æ—¶ï¼Œå¯¹æ‰€æœ‰å‰©ä½™éƒ¨é˜Ÿè¿›è¡Œå£«æ°”æµ‹è¯•
            async performGeneralDeathTest(faction) {
                // æ£€æŸ¥è¯¥é˜µè¥çš„å°†é¢†é˜µäº¡æµ‹è¯•æ˜¯å¦å·²ç»æ‰§è¡Œè¿‡
                if (this.generalDeathTestDone[faction]) {
                    console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${faction}é˜µè¥çš„å°†é¢†é˜µäº¡æµ‹è¯•å·²ç»æ‰§è¡Œè¿‡ï¼Œè·³è¿‡`);
                    return;
                }
                
                // æ ‡è®°è¯¥é˜µè¥çš„å°†é¢†é˜µäº¡æµ‹è¯•å·²æ‰§è¡Œ
                this.generalDeathTestDone[faction] = true;
                
                this.addGameLog(`\nâš ï¸ ${faction === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}å°†é¢†é˜µäº¡ï¼å¼€å§‹è¿›è¡Œéƒ¨é˜Ÿå£«æ°”æµ‹è¯•...`);
                console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${faction}å°†é¢†è¢«æ¶ˆç­ï¼Œå¼€å§‹æµ‹è¯•æ‰€æœ‰å‰©ä½™éƒ¨é˜Ÿ`);
                
                // è·å–è¯¥é˜µè¥æ‰€æœ‰å­˜æ´»çš„éå°†é¢†å•ä½
                const remainingUnits = this.units.filter(u => 
                    u.faction === faction && 
                    u.type !== 'general' && 
                    u.hp > 0
                );
                
                if (remainingUnits.length === 0) {
                    this.addGameLog(`âš ï¸ è¯¥é˜µè¥æ²¡æœ‰å‰©ä½™éƒ¨é˜Ÿéœ€è¦æµ‹è¯•`);
                    return;
                }
                
                this.addGameLog(`ğŸ“‹ éœ€è¦æµ‹è¯•çš„å•ä½æ•°é‡: ${remainingUnits.length}`);
                
                // é€ä¸ªå¯¹æ¯ä¸ªå•ä½è¿›è¡Œæµ‹è¯•
                for (const unit of remainingUnits) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // æŠ•æ·2D6
                    const dice1 = Math.floor(Math.random() * 6) + 1;
                    const dice2 = Math.floor(Math.random() * 6) + 1;
                    const roll = dice1 + dice2;
                    
                    this.addGameLog(`\nğŸ¯ ${unit.name} è¿›è¡Œå°†é¢†é˜µäº¡å£«æ°”æµ‹è¯•`);
                    this.addGameLog(`ğŸ² æŠ•æ·2D6: ${dice1} + ${dice2} = ${roll}`);
                    
                    // æŸ¥è¡¨è·å–ç»“æœ
                    const result = this.getGeneralDeathTestResult(unit, roll);
                    
                    this.addGameLog(`âœ… ç»“æœ: ${result.text}`);
                    console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${unit.name}, roll=${roll}, result=`, result);
                    
                    // åº”ç”¨ç»“æœ
                    await this.applyGeneralDeathTestResult(unit, result);
                }
                
                this.addGameLog(`\nâœ… å°†é¢†é˜µäº¡å£«æ°”æµ‹è¯•å®Œæˆ\n`);
                
                // æ›´æ–°æ˜¾ç¤º
                this.renderBoard();
                this.updateUI();
            }
            
            // æ ¹æ®éª°å­ç»“æœæŸ¥è¡¨è·å–å°†é¢†é˜µäº¡æµ‹è¯•ç»“æœ
            getGeneralDeathTestResult(unit, roll) {
                const category = this.getUnitCategory(unit);
                
                // æ ¹æ®å•ä½ç±»åˆ«å’Œéª°å­ç»“æœæŸ¥è¡¨
                if (roll >= 10) {
                    // 10+ï¼šæ‰€æœ‰å•ä½åšå®ˆ
                    return { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                } else if (roll === 9) {
                    // 9ï¼šæ­¥å…µ/éª‘å…µåšå®ˆï¼Œå¼“ç®­å…µæœ‰åºæ’¤é€€
                    if (category === 'archer') {
                        return { action: 'retreat_ordered', disorder: false, text: 'æœ‰åºåœ°æ’¤é€€' };
                    } else {
                        return { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                    }
                } else if (roll === 8) {
                    // 8ï¼šæ­¥å…µ/éª‘å…µåšå®ˆï¼Œå¼“ç®­å…µæ··ä¹±æ’¤é€€
                    if (category === 'archer') {
                        return { action: 'retreat_disordered', disorder: true, text: 'æ··ä¹±åœ°æ’¤é€€' };
                    } else {
                        return { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                    }
                } else if (roll === 7) {
                    // 7ï¼šæ­¥å…µåšå®ˆï¼Œéª‘å…µæœ‰åºæ’¤é€€ï¼Œå¼“ç®­å…µæ··ä¹±æ’¤é€€
                    if (category === 'infantry') {
                        return { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                    } else if (category === 'cavalry') {
                        return { action: 'retreat_ordered', disorder: false, text: 'æœ‰åºåœ°æ’¤é€€' };
                    } else { // archer
                        return { action: 'retreat_disordered', disorder: true, text: 'æ··ä¹±åœ°æ’¤é€€' };
                    }
                } else if (roll === 6) {
                    // 6ï¼šæ­¥å…µåšå®ˆå¹¶æ··ä¹±ï¼Œéª‘å…µæ··ä¹±æ’¤é€€ï¼Œå¼“ç®­å…µæ··ä¹±æ’¤é€€
                    if (category === 'infantry') {
                        return { action: 'hold', disorder: true, text: 'åšå®ˆå¹¶æ··ä¹±' };
                    } else {
                        return { action: 'retreat_disordered', disorder: true, text: 'æ··ä¹±åœ°æ’¤é€€' };
                    }
                } else if (roll === 5) {
                    // 5ï¼šæ­¥å…µåšå®ˆå¹¶æ··ä¹±ï¼Œéª‘å…µæ··ä¹±æ’¤é€€ï¼Œå¼“ç®­å…µè¢«æ¶ˆç­
                    if (category === 'infantry') {
                        return { action: 'hold', disorder: true, text: 'åšå®ˆå¹¶æ··ä¹±' };
                    } else if (category === 'cavalry') {
                        return { action: 'retreat_disordered', disorder: true, text: 'æ··ä¹±åœ°æ’¤é€€' };
                    } else { // archer
                        return { action: 'destroyed', disorder: false, text: 'è¢«æ¶ˆç­' };
                    }
                } else if (roll === 4) {
                    // 4ï¼šæ­¥å…µæ··ä¹±æ’¤é€€ï¼Œéª‘å…µè¢«æ¶ˆç­ï¼Œå¼“ç®­å…µè¢«æ¶ˆç­
                    if (category === 'infantry') {
                        return { action: 'retreat_disordered', disorder: true, text: 'æ··ä¹±åœ°æ’¤é€€' };
                    } else {
                        return { action: 'destroyed', disorder: false, text: 'è¢«æ¶ˆç­' };
                    }
                } else {
                    // 3åŠä»¥ä¸‹ï¼šæ‰€æœ‰å•ä½è¢«æ¶ˆç­
                    return { action: 'destroyed', disorder: false, text: 'è¢«æ¶ˆç­' };
                }
            }
            
            // åº”ç”¨å°†é¢†é˜µäº¡æµ‹è¯•ç»“æœ
            async applyGeneralDeathTestResult(unit, result) {
                switch (result.action) {
                    case 'hold':
                        // åšå®ˆåŸåœ°
                        console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${unit.name}åšå®ˆåŸåœ°`);
                        if (result.disorder) {
                            unit.order = 'chaotic';
                            this.addGameLog(`ğŸ“‹ ${unit.name}è¿›å…¥æ··ä¹±çŠ¶æ€`);
                        }
                        this.updateUnitDisplay(unit);
                        break;
                        
                    case 'retreat_ordered':
                        // æœ‰åºåé€€
                        console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${unit.name}æœ‰åºåé€€`);
                        const orderedRes = this.retreatUnit(unit, false, false, [], true);
                        if (orderedRes.destroyed) {
                            this.showDeathEffect(unit.x, unit.y);
                            await new Promise(resolve => setTimeout(resolve, 800));
                            this.checkAndDisengageUnits();
                            this.checkGameEnd();
                        }
                        break;
                        
                    case 'retreat_disordered':
                        // æ··ä¹±åé€€
                        console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${unit.name}æ··ä¹±åé€€`);
                        const disorderedRes = this.retreatUnit(unit, true, false, [], true);
                        if (disorderedRes.destroyed) {
                            this.showDeathEffect(unit.x, unit.y);
                            await new Promise(resolve => setTimeout(resolve, 800));
                            this.checkAndDisengageUnits();
                            this.checkGameEnd();
                        }
                        break;
                        
                    case 'destroyed':
                        // è¢«æ¶ˆç­
                        console.log(`[å°†é¢†é˜µäº¡æµ‹è¯•] ${unit.name}è¢«æ¶ˆç­`);
                        this.addGameLog(`ğŸ’€ ${unit.name}è¢«æ¶ˆç­ï¼`);
                        this.showDeathEffect(unit.x, unit.y);
                        await new Promise(resolve => setTimeout(resolve, 800));
                        this.removeUnit(unit);
                        this.checkAndDisengageUnits();
                        this.checkGameEnd();
                        break;
                }
            }
            
            // å°„å‡»é˜¶æ®µå´©æºƒæµ‹è¯•æŸ¥è¡¨ï¼ˆä¸è¿‘æˆ˜ä¸åŒï¼‰
            getRangedRouteTestResult(unit, roll) {
                const category = this.getUnitCategory(unit);
                console.log(`[getRangedRouteTestResult] å•ä½=${unit.name}, ç±»åˆ«=${category}, éª°å€¼=${roll}`);
                
                let result;
                
                // å°„å‡»é˜¶æ®µå´©æºƒæµ‹è¯•ç»“æœè¡¨
                if (roll >= 10) {
                    // 10+ï¼šå…¨éƒ¨åšå®ˆ
                    result = { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                } else if (roll === 9) {
                    if (category === 'archer') {
                        result = { action: 'retreat_ordered', disorder: false, withSupports: false, text: 'å¼“ç®­å…µæœ‰åºåœ°æ’¤é€€' };
                    } else { // infantry or cavalry
                        result = { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                    }
                } else if (roll === 8) {
                    if (category === 'archer') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'å¼“ç®­å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else { // infantry or cavalry
                        result = { action: 'hold', disorder: false, text: 'åšå®ˆ' };
                    }
                } else if (roll === 7) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_ordered', disorder: false, withSupports: false, text: 'éª‘å…µæœ‰åºåœ°æ’¤é€€' };
                    } else if (category === 'archer') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'å¼“ç®­å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else { // infantry
                        result = { action: 'hold', disorder: false, text: 'æ­¥å…µåšå®ˆ' };
                    }
                } else if (roll === 6) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'éª‘å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else if (category === 'archer') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'å¼“ç®­å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else { // infantry
                        result = { action: 'hold', disorder: true, text: 'æ­¥å…µåšå®ˆå¹¶æ··ä¹±' };
                    }
                } else if (roll === 5) {
                    if (category === 'cavalry') {
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'éª‘å…µæ··ä¹±åœ°æ’¤é€€' };
                    } else if (category === 'archer') {
                        result = { action: 'destroyed', text: 'å¼“ç®­å…µè¢«æ¶ˆç­' };
                    } else { // infantry
                        result = { action: 'hold', disorder: true, text: 'æ­¥å…µåšå®ˆå¹¶æ··ä¹±' };
                    }
                } else if (roll === 4) {
                    if (category === 'cavalry' || category === 'archer') {
                        result = { action: 'destroyed', text: 'è¢«æ¶ˆç­' };
                    } else { // infantry
                        result = { action: 'retreat_disordered', disorder: true, withSupports: false, text: 'æ­¥å…µæ··ä¹±åœ°æ’¤é€€' };
                    }
                } else { // roll <= 3
                    // 2-3ï¼šå…¨éƒ¨è¢«æ¶ˆç­
                    result = { action: 'destroyed', text: 'è¢«æ¶ˆç­' };
                }
                
                console.log(`[getRangedRouteTestResult] ç»“æœ: action=${result.action}, text=${result.text}`);
                return result;
            }
            
            // æ‰§è¡Œå°„å‡»é˜¶æ®µçš„å´©æºƒæµ‹è¯•
            performRangedRouteTest(unit, damageReceived) {
                console.log(`[performRangedRouteTest] å•ä½=${unit.name}, å—åˆ°ä¼¤å®³=${damageReceived}`);
                
                // æŠ•æ·2D6
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const baseRoll = die1 + die2;
                
                // è®¡ç®—ä¿®æ­£å€¼ï¼šæ•Œæ–¹ä¼¤å®³ - å·±æ–¹ä¼¤å®³ = 0 - damageReceived = -damageReceived
                const damageDiff = -damageReceived;
                const finalRoll = baseRoll + damageDiff;
                
                this.addGameLog(`ğŸ² å°„å‡»å´©æºƒæµ‹è¯•: 2D6=[${die1}+${die2}=${baseRoll}] ä¼¤å®³ä¿®æ­£=${damageDiff} æœ€ç»ˆ=${finalRoll}`);
                console.log(`[performRangedRouteTest] baseRoll=${baseRoll}, damageDiff=${damageDiff}, finalRoll=${finalRoll}`);
                
                // æŸ¥è¡¨è·å–ç»“æœ
                const result = this.getRangedRouteTestResult(unit, finalRoll);
                
                // åº”ç”¨ç»“æœï¼ˆå°„å‡»é˜¶æ®µä¸æ¶‰åŠæ”¯æ´å•ä½ï¼‰
                this.applyRouteResult(unit, result, []);
            }
            
            // åé€€å•ä½
            // æ£€æŸ¥æ’¤é€€è·¯å¾„æ˜¯å¦æœ‰æ•Œæ–¹å•ä½é˜»æŒ¡
            checkRetreatPath(unit, retreatDistance) {
                const oppositeDirection = {
                    'north': 'south',
                    'south': 'north',
                    'east': 'west',
                    'west': 'east'
                }[unit.direction];
                
                const unitSize = this.getUnitSizeWithDirection(unit);
                
                // æ£€æŸ¥æ’¤é€€è·¯å¾„ä¸Šçš„æ¯ä¸€æ ¼
                for (let step = 1; step <= retreatDistance; step++) {
                    let checkX = unit.x;
                    let checkY = unit.y;
                    
                    switch (oppositeDirection) {
                        case 'north':
                            checkY -= step;
                            break;
                        case 'south':
                            checkY += step;
                            break;
                        case 'east':
                            checkX += step;
                            break;
                        case 'west':
                            checkX -= step;
                            break;
                    }
                    
                    // æ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦æœ‰æ•Œæ–¹å•ä½
                    for (let unit2 of this.units) {
                        if (unit2.id === unit.id || unit2.faction === unit.faction) continue;
                        
                        const unit2Size = this.getUnitSizeWithDirection(unit2);
                        
                        // æ£€æŸ¥æ˜¯å¦é‡å 
                        if (checkX < unit2.x + unit2Size.width &&
                            checkX + unitSize.width > unit2.x &&
                            checkY < unit2.y + unit2Size.height &&
                            checkY + unitSize.height > unit2.y) {
                            return { canRetreat: false, blockedBy: unit2, blockedAt: step };
                        }
                    }
                }
                
                return { canRetreat: true, blockedBy: null, blockedAt: -1 };
            }

            retreatUnit(unit, isDisordered, withSupports, relatedSupports = [], fromRouteTest = false) {
                // æ£€æŸ¥å•ä½æ˜¯å¦è¿˜å­˜åœ¨
                if (!this.units.find(u => u.id === unit.id)) {
                    console.error(`[retreatUnit] å•ä½${unit.name}å·²ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåé€€`);
                    return { success: false, destroyed: false };
                }
                
                console.log(`[retreatUnit] å•ä½=${unit.name}, isDisordered=${isDisordered}, withSupports=${withSupports}, relatedSupportsæ•°é‡=${relatedSupports.length}, fromRouteTest=${fromRouteTest}`);
                console.log(`[retreatUnit] å•ä½å½“å‰ä½ç½®: (${unit.x}, ${unit.y}), æœå‘=${unit.direction}`);
                
                // è¿‘æˆ˜åé€€å›ºå®š6æ ¼
                const retreatDistance = 6;
                
                // æ£€æŸ¥æ’¤é€€è·¯å¾„æ˜¯å¦æœ‰æ•Œæ–¹å•ä½é˜»æŒ¡
                const pathCheck = this.checkRetreatPath(unit, retreatDistance);
                if (!pathCheck.canRetreat) {
                    this.addGameLog(`âš ï¸ ${unit.name}çš„æ’¤é€€è·¯å¾„è¢«${pathCheck.blockedBy.name}é˜»æŒ¡ï¼`);
                    
                    if (fromRouteTest) {
                        // å¦‚æœæ˜¯å´©æºƒæµ‹è¯•å¯¼è‡´çš„æ’¤é€€ä¸”æ— æ³•æ’¤é€€ï¼Œåˆ™æ¶ˆç­å•ä½
                        this.addGameLog(`ğŸ’€ ${unit.name}æ— æ³•æ’¤é€€ï¼Œè¢«æ¶ˆç­ï¼`);
                        this.removeUnit(unit);
                        return { success: false, destroyed: true };
                    } else {
                        // éå´©æºƒæµ‹è¯•çš„æ’¤é€€ï¼ˆä¾‹å¦‚é˜²å®ˆæ–¹é€‰æ‹©æ’¤é€€ï¼‰ï¼Œä¸å…è®¸æ’¤é€€
                        this.addGameLog(`âŒ ${unit.name}æ— æ³•æ’¤é€€ï¼`);
                        return { success: false, destroyed: false };
                    }
                }
                
                // è®¡ç®—åé€€æ–¹å‘ï¼ˆä¸å•ä½æœå‘ç›¸åï¼‰
                const oppositeDirection = {
                    'north': 'south',
                    'south': 'north',
                    'east': 'west',
                    'west': 'east'
                }[unit.direction];
                
                console.log(`[retreatUnit] åé€€æ–¹å‘=${oppositeDirection}`);
                
                // è®¡ç®—ç›®æ ‡ä½ç½®
                let targetX = unit.x;
                let targetY = unit.y;
                
                switch (oppositeDirection) {
                    case 'north':
                        targetY -= retreatDistance;
                        break;
                    case 'south':
                        targetY += retreatDistance;
                        break;
                    case 'east':
                        targetX += retreatDistance;
                        break;
                    case 'west':
                        targetX -= retreatDistance;
                        break;
                }
                
                // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                const unitSize = this.getUnitSizeWithDirection(unit);
                let finalX = targetX;
                let finalY = targetY;
                let blocked = false;
                
                // æ£€æŸ¥æ˜¯å¦å‡ºç•Œ
                if (targetX < 0 || targetY < 0 || 
                    targetX + unitSize.width > this.gridWidth || 
                    targetY + unitSize.height > this.gridHeight) {
                    // å°½å¯èƒ½åé€€
                    finalX = Math.max(0, Math.min(targetX, this.gridWidth - unitSize.width));
                    finalY = Math.max(0, Math.min(targetY, this.gridHeight - unitSize.height));
                    blocked = true;
                    this.addGameLog(`âš ï¸ ${unit.name}åé€€å—é˜»ï¼ˆåœ°å›¾è¾¹ç•Œï¼‰`);
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å•ä½é‡å 
                if (!blocked && this.isAreaOccupiedByOthers(finalX, finalY, unitSize.width, unitSize.height, unit.id)) {
                    // å°è¯•éƒ¨åˆ†åé€€
                    let partialDistance = 0;
                    for (let d = retreatDistance - 1; d > 0; d--) {
                        let testX = unit.x;
                        let testY = unit.y;
                        switch (oppositeDirection) {
                            case 'north': testY -= d; break;
                            case 'south': testY += d; break;
                            case 'east': testX += d; break;
                            case 'west': testX -= d; break;
                        }
                        if (!this.isAreaOccupiedByOthers(testX, testY, unitSize.width, unitSize.height, unit.id)) {
                            finalX = testX;
                            finalY = testY;
                            partialDistance = d;
                            break;
                        }
                    }
                    if (partialDistance > 0) {
                        blocked = true;
                        this.addGameLog(`âš ï¸ ${unit.name}åé€€å—é˜»ï¼Œåªèƒ½åé€€${partialDistance}æ ¼`);
                    } else {
                        finalX = unit.x;
                        finalY = unit.y;
                        blocked = true;
                        this.addGameLog(`âš ï¸ ${unit.name}åé€€å®Œå…¨å—é˜»ï¼`);
                    }
                }
                
                // ç§»åŠ¨å•ä½
                if (finalX !== unit.x || finalY !== unit.y) {
                    console.log(`[retreatUnit] ç§»åŠ¨å•ä½ä»(${unit.x}, ${unit.y})åˆ°(${finalX}, ${finalY})`);
                    unit.x = finalX;
                    unit.y = finalY;
                    this.addGameLog(`ğŸƒ ${unit.name}åé€€åˆ°(${finalX}, ${finalY})`);
                } else {
                    console.log(`[retreatUnit] å•ä½ä½ç½®æœªæ”¹å˜`);
                }
                
                // å¤„ç†æ··ä¹±çŠ¶æ€
                if (isDisordered || blocked) {
                    console.log(`[retreatUnit] è®¾ç½®æ··ä¹±çŠ¶æ€: isDisordered=${isDisordered}, blocked=${blocked}`);
                    unit.order = 'chaotic';
                    this.addGameLog(`ğŸ“‹ ${unit.name}è¿›å…¥æ··ä¹±çŠ¶æ€`);
                } else {
                    console.log(`[retreatUnit] ä¸è®¾ç½®æ··ä¹±çŠ¶æ€`);
                }
                
                // æ¸…é™¤åé€€å•ä½çš„æ”¯æ´çŠ¶æ€
                if (unit.combatStatus === 'supporting') {
                    console.log(`[retreatUnit] æ¸…é™¤å•ä½${unit.name}çš„æ”¯æ´çŠ¶æ€`);
                    unit.combatStatus = 'not_engaged';
                    unit.supportingUnit = null;
                    this.addGameLog(`ğŸƒ ${unit.name}è„±ç¦»æ”¯æ´çŠ¶æ€`);
                }
                
                // å¤„ç†æ”¯æ´å•ä½ï¼ˆåªå½±å“ä¼ å…¥çš„relatedSupportsåˆ—è¡¨ä¸­çš„å•ä½ï¼‰
                if (withSupports && relatedSupports.length > 0) {
                    relatedSupports.forEach(support => {
                        // æ£€æŸ¥æ”¯æ´å•ä½æ˜¯å¦è¿˜å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«æ¶ˆç­ï¼‰
                        if (!this.units.find(u => u.id === support.id)) {
                            console.log(`[retreatUnit] æ”¯æ´å•ä½${support.name}å·²ä¸å­˜åœ¨`);
                            return;
                        }
                        
                        console.log(`[retreatUnit] å¤„ç†æ”¯æ´å•ä½${support.name}, å½“å‰ä½ç½®:(${support.x}, ${support.y})`);
                        console.log(`[retreatUnit] ä¸»å•ä½åé€€åˆ°ä½ç½®: finalX=${finalX}, finalY=${finalY}`);
                        
                        this.addGameLog(`ğŸ‘¥ ${support.name}è·Ÿéš${unit.name}ä¸€èµ·åé€€`);
                        // æ”¯æ´å•ä½ä¹Ÿåé€€ï¼ˆç®€åŒ–å¤„ç†ï¼Œåé€€åˆ°ä¸»å•ä½é™„è¿‘ï¼‰
                        const offsetX = Math.floor(Math.random() * 3) - 1;
                        const offsetY = Math.floor(Math.random() * 3) - 1;
                        console.log(`[retreatUnit] éšæœºåç§»: offsetX=${offsetX}, offsetY=${offsetY}`);
                        
                        let supportTargetX = finalX + offsetX;
                        let supportTargetY = finalY + offsetY;
                        console.log(`[retreatUnit] åˆå§‹ç›®æ ‡ä½ç½®: (${supportTargetX}, ${supportTargetY})`);
                        
                        const supportSize = this.getUnitSizeWithDirection(support);
                        console.log(`[retreatUnit] æ”¯æ´å•ä½å°ºå¯¸: ${supportSize.width}x${supportSize.height}`);
                        console.log(`[retreatUnit] åœ°å›¾å°ºå¯¸: gridWidth=${this.gridWidth}, gridHeight=${this.gridHeight}`);
                        
                        supportTargetX = Math.max(0, Math.min(supportTargetX, this.gridWidth - supportSize.width));
                        supportTargetY = Math.max(0, Math.min(supportTargetY, this.gridHeight - supportSize.height));
                        console.log(`[retreatUnit] è¾¹ç•Œé™åˆ¶åä½ç½®: (${supportTargetX}, ${supportTargetY})`);
                        
                        if (!this.isAreaOccupiedByOthers(supportTargetX, supportTargetY, supportSize.width, supportSize.height, support.id)) {
                            console.log(`[retreatUnit] ä½ç½®æœªè¢«å ç”¨ï¼Œæ›´æ–°æ”¯æ´å•ä½ä½ç½®: (${support.x}, ${support.y}) -> (${supportTargetX}, ${supportTargetY})`);
                            support.x = supportTargetX;
                            support.y = supportTargetY;
                            this.addGameLog(`ğŸƒ ${support.name}åé€€åˆ°(${supportTargetX}, ${supportTargetY})`);
                        } else {
                            console.log(`[retreatUnit] ä½ç½®è¢«å ç”¨ï¼Œæ”¯æ´å•ä½ä¿æŒåŸä½: (${support.x}, ${support.y})`);
                            this.addGameLog(`âš ï¸ ${support.name}åé€€å—é˜»ï¼Œä¿æŒåŸä½`);
                        }
                        
                        if (isDisordered) {
                            support.order = 'chaotic';
                        }
                        
                        console.log(`[retreatUnit] æ”¯æ´å•ä½${support.name}æœ€ç»ˆä½ç½®: (${support.x}, ${support.y})`);
                        this.updateUnitDisplay(support);
                    });
                }
                
                this.updateUnitDisplay(unit);
                this.renderBoard();
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å•ä½å› åé€€è„±ç¦»è¿‘æˆ˜
                this.checkAndDisengageUnits();
                
                return { success: true, destroyed: false };
            }
            
            // é‡ç½®å†²é”‹çŠ¶æ€
            resetChargeState() {
                this.meleeType = null;
                this.meleeAttacker = null;
                this.meleeTarget = null;
                this.attackerSupports = [];
                this.defenderSupports = [];
                this.meleeSubPhase = 'select_attacker';
                
                // é‡ç½®åç«‹å³æ›´æ–°UIä»¥éšè—æ‰§è¡Œå†²é”‹æŒ‰é’®
                this.renderBoard();
                this.updateUI();
            }
            
            // æŸ¥æ‰¾æ‰€æœ‰å¯ä»¥è¿›è¡ŒæŒç»­è¿‘æˆ˜çš„å•ä½
            getAvailableSustainedMeleeUnits() {
                return this.units.filter(unit => {
                    // åŸºæœ¬æ¡ä»¶ï¼šå½“å‰ç©å®¶ã€å¤„äºè¿‘æˆ˜ä¸­ã€æœ¬å›åˆæœªè¿›è¡Œè¿‘æˆ˜
                    if (unit.faction !== this.currentPlayer) return false;
                    if (unit.combatStatus !== 'engaged') return false;
                    if (unit.hasMeleeAttacked) return false;
                    if (!unit.engagedWith) return false;
                    
                    // æ£€æŸ¥åŸå¯¹æ‰‹æ˜¯å¦è¿˜åœ¨3æ ¼å†…
                    const opponent = this.units.find(u => u.id === unit.engagedWith);
                    if (!opponent) return false;
                    
                    const centerX = unit.x + Math.floor(this.getUnitSizeWithDirection(unit).width / 2);
                    const centerY = unit.y + Math.floor(this.getUnitSizeWithDirection(unit).height / 2);
                    const opponentCenterX = opponent.x + Math.floor(this.getUnitSizeWithDirection(opponent).width / 2);
                    const opponentCenterY = opponent.y + Math.floor(this.getUnitSizeWithDirection(opponent).height / 2);
                    const distance = this.getDistance(centerX, centerY, opponentCenterX, opponentCenterY);
                    
                    return distance <= 3;
                });
            }
            
            // è‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªæŒç»­è¿‘æˆ˜
            autoStartNextSustainedMelee() {
                console.log('[æŒç»­è¿‘æˆ˜] æ£€æŸ¥æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå¯æŒç»­è¿‘æˆ˜çš„å•ä½');
                
                const availableUnits = this.getAvailableSustainedMeleeUnits();
                console.log(`[æŒç»­è¿‘æˆ˜] æ‰¾åˆ° ${availableUnits.length} ä¸ªå¯æŒç»­è¿‘æˆ˜çš„å•ä½`);
                
                if (availableUnits.length === 0) {
                    // æ²¡æœ‰æ›´å¤šæŒç»­è¿‘æˆ˜å•ä½ï¼Œç»“æŸæŒç»­è¿‘æˆ˜æµç¨‹
                    console.log('[æŒç»­è¿‘æˆ˜] æ²¡æœ‰æ›´å¤šå•ä½ï¼Œç»“æŸæŒç»­è¿‘æˆ˜æµç¨‹');
                    this.addGameLog(`\nâœ… æ‰€æœ‰æŒç»­è¿‘æˆ˜å·²å®Œæˆ`);
                    return false;
                }
                
                // é€‰æ‹©ç¬¬ä¸€ä¸ªå•ä½è‡ªåŠ¨å¼€å§‹æŒç»­è¿‘æˆ˜
                const nextUnit = availableUnits[0];
                const opponent = this.units.find(u => u.id === nextUnit.engagedWith);
                
                console.log(`[æŒç»­è¿‘æˆ˜] è‡ªåŠ¨å¼€å§‹: ${nextUnit.name} VS ${opponent.name}`);
                this.addGameLog(`\nğŸ”„ è‡ªåŠ¨è¿›è¡ŒæŒç»­è¿‘æˆ˜...`);
                
                // è®¾ç½®ä¸ºæŒç»­è¿‘æˆ˜
                this.meleeType = 'sustained';
                this.meleeAttacker = nextUnit;
                this.meleeTarget = opponent;
                this.meleeSubPhase = 'select_attacker_support';
                
                this.addGameLog(`âš”ï¸ æŒç»­è¿‘æˆ˜: ${nextUnit.name} VS ${opponent.name}`);
                this.addGameLog(`ğŸ’ª è¯·é€‰æ‹©æ”»å‡»æ–¹æ”¯æ´éƒ¨é˜Ÿï¼ˆ3æ ¼èŒƒå›´å†…ï¼Œå¯å¤šé€‰ï¼‰ï¼Œå®Œæˆåç‚¹å‡»"å®Œæˆæ”¯æ´é€‰æ‹©"æŒ‰é’®`);
                
                this.renderBoard();
                this.updateUI();
                return true;
            }
            
            // æ··ä¹±çŠ¶æ€æ¢å¤æµ‹è¯•ï¼ˆRally Testï¼‰
            performRallyTests() {
                const currentPlayerName = this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                
                // æ‰¾å‡ºæ‰€æœ‰å½“å‰ç©å®¶çš„æ··ä¹±å•ä½
                const chaoticUnits = this.units.filter(u => 
                    u.faction === this.currentPlayer && 
                    u.order === 'chaotic'
                );
                
                if (chaoticUnits.length === 0) {
                    return; // æ²¡æœ‰æ··ä¹±å•ä½ï¼Œä¸éœ€è¦æµ‹è¯•
                }
                
                this.addGameLog(`\nğŸ“‹ ${currentPlayerName}æ··ä¹±éƒ¨é˜Ÿå°è¯•æ¢å¤ç§©åº...`);
                
                chaoticUnits.forEach(unit => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    console.log(`[æ¢å¤æµ‹è¯•] ${unit.name} æŠ•æ·D6: ${roll}`);
                    
                    if (roll >= 4) {
                        // æˆåŠŸæ¢å¤
                        unit.order = 'good';
                        this.addGameLog(`âœ… ${unit.name}æŠ•æ·${roll}ï¼ŒæˆåŠŸæ¢å¤ç§©åºï¼`);
                        this.updateUnitDisplay(unit);
                    } else {
                        // å¤±è´¥
                        this.addGameLog(`âŒ ${unit.name}æŠ•æ·${roll}ï¼Œä»ç„¶æ··ä¹±`);
                    }
                });
                
                this.renderBoard();
            }
            
            // æ£€æŸ¥å¹¶è§£é™¤è¶…è·çš„è¿‘æˆ˜çŠ¶æ€
            checkAndDisengageUnits() {
                const unitsToDisengage = [];
                
                // æ£€æŸ¥æ‰€æœ‰è¿‘æˆ˜ä¸­çš„å•ä½
                this.units.forEach(unit => {
                    if (unit.combatStatus === 'engaged' && unit.engagedWith) {
                        // æ‰¾åˆ°å…¶è¿‘æˆ˜å¯¹æ‰‹
                        const opponent = this.units.find(u => u.id === unit.engagedWith);
                        if (!opponent) {
                            // å¯¹æ‰‹å·²ç»ä¸å­˜åœ¨ï¼ˆè¢«æ¶ˆç­ï¼‰ï¼Œè§£é™¤è¿‘æˆ˜çŠ¶æ€
                            unitsToDisengage.push(unit);
                            return;
                        }
                        
                        // è®¡ç®—è·ç¦»
                        const unitCenterX = unit.x + Math.floor(this.getUnitSizeWithDirection(unit).width / 2);
                        const unitCenterY = unit.y + Math.floor(this.getUnitSizeWithDirection(unit).height / 2);
                        const opponentCenterX = opponent.x + Math.floor(this.getUnitSizeWithDirection(opponent).width / 2);
                        const opponentCenterY = opponent.y + Math.floor(this.getUnitSizeWithDirection(opponent).height / 2);
                        const distance = this.getDistance(unitCenterX, unitCenterY, opponentCenterX, opponentCenterY);
                        
                        // å¦‚æœè·ç¦»è¶…è¿‡3æ ¼ï¼Œæ ‡è®°ä¸ºéœ€è¦è§£é™¤
                        if (distance > 3) {
                            if (!unitsToDisengage.find(u => u.id === unit.id)) {
                                unitsToDisengage.push(unit);
                            }
                            if (!unitsToDisengage.find(u => u.id === opponent.id)) {
                                unitsToDisengage.push(opponent);
                            }
                        }
                    }
                });
                
                // è§£é™¤è¿‘æˆ˜çŠ¶æ€
                unitsToDisengage.forEach(unit => {
                    const opponentId = unit.engagedWith;
                    const opponent = this.units.find(u => u.id === opponentId);
                    
                    this.addGameLog(`ğŸƒ ${unit.name}è„±ç¦»äº†ä¸${opponent ? opponent.name : 'å¯¹æ‰‹'}çš„è¿‘æˆ˜`);
                    
                    // è§£é™¤è¯¥å•ä½çš„è¿‘æˆ˜çŠ¶æ€
                    unit.combatStatus = 'not_engaged';
                    unit.engagedWith = null;
                    this.updateUnitDisplay(unit);
                    
                    // æ‰¾å‡ºæ‰€æœ‰æ”¯æ´è¯¥å•ä½çš„å•ä½ï¼Œå¹¶è§£é™¤æ”¯æ´çŠ¶æ€
                    const supportingUnits = this.units.filter(u => u.supportingUnit === unit.id);
                    supportingUnits.forEach(support => {
                        this.addGameLog(`ğŸƒ ${support.name}è§£é™¤äº†å¯¹${unit.name}çš„æ”¯æ´çŠ¶æ€`);
                        support.combatStatus = 'not_engaged';
                        support.supportingUnit = null;
                        this.updateUnitDisplay(support);
                    });
                });
                
                if (unitsToDisengage.length > 0) {
                    this.renderBoard();
                }
            }
            
            // é˜²å¾¡æ–¹é€‰æ‹©æ’¤é€€
            confirmRangedAttack() {
                if (!this.rangedAttacker || !this.rangedTarget) {
                    this.addGameLog('âš ï¸ è¯·å…ˆé€‰æ‹©å°„å‡»å•ä½å’Œç›®æ ‡');
                    return;
                }
                
                // æ‰§è¡Œå°„å‡»æ”»å‡»
                this.executeRangedAttack(this.rangedAttacker, this.rangedTarget);
                
                // é‡ç½®çŠ¶æ€
                this.rangedAttacker = null;
                this.rangedTarget = null;
                this.selectedUnit = null;
                this.moveState = 'none';
                this.clearHighlights();
                
                // æ›´æ–°UI
                setTimeout(() => {
                    this.renderBoard();
                    this.updateUI();
                }, 1000);
            }
            
            defenderChooseRetreat() {
                const defender = this.meleeTarget;
                this.addGameLog(`ğŸƒ ${defender.name}é€‰æ‹©æ’¤é€€ï¼Œåæ’¤6æ ¼`);
                
                // æ‰§è¡Œåæ’¤6æ ¼ï¼ˆæœ‰åºæ’¤é€€ï¼Œéå´©æºƒæµ‹è¯•ï¼‰
                const retreatResult = this.retreatUnit(defender, false, false, [], false);
                
                if (!retreatResult.success) {
                    // æ’¤é€€å¤±è´¥ï¼Œè‡ªåŠ¨è¿›å…¥æˆ˜æ–—ç¯èŠ‚
                    this.addGameLog(`âŒ ${defender.name}æ’¤é€€å¤±è´¥ï¼Œè‡ªåŠ¨è¿›å…¥æˆ˜æ–—ï¼`);
                    setTimeout(() => {
                        this.defenderChooseStand();
                    }, 500);
                    return;
                }
                
                // é‡ç½®è¿‘æˆ˜çŠ¶æ€
                setTimeout(() => {
                    this.addGameLog(`âœ… æ’¤é€€å®Œæˆï¼Œå†²é”‹å–æ¶ˆ`);
                    this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome'; // åˆ‡æ¢å›æ”»å‡»æ–¹
                    this.resetChargeState();
                }, 800);
            }
            
            // é˜²å¾¡æ–¹é€‰æ‹©åšå®ˆæˆ˜æ–—
            defenderChooseStand() {
                const defender = this.meleeTarget;
                this.addGameLog(`âš”ï¸ ${defender.name}é€‰æ‹©åšå®ˆæˆ˜æ–—ï¼`);
                
                // åˆ‡æ¢å›æ”»å‡»æ–¹ï¼Œè¿›å…¥æ”¯æ´é€‰æ‹©é˜¶æ®µ
                this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome';
                this.meleeSubPhase = 'select_attacker_support';
                this.addGameLog(`ğŸ’ª è¯·é€‰æ‹©æ”»å‡»æ–¹æ”¯æ´éƒ¨é˜Ÿï¼ˆ3æ ¼èŒƒå›´å†…ï¼Œå¯å¤šé€‰ï¼‰ï¼Œå®Œæˆåç‚¹å‡»"å®Œæˆæ”¯æ´é€‰æ‹©"æŒ‰é’®`);
                this.renderBoard();
                this.updateUI();
            }
            
            // å®Œæˆæ”»å‡»æ–¹æ”¯æ´é€‰æ‹©
            finishAttackerSupport() {
                this.addGameLog(`âœ… æ”»å‡»æ–¹æ”¯æ´é€‰æ‹©å®Œæˆï¼Œå…±${this.attackerSupports.length}ä¸ªæ”¯æ´å•ä½`);
                // åˆ‡æ¢åˆ°é˜²å®ˆæ–¹é€‰æ‹©æ”¯æ´
                this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome';
                this.meleeSubPhase = 'select_defender_support';
                this.addGameLog(`ğŸ”„ è½®åˆ°${this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}é€‰æ‹©é˜²å®ˆæ–¹æ”¯æ´éƒ¨é˜Ÿ`);
                this.renderBoard();
                this.updateUI();
            }
            
            // å®Œæˆé˜²å®ˆæ–¹æ”¯æ´é€‰æ‹©
            finishDefenderSupport() {
                this.addGameLog(`âœ… é˜²å®ˆæ–¹æ”¯æ´é€‰æ‹©å®Œæˆï¼Œå…±${this.defenderSupports.length}ä¸ªæ”¯æ´å•ä½`);
                // åˆ‡æ¢å›åŸæ¥çš„ç©å®¶
                this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome';
                
                // è‡ªåŠ¨æ‰§è¡Œè¿‘æˆ˜ï¼Œä¸éœ€è¦ç‚¹å‡»æ‰§è¡ŒæŒ‰é’®
                this.meleeSubPhase = 'executing';
                this.renderBoard();
                this.updateUI();
                
                // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´è®©UIæ›´æ–°ï¼Œç„¶åè‡ªåŠ¨æ‰§è¡Œ
                setTimeout(() => {
                    this.executeChargeAttack();
                    this.renderBoard();
                    this.updateUI();
                }, 300);
            }

            showAttackEffect(x, y, damage) {
                const targetHex = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                if (!targetHex) {
                    console.log(`æ‰¾ä¸åˆ°ç›®æ ‡æ ¼å­: (${x}, ${y})`);
                    return;
                }

                console.log(`æ˜¾ç¤ºæ”»å‡»ç‰¹æ•ˆåœ¨ä½ç½® (${x}, ${y}), ä¼¤å®³: ${damage}`);

                // åˆ›å»ºä¼¤å®³æ•°å­—å¼¹å‡ºæ•ˆæœ
                const damagePopup = document.createElement('div');
                damagePopup.className = 'damage-popup';
                damagePopup.textContent = `-${damage}`;
                damagePopup.style.cssText = `
                    position: absolute;
                    left: 50%;
                    top: 20%;
                    transform: translateX(-50%);
                    z-index: 25;
                    font-size: 20px;
                    font-weight: bold;
                    color: #e74c3c;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                    pointer-events: none;
                `;
                
                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                const explosion = document.createElement('div');
                explosion.className = 'explosion-effect';
                explosion.textContent = 'ğŸ’¥';
                explosion.style.cssText = `
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 24;
                    font-size: 30px;
                    pointer-events: none;
                `;

                targetHex.appendChild(damagePopup);
                targetHex.appendChild(explosion);

                // å¯åŠ¨åŠ¨ç”»
                setTimeout(() => {
                    damagePopup.style.animation = 'damageFloat 2s ease-out forwards';
                    explosion.style.animation = 'explosion 1s ease-out forwards';
                }, 10);

                // éœ‡åŠ¨æ•ˆæœ
                targetHex.style.animation = 'shake 0.5s ease-in-out';
                
                // æ¸…ç†ç‰¹æ•ˆ
                setTimeout(() => {
                    if (damagePopup.parentNode) damagePopup.remove();
                    if (explosion.parentNode) explosion.remove();
                    targetHex.style.animation = '';
                }, 2100);
            }

            showDeathEffect(x, y) {
                const targetHex = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                if (!targetHex) {
                    console.log(`æ‰¾ä¸åˆ°æ­»äº¡ç‰¹æ•ˆç›®æ ‡æ ¼å­: (${x}, ${y})`);
                    return;
                }

                console.log(`æ˜¾ç¤ºæ­»äº¡ç‰¹æ•ˆåœ¨ä½ç½® (${x}, ${y})`);

                // æ­»äº¡ç‰¹æ•ˆ
                const deathEffect = document.createElement('div');
                deathEffect.textContent = 'ğŸ’€';
                deathEffect.style.cssText = `
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 26;
                    font-size: 40px;
                    pointer-events: none;
                `;

                targetHex.appendChild(deathEffect);

                // å¯åŠ¨æ­»äº¡åŠ¨ç”»
                setTimeout(() => {
                    deathEffect.style.animation = 'explosion 1.5s ease-out forwards';
                }, 100);

                setTimeout(() => {
                    if (deathEffect.parentNode) deathEffect.remove();
                }, 1600);
            }

            // æ˜¾ç¤ºå°„å‡»åŠ¨ç”»
            showRangedAttackAnimation(attacker, defender, arrowCount, callback) {
                const container = document.getElementById('square-grid');
                if (!container) {
                    console.error('æ‰¾ä¸åˆ°æ¸¸æˆå®¹å™¨');
                    if (callback) callback();
                    return;
                }

                const squareSize = 16;
                
                // è®¡ç®—å°„å‡»è€…å’Œç›®æ ‡çš„ä¸­å¿ƒä½ç½®
                const attackerSize = this.getUnitSizeWithDirection(attacker);
                const defenderSize = this.getUnitSizeWithDirection(defender);
                
                const startX = (attacker.x + attackerSize.width / 2) * squareSize;
                const startY = (attacker.y + attackerSize.height / 2) * squareSize;
                const endX = (defender.x + defenderSize.width / 2) * squareSize;
                const endY = (defender.y + defenderSize.height / 2) * squareSize;

                console.log(`å°„å‡»åŠ¨ç”»: ä»(${startX}, ${startY})åˆ°(${endX}, ${endY}), ${arrowCount}æ”¯ç®­`);

                // åˆ›å»ºå¤šæ”¯ç®­çŸ¢
                const arrows = [];
                for (let i = 0; i < arrowCount; i++) {
                    setTimeout(() => {
                        this.createArrowAnimation(container, startX, startY, endX, endY, i, callback && i === arrowCount - 1 ? callback : null);
                    }, i * 150); // æ¯æ”¯ç®­é—´éš”150mså‘å°„
                }
            }

            // åˆ›å»ºå•æ”¯ç®­çŸ¢åŠ¨ç”»
            createArrowAnimation(container, startX, startY, endX, endY, arrowIndex, callback) {
                // æ·»åŠ ä¸€äº›éšæœºåç§»ï¼Œè®©ç®­çŸ¢ä¸å®Œå…¨é‡å 
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetY = (Math.random() - 0.5) * 20;
                const actualEndX = endX + offsetX;
                const actualEndY = endY + offsetY;

                // è®¡ç®—ç®­çŸ¢è§’åº¦
                const dx = actualEndX - startX;
                const dy = actualEndY - startY;
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                const distance = Math.sqrt(dx * dx + dy * dy);

                // åˆ›å»ºç®­çŸ¢å…ƒç´ 
                const arrow = document.createElement('div');
                arrow.style.cssText = `
                    position: absolute;
                    left: ${startX}px;
                    top: ${startY}px;
                    width: 20px;
                    height: 3px;
                    background: linear-gradient(90deg, #8B4513 0%, #DEB887 50%, #CD853F 100%);
                    transform: rotate(${angle}deg);
                    transform-origin: left center;
                    z-index: 1000;
                    pointer-events: none;
                    border-radius: 1px;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
                `;

                // æ·»åŠ ç®­å¤´
                const arrowHead = document.createElement('div');
                arrowHead.style.cssText = `
                    position: absolute;
                    right: -6px;
                    top: -2px;
                    width: 0;
                    height: 0;
                    border-left: 8px solid #8B4513;
                    border-top: 4px solid transparent;
                    border-bottom: 4px solid transparent;
                `;
                arrow.appendChild(arrowHead);

                container.appendChild(arrow);

                // åŠ¨ç”»é£è¡Œæ—¶é—´åŸºäºè·ç¦»
                const flightTime = Math.min(1000, Math.max(300, distance * 2));

                // ç®­çŸ¢é£è¡ŒåŠ¨ç”»
                setTimeout(() => {
                    arrow.style.transition = `left ${flightTime}ms ease-out, top ${flightTime}ms ease-out`;
                    arrow.style.left = `${actualEndX}px`;
                    arrow.style.top = `${actualEndY}px`;

                    // æ·»åŠ é‡åŠ›æ•ˆæœï¼ˆæŠ›ç‰©çº¿ï¼‰
                    const midTime = flightTime / 2;
                    setTimeout(() => {
                        arrow.style.transform = `rotate(${angle + 15}deg)`; // ç®­çŸ¢ä¸‹è½æ—¶è§’åº¦å˜åŒ–
                    }, midTime);

                }, 50);

                // ç®­çŸ¢æ’å‡»æ•ˆæœ
                setTimeout(() => {
                    // æ’å‡»é—ªå…‰æ•ˆæœ
                    const impact = document.createElement('div');
                    impact.style.cssText = `
                        position: absolute;
                        left: ${actualEndX - 10}px;
                        top: ${actualEndY - 10}px;
                        width: 20px;
                        height: 20px;
                        background: radial-gradient(circle, #FFD700 0%, #FF8C00 50%, transparent 70%);
                        border-radius: 50%;
                        z-index: 999;
                        pointer-events: none;
                        animation: impactFlash 0.3s ease-out forwards;
                    `;
                    container.appendChild(impact);

                    // ç§»é™¤ç®­çŸ¢å’Œæ’å‡»æ•ˆæœ
                    setTimeout(() => {
                        if (arrow.parentNode) arrow.remove();
                        if (impact.parentNode) impact.remove();
                        
                        // å¦‚æœæ˜¯æœ€åä¸€æ”¯ç®­ï¼Œæ‰§è¡Œå›è°ƒ
                        if (callback) callback();
                    }, 300);

                }, flightTime + 50);
            }

            // è¿‘æˆ˜å†²é”‹åŠ¨ç”»
            showMeleeChargeAnimation(attacker, defender, callback) {
                const container = document.getElementById('square-grid');
                if (!container) {
                    console.error('æ‰¾ä¸åˆ°æ¸¸æˆå®¹å™¨');
                    if (callback) callback();
                    return;
                }

                const squareSize = 16;
                
                // è®¡ç®—æ”»å‡»è€…å’Œé˜²å®ˆè€…çš„ä½ç½®
                const attackerSize = this.getUnitSizeWithDirection(attacker);
                const defenderSize = this.getUnitSizeWithDirection(defender);
                
                const attackerCenterX = attacker.x + attackerSize.width / 2;
                const attackerCenterY = attacker.y + attackerSize.height / 2;
                const defenderCenterX = defender.x + defenderSize.width / 2;
                const defenderCenterY = defender.y + defenderSize.height / 2;
                
                // è®¡ç®—å†²é”‹æ–¹å‘
                const dx = (defenderCenterX - attackerCenterX) * squareSize * 0.3;
                const dy = (defenderCenterY - attackerCenterY) * squareSize * 0.3;
                
                // æ‰¾åˆ°æ”»å‡»è€…å•ä½å…ƒç´ 
                const attackerElements = document.querySelectorAll(`.unit-large[data-unit-id="${attacker.id}"]`);
                
                if (attackerElements.length > 0) {
                    attackerElements.forEach(elem => {
                        elem.style.setProperty('--charge-x', `${dx}px`);
                        elem.style.setProperty('--charge-y', `${dy}px`);
                        elem.style.animation = 'chargeForward 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                    });
                    
                    // å†²é”‹ä¸­é€”æ˜¾ç¤ºæ–©å‡»æ•ˆæœ
                    setTimeout(() => {
                        this.showSlashEffect(defenderCenterX * squareSize, defenderCenterY * squareSize);
                    }, 400);
                    
                    // é‡ç½®åŠ¨ç”»
                    setTimeout(() => {
                        attackerElements.forEach(elem => {
                            elem.style.animation = '';
                        });
                        if (callback) callback();
                    }, 800);
                } else {
                    if (callback) callback();
                }
            }

            // æ–©å‡»è½¨è¿¹æ•ˆæœ
            showSlashEffect(x, y) {
                const container = document.getElementById('square-grid');
                if (!container) return;
                
                // åˆ›å»ºæ–©å‡»æ•ˆæœ
                const slash = document.createElement('div');
                slash.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 60px;
                    height: 60px;
                    background: linear-gradient(135deg, 
                        transparent 0%, 
                        rgba(255, 255, 255, 0.9) 20%, 
                        rgba(255, 200, 0, 0.8) 50%, 
                        rgba(255, 100, 0, 0.6) 80%, 
                        transparent 100%);
                    border-radius: 10px;
                    z-index: 1000;
                    pointer-events: none;
                    animation: slashEffect 0.6s ease-out forwards;
                    box-shadow: 0 0 20px rgba(255, 200, 0, 0.8);
                `;
                
                container.appendChild(slash);
                
                // æ·»åŠ å†²å‡»æ³¢
                const shockwave = document.createElement('div');
                shockwave.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 40px;
                    height: 40px;
                    border: 3px solid rgba(255, 255, 255, 0.8);
                    border-radius: 50%;
                    z-index: 999;
                    pointer-events: none;
                    animation: shockwave 0.5s ease-out forwards;
                `;
                
                container.appendChild(shockwave);
                
                // æ¸…ç†ç‰¹æ•ˆ
                setTimeout(() => {
                    if (slash.parentNode) slash.remove();
                    if (shockwave.parentNode) shockwave.remove();
                }, 600);
            }

            // å¢å¼ºä¼¤å®³æ•ˆæœï¼ˆæ”¯æŒæš´å‡»ã€è¿å‡»ï¼‰
            showEnhancedDamageEffect(x, y, damage, options = {}) {
                const { isCritical = false, comboCount = 0, attackType = 'melee', isMiss = false } = options;
                
                const targetHex = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                if (!targetHex) return;

                // åˆ›å»ºä¸»ä¼¤å®³æ•°å­—æˆ–MISSæ–‡å­—
                const damagePopup = document.createElement('div');
                damagePopup.className = 'damage-popup';
                
                if (isMiss) {
                    // MISSæ•ˆæœ
                    damagePopup.textContent = 'MISS';
                    damagePopup.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 30%;
                        z-index: 25;
                        font-size: 28px;
                        font-weight: bold;
                        color: #95a5a6;
                        text-shadow: 
                            2px 2px 4px rgba(0,0,0,0.9),
                            0 0 8px rgba(149, 165, 166, 0.5);
                        pointer-events: none;
                        transform: translateX(-50%);
                        animation: missFloat 1.5s ease-out forwards;
                    `;
                } else {
                    // æ­£å¸¸ä¼¤å®³æ•ˆæœ
                    damagePopup.textContent = `-${damage}`;
                    damagePopup.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 30%;
                        z-index: 25;
                        font-size: ${isCritical ? '32px' : '24px'};
                        font-weight: bold;
                        color: ${isCritical ? '#ff0000' : '#e74c3c'};
                        text-shadow: 
                            2px 2px 4px rgba(0,0,0,0.9),
                            0 0 ${isCritical ? '10px' : '5px'} ${isCritical ? '#ffff00' : '#ff6b6b'};
                        pointer-events: none;
                        transform: translateX(-50%);
                    `;
                }
                
                // MISSæ•ˆæœæ—¶è·³è¿‡æš´å‡»ã€è¿å‡»å’Œä¼¤å®³åŠ¨ç”»
                if (!isMiss) {
                    if (isCritical) {
                        damagePopup.style.animation = 'criticalDamage 1.5s ease-out forwards';
                        
                        // æš´å‡»æ–‡å­—
                        const critText = document.createElement('div');
                        critText.textContent = 'ğŸ’¥æš´å‡»ï¼';
                        critText.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 10%;
                            transform: translateX(-50%);
                            z-index: 26;
                            font-size: 16px;
                            font-weight: bold;
                            color: #ffff00;
                            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 10px #ff0000;
                            pointer-events: none;
                            animation: comboEffect 1.2s ease-out forwards;
                        `;
                        targetHex.appendChild(critText);
                        setTimeout(() => { if (critText.parentNode) critText.remove(); }, 1200);
                    } else {
                        damagePopup.style.animation = 'damageFloat 2s ease-out forwards';
                    }
                    
                    // è¿å‡»è®¡æ•°
                    if (comboCount > 1) {
                        const comboText = document.createElement('div');
                        comboText.textContent = `${comboCount} HIT COMBO!`;
                        comboText.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 60%;
                            transform: translateX(-50%);
                            z-index: 26;
                            font-size: 14px;
                            font-weight: bold;
                            color: #ffa500;
                            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
                            pointer-events: none;
                            animation: comboEffect 1.5s ease-out forwards;
                        `;
                        targetHex.appendChild(comboText);
                        setTimeout(() => { if (comboText.parentNode) comboText.remove(); }, 1500);
                    }
                    
                    // çˆ†ç‚¸æ•ˆæœ
                    const explosion = document.createElement('div');
                    explosion.className = 'explosion-effect';
                    explosion.textContent = attackType === 'melee' ? 'âš”ï¸' : 'ğŸ’¥';
                    explosion.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 24;
                        font-size: ${isCritical ? '40px' : '30px'};
                        pointer-events: none;
                    `;
                    
                    // å…‰èŠ’çˆ†å‘æ•ˆæœï¼ˆæš´å‡»ä¸“å±ï¼‰
                    if (isCritical) {
                        const burst = document.createElement('div');
                        burst.style.cssText = `
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            width: 50px;
                            height: 50px;
                            background: radial-gradient(circle, 
                                rgba(255, 255, 0, 0.8) 0%, 
                                rgba(255, 150, 0, 0.6) 30%, 
                                rgba(255, 0, 0, 0.3) 60%, 
                                transparent 100%);
                            border-radius: 50%;
                            z-index: 23;
                            pointer-events: none;
                            animation: radialBurst 0.8s ease-out forwards;
                        `;
                        targetHex.appendChild(burst);
                        setTimeout(() => { if (burst.parentNode) burst.remove(); }, 800);
                    }

                    targetHex.appendChild(explosion);

                    // å¯åŠ¨çˆ†ç‚¸åŠ¨ç”»
                    setTimeout(() => {
                        explosion.style.animation = 'explosion 1s ease-out forwards';
                    }, 10);

                    // éœ‡åŠ¨å’Œé—ªçº¢æ•ˆæœ
                    this.showHitReaction(x, y);
                } else {
                    // MISSæ•ˆæœï¼šæ˜¾ç¤ºçƒŸé›¾/ç°å°˜æ•ˆæœ
                    const missEffect = document.createElement('div');
                    missEffect.textContent = 'ğŸ’¨';
                    missEffect.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        z-index: 24;
                        font-size: 24px;
                        pointer-events: none;
                        opacity: 0.7;
                        animation: missEffect 1.2s ease-out forwards;
                    `;
                    targetHex.appendChild(missEffect);
                    setTimeout(() => { if (missEffect.parentNode) missEffect.remove(); }, 1200);
                }

                targetHex.appendChild(damagePopup);
                
                // æ¸…ç†ç‰¹æ•ˆ
                setTimeout(() => {
                    if (damagePopup.parentNode) damagePopup.remove();
                    if (explosion.parentNode) explosion.remove();
                }, isCritical ? 1500 : 2100);
            }

            // å—å‡»ååº”åŠ¨ç”»
            showHitReaction(x, y) {
                const targetHex = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                if (!targetHex) return;
                
                // æ ¼å­éœ‡åŠ¨
                targetHex.style.animation = 'shake 0.5s ease-in-out';
                
                // å•ä½é—ªçº¢
                const unitElements = document.querySelectorAll(`[data-x="${x}"][data-y="${y}"] .unit-large`);
                unitElements.forEach(elem => {
                    elem.style.animation = 'hitFlash 0.6s ease-in-out';
                });
                
                // é‡ç½®åŠ¨ç”»
                setTimeout(() => {
                    targetHex.style.animation = '';
                    unitElements.forEach(elem => {
                        elem.style.animation = '';
                    });
                }, 600);
            }

            canMoveTo(unit, x, y) {
                if (!this.isValidPosition(x, y)) return false;
                
                const size = this.unitSizes[unit.type];
                
                // æ£€æŸ¥ç›®æ ‡åŒºåŸŸæ˜¯å¦éƒ½åœ¨è¾¹ç•Œå†…
                if (x + size.width > this.gridWidth || y + size.height > this.gridHeight) {
                    return false;
                }
                
                // æ£€æŸ¥ç›®æ ‡åŒºåŸŸæ˜¯å¦è¢«å…¶ä»–å•ä½å ç”¨
                if (this.isAreaOccupied(x, y, size.width, size.height, unit.id)) {
                    return false;
                }
                
                const distance = this.getDistance(unit.x, unit.y, x, y);
                return distance <= unit.movement;
            }

            isAreaOccupied(x, y, width, height, excludeUnitId = null) {
                for (let checkY = y; checkY < y + height; checkY++) {
                    for (let checkX = x; checkX < x + width; checkX++) {
                        const occupyingUnit = this.findUnitAtPosition(checkX, checkY);
                        if (occupyingUnit && occupyingUnit.id !== excludeUnitId) {
                            return true;
                        }
                    }
                }
                return false;
            }

            getDistance(x1, y1, x2, y2) {
                // æ­£æ–¹å½¢ç½‘æ ¼è·ç¦»è®¡ç®—ï¼ˆæ›¼å“ˆé¡¿è·ç¦»æˆ–åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼‰
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                
                // ä½¿ç”¨åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼ˆå…è®¸å¯¹è§’çº¿ç§»åŠ¨ï¼‰
                return Math.max(dx, dy);
            }

            getAttackBonus(attacker, defender) {
                // è®¡ç®—æ”»å‡»æ–¹å‘åŠ æˆ
                const dx = defender.x - attacker.x;
                const dy = defender.y - attacker.y;
                
                // ç¡®å®šæ”»å‡»æ–¹å‘
                let attackDirection = 'front';
                if (dx === 0 && dy === -1) attackDirection = 'north';
                else if (dx === 1 && dy === 0) attackDirection = 'east';
                else if (dx === 0 && dy === 1) attackDirection = 'south';
                else if (dx === -1 && dy === 0) attackDirection = 'west';
                
                // è®¡ç®—ç›¸å¯¹æ”»å‡»æ–¹å‘
                const relative = this.getRelativeDirection(attacker.direction, attackDirection);
                const defenseRelative = this.getRelativeDirection(defender.direction, attackDirection);
                
                let bonus = 0;
                
                // æ”»å‡»è€…ä»æ­£é¢æ”»å‡» +10%
                if (relative === 'front') bonus += 0.1;
                
                // æ”»å‡»é˜²å¾¡è€…çš„ä¾§é¢ +20%
                if (defenseRelative === 'side') bonus += 0.2;
                
                // æ”»å‡»é˜²å¾¡è€…çš„èƒŒé¢ +50%
                if (defenseRelative === 'back') bonus += 0.5;
                
                // å°†é¢†çš„é¢†å¯¼åŠ æˆ
                if (attacker.leadership) {
                    bonus += attacker.leadership * 0.05; // æ¯ç‚¹é¢†å¯¼åŠ›+5%æ”»å‡»
                }
                
                return bonus;
            }

            getRelativeDirection(unitDirection, attackDirection) {
                const directionMap = {
                    'north': { front: 'north', back: 'south', left: 'west', right: 'east' },
                    'south': { front: 'south', back: 'north', left: 'east', right: 'west' },
                    'east': { front: 'east', back: 'west', left: 'north', right: 'south' },
                    'west': { front: 'west', back: 'east', left: 'south', right: 'north' }
                };
                
                const directions = directionMap[unitDirection];
                if (attackDirection === directions.front) return 'front';
                if (attackDirection === directions.back) return 'back';
                return 'side';
            }



            canAttack(attacker, defender) {
                const distance = this.getDistance(attacker.x, attacker.y, defender.x, defender.y);
                return distance <= 1 && attacker.faction !== defender.faction;
            }

            // æ£€æŸ¥å°„å‡»è·¯å¾„ä¸Šæ˜¯å¦æœ‰å•ä½é˜»æŒ¡
            hasLineOfSight(attacker, defender) {
                // è®¡ç®—æ”»å‡»è€…å’Œé˜²å®ˆè€…çš„ä¸­å¿ƒä½ç½®
                const attackerSize = this.getUnitSizeWithDirection(attacker);
                const defenderSize = this.getUnitSizeWithDirection(defender);
                
                const attackerCenterX = attacker.x + Math.floor(attackerSize.width / 2);
                const attackerCenterY = attacker.y + Math.floor(attackerSize.height / 2);
                const defenderCenterX = defender.x + Math.floor(defenderSize.width / 2);
                const defenderCenterY = defender.y + Math.floor(defenderSize.height / 2);
                
                // ä½¿ç”¨å¸ƒé›·æ£®æ±‰å§†ç›´çº¿ç®—æ³•è·å–è·¯å¾„ä¸Šçš„æ‰€æœ‰æ ¼å­
                const pathCells = this.getLinePath(attackerCenterX, attackerCenterY, defenderCenterX, defenderCenterY);
                
                // æ£€æŸ¥è·¯å¾„ä¸Šæ˜¯å¦æœ‰å…¶ä»–å•ä½ï¼ˆæ’é™¤æ”»å‡»è€…å’Œé˜²å®ˆè€…è‡ªå·±ï¼‰
                for (let i = 1; i < pathCells.length - 1; i++) {
                    const cell = pathCells[i];
                    const unitAtCell = this.findUnitAtPosition(cell.x, cell.y);
                    
                    if (unitAtCell && unitAtCell.id !== attacker.id && unitAtCell.id !== defender.id) {
                        console.log(`å°„å‡»è·¯å¾„è¢«é˜»æŒ¡: (${cell.x}, ${cell.y}) ä½ç½®æœ‰å•ä½ ${unitAtCell.name}`);
                        return false; // è·¯å¾„è¢«é˜»æŒ¡
                    }
                }
                
                return true; // è§†çº¿ç•…é€š
            }
            
            // ä½¿ç”¨å¸ƒé›·æ£®æ±‰å§†ç›´çº¿ç®—æ³•è·å–ä¸¤ç‚¹ä¹‹é—´çš„è·¯å¾„
            getLinePath(x0, y0, x1, y1) {
                const path = [];
                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = x0 < x1 ? 1 : -1;
                const sy = y0 < y1 ? 1 : -1;
                let err = dx - dy;
                
                let x = x0;
                let y = y0;
                
                while (true) {
                    path.push({ x, y });
                    
                    if (x === x1 && y === y1) break;
                    
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                }
                
                return path;
            }

            canAttackInCurrentPhase(attacker, defender) {
                const distance = this.getDistance(attacker.x, attacker.y, defender.x, defender.y);
                
                if (this.currentPhase === 'ranged') {
                    // è¿œç¨‹å°„å‡»é˜¶æ®µï¼šé€‰æ‹©æœ¬é˜µè¥ã€æœªå¤„äºè¿‘æˆ˜ã€æŠ•æ·æˆ–å°„å‡»å±æ€§å¤§äº0çš„å•ä½
                    // æ”»å‡»å°„ç¨‹èŒƒå›´å†…ã€ä¸”æœªè¿›å…¥è¿‘æˆ˜çš„æ•Œæ–¹å•ä½
                    const basicCheck = attacker.combatStatus !== 'engaged' && // æ”»å‡»è€…æœªå¤„äºè¿‘æˆ˜
                           (attacker.rangedAttack > 0 || attacker.throwingAttack > 0) && // æœ‰è¿œç¨‹æ”»å‡»èƒ½åŠ›
                           distance <= attacker.range && // åœ¨å°„ç¨‹å†…
                           defender.combatStatus !== 'engaged' && // ç›®æ ‡æœªè¿›å…¥è¿‘æˆ˜
                           attacker.faction !== defender.faction; // æ•Œæ–¹å•ä½
                    
                    // å¦‚æœåŸºæœ¬æ£€æŸ¥é€šè¿‡ï¼Œå†æ£€æŸ¥è§†çº¿
                    if (basicCheck) {
                        const lineOfSight = this.hasLineOfSight(attacker, defender);
                        
                        // è°ƒè¯•ä¿¡æ¯
                        console.log(`å°„å‡»æ£€æŸ¥: æ”»å‡»è€…(${attacker.x},${attacker.y}) -> ç›®æ ‡(${defender.x},${defender.y})`);
                        console.log(`è·ç¦»: ${distance}, å°„ç¨‹: ${attacker.range}`);
                        console.log(`æ”»å‡»è€…çŠ¶æ€: ${attacker.combatStatus}, ç›®æ ‡çŠ¶æ€: ${defender.combatStatus}`);
                        console.log(`æ”»å‡»èƒ½åŠ›: å°„å‡»${attacker.rangedAttack}, æŠ•æ·${attacker.throwingAttack}`);
                        console.log(`è§†çº¿ç•…é€š: ${lineOfSight}`);
                        
                        return lineOfSight;
                    }
                    
                    return false;
                } else if (this.currentPhase === 'melee') {
                    // è¿‘æˆ˜æ”»å‡»é˜¶æ®µï¼šåªèƒ½è¿›è¡Œè¿‘æˆ˜æ”»å‡»
                    return distance <= 1 && attacker.faction !== defender.faction;
                }
                
                return false; // ç§»åŠ¨é˜¶æ®µå’Œè½¬å‘é˜¶æ®µä¸å…è®¸æ”»å‡»
            }

            updateUnitDisplay(unit) {
                const unitElement = document.querySelector(`[data-unit-id="${unit.id}"]`);
                if (unitElement && unit.hp > 0) {
                    // æ›´æ–°tooltip
                    const hpPercentage = (unit.hp / unit.maxHp) * 100;
                    const moraleText = unit.morale === 'good' ? 'è‰¯å¥½' : 'åŠ¨æ‘‡';
                    const orderText = unit.order === 'good' ? 'è‰¯å¥½' : 'æ··ä¹±';
                    const combatText = unit.combatStatus === 'engaged' ? 'è¿‘æˆ˜ä¸­' : unit.combatStatus === 'supporting' ? 'æ”¯æ´ä¸­' : 'æœªè¿‘æˆ˜';
                    const directionText = {
                        'north': 'åŒ—â†‘',
                        'east': 'ä¸œâ†’', 
                        'south': 'å—â†“',
                        'west': 'è¥¿â†'
                    }[unit.direction] || unit.direction;
                    const directionIcon = {
                        'north': 'â¬†ï¸',
                        'east': 'â¡ï¸', 
                        'south': 'â¬‡ï¸',
                        'west': 'â¬…ï¸'
                    }[unit.direction] || 'ğŸ§­';
                    
                    unitElement.title = `${unit.name} (${unit.faction === 'rome' ? 'ç½—é©¬' : 'è¿¦å¤ªåŸº'}) | ğŸ’åˆ†å€¼: ${unit.value || 0}
HP: ${unit.hp}/${unit.maxHp} | æœå‘: ${directionIcon}${directionText} | ä½ç½®: (${unit.x}, ${unit.y})
å£«æ°”: ${moraleText} | ç§©åº: ${orderText} | æˆ˜æ–—çŠ¶æ€: ${combatText}
å†²é”‹è¿‘æˆ˜: ${unit.chargeAttack} | æŒç»­è¿‘æˆ˜: ${unit.sustainedMelee} | æ”¯æ´è¿‘æˆ˜: ${unit.supportMelee}
æŠ•æ·æ”»å‡»: ${unit.throwingAttack} | å°„å‡»æ”»å‡»: ${unit.rangedAttack} | é˜²å¾¡èƒ½åŠ›: ${unit.defense}
ä¼¤äº¡æ‰¿å—åŠ›: ${unit.casualtyTolerance} | å°„ç¨‹: ${unit.range} | ç§»åŠ¨: ${unit.movement}
ç‰¹æ®ŠæŠ€èƒ½: ${unit.specialSkills.join(', ')}${unit.leadership > 0 ? `\né¢†å¯¼åŠ›: ${unit.leadership}` : ''}
è¡ŒåŠ¨çŠ¶æ€: ç§»åŠ¨${unit.hasMoved ? 'âœ…' : 'â­•'} | å°„å‡»${unit.hasRangedAttacked ? 'âœ…' : 'â­•'} | è¿‘æˆ˜${unit.hasMeleeAttacked ? 'âœ…' : 'â­•'}`;

                    // æ›´æ–°æˆ–æ·»åŠ HPæ¡
                    const existingHpBar = unitElement.querySelector('.hp-bar');
                    if (existingHpBar) {
                        existingHpBar.remove();
                    }
                    
                    if (unit.hp < unit.maxHp) {
                        let hpColor = '#2ecc71';
                        if (hpPercentage < 70) hpColor = '#f39c12';
                        if (hpPercentage < 40) hpColor = '#e74c3c';
                        
                        const hpBar = document.createElement('div');
                        hpBar.className = 'hp-bar';
                        hpBar.style.cssText = `
                            position: absolute;
                            bottom: -6px;
                            left: 50%;
                            transform: translateX(-50%);
                            width: 35px;
                            height: 3px;
                            background: rgba(0,0,0,0.6);
                            border-radius: 2px;
                            overflow: hidden;
                        `;
                        
                        const hpFill = document.createElement('div');
                        hpFill.style.cssText = `
                            width: ${hpPercentage}%;
                            height: 100%;
                            background: ${hpColor};
                            transition: all 0.3s ease;
                        `;
                        
                        hpBar.appendChild(hpFill);
                        unitElement.appendChild(hpBar);
                    }
                }
            }

            removeUnit(unit) {
                this.units = this.units.filter(u => u.id !== unit.id);
            }
            
            toggleUnitInfo() {
                this.showUnitInfo = !this.showUnitInfo;
                const btn = document.getElementById('toggle-unit-info-btn');
                if (this.showUnitInfo) {
                    btn.textContent = 'ğŸ‘ï¸ éšè—å•ä½ä¿¡æ¯';
                    btn.style.background = 'linear-gradient(135deg, #16a085, #1abc9c)';
                    this.addGameLog('ğŸ‘ï¸ æ˜¾ç¤ºå•ä½åç§°å’ŒHPå€¼');
                } else {
                    btn.textContent = 'ğŸ‘ï¸ æ˜¾ç¤ºå•ä½ä¿¡æ¯';
                    btn.style.background = 'linear-gradient(135deg, #95a5a6, #7f8c8d)';
                    this.addGameLog('ğŸ‘ï¸ éšè—å•ä½åç§°å’ŒHPå€¼');
                }
                this.renderBoard();
                this.updateUI();
            }
            
            getUnitIcon(unit) {
                // æ ¹æ®å•ä½ç±»å‹å’Œé˜µè¥é€‰æ‹©å›¾ç‰‡æˆ–emoji
                const unitType = unit.type;
                const faction = unit.faction;
                
                // ç½—é©¬å•ä½ä½¿ç”¨å›¾ç‰‡
                if (faction === 'rome') {
                if (unitType === 'legionary') {
                        return '<img src="static/footman.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="æ­¥å…µ">';
                    }
                    if (unitType === 'centurion') {
                        return '<img src="static/footman2.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="ç™¾å¤«é•¿">';
                    }
                    if (unitType === 'hastati') {
                        return '<img src="static/footman2.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="åå¤‡å…µ">';
                    }
                    if (unitType === 'cavalry') {
                        return '<img src="static/cav_roma.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="ç½—é©¬éª‘å…µ">';
                    }
                    if (unitType === 'archer') {
                        return '<img src="static/archer_roma.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="å¼“ç®­æ‰‹">';
                    }
                    if (unitType === 'general') {
                        return '<img src="static/leader_roma.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="å°†é¢†">';
                    }
                }
                
                // è¿¦å¤ªåŸºå•ä½
                if (faction === 'carthage') {
                    if (unitType === 'cavalry') {
                        return '<img src="static/cav_carthage.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="è¿¦å¤ªåŸºéª‘å…µ">';
                    }
                    if (unitType === 'archer') {
                        return '<img src="static/archer_carthage.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="è¿¦å¤ªåŸºå¼“ç®­æ‰‹">';
                    }
                    if (unitType === 'general') {
                        return '<img src="static/leader_carthagepng.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="è¿¦å¤ªåŸºå°†é¢†">';
                    }
                    if (unitType === 'infantry') {
                        return '<img src="static/footman3.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="è¿¦å¤ªåŸºæ­¥å…µ">';
                    }
                    if (unitType === 'elephant') {
                        return '<img src="static/elp_carthage.png" style="width: 100%; height: 100%; object-fit: contain; object-position: center;" alt="è¿¦å¤ªåŸºæˆ˜è±¡">';
                    }
                }
                
                // å…¶ä»–å•ä½ä½¿ç”¨emoji
                const typeMap = {
                    'infantry': 'ğŸ—¡ï¸',
                    'elephant': 'ğŸ˜',
                    'archer': 'ğŸ¹',
                    'general': 'ğŸ‘‘',
                    'cavalry': 'ğŸ'
                };
                
                return typeMap[unitType] || '?';
            }
            
            getDirectionArrow(direction) {
                const directionArrows = {
                    'north': 'â†‘',
                    'south': 'â†“',
                    'east': 'â†’',
                    'west': 'â†'
                };
                
                return directionArrows[direction] || '?';
            }

            // æ ¹æ®å•ä½æœå‘è·å–å®é™…å ä½å°ºå¯¸
            getUnitSizeWithDirection(unit) {
                const baseSize = this.unitBaseSizes[unit.type];
                
                // å¯¹äºéæ­£æ–¹å½¢å•ä½ï¼Œæœå‘ä¼šå½±å“å ä½
                if (baseSize.width !== baseSize.height) {
                    if (unit.direction === 'east' || unit.direction === 'west') {
                        // ä¸œè¥¿æœå‘æ—¶ï¼Œå®½é«˜äº’æ¢
                        return { width: baseSize.height, height: baseSize.width };
                    }
                }
                
                // æ­£æ–¹å½¢å•ä½æˆ–å—åŒ—æœå‘ï¼Œä¿æŒåŸå°ºå¯¸
                return { width: baseSize.width, height: baseSize.height };
            }

            nextPhase() {
                // æ£€æŸ¥æ˜¯å¦å…è®¸è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                if (this.currentPhase === 'melee') {
                    // è¿‘æˆ˜é˜¶æ®µéœ€è¦æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æŒç»­è¿‘æˆ˜å¾…å¤„ç†
                    const pendingUnits = this.getAvailableSustainedMeleeUnits();
                    if (pendingUnits.length > 0 && this.meleeSubPhase === 'select_attacker') {
                        this.addGameLog(`âš ï¸ è¿˜æœ‰${pendingUnits.length}ä¸ªå•ä½éœ€è¦è¿›è¡ŒæŒç»­è¿‘æˆ˜ï¼Œæ— æ³•è¿›å…¥ä¸‹ä¸€é˜¶æ®µ`);
                        console.log('[é˜¶æ®µæ§åˆ¶] æŒç»­è¿‘æˆ˜æœªå®Œæˆï¼Œé˜»æ­¢è¿›å…¥ä¸‹ä¸€é˜¶æ®µ');
                        return;
                    }
                }
                
                // å®Œæˆå½“å‰é˜¶æ®µ
                this.phaseCompleted[this.currentPhase] = true;
                
                // åˆ‡æ¢åˆ°ä¸‹ä¸€é˜¶æ®µ
                if (this.currentPhase === 'movement') {
                    this.currentPhase = 'turning';
                    this.addGameLog(`ğŸ”„ ${this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}è¿›å…¥è½¬å‘é˜¶æ®µï¼Œå³é”®ç‚¹å‡»å•ä½è°ƒæ•´æœå‘`);
                } else if (this.currentPhase === 'turning') {
                    this.currentPhase = 'ranged';
                    // æ¸…é™¤å°„å‡»çŠ¶æ€
                    this.rangedAttacker = null;
                    this.rangedTarget = null;
                    this.addGameLog(`ğŸ¹ ${this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}è¿›å…¥è¿œç¨‹å°„å‡»é˜¶æ®µ`);
                    console.log('è¿›å…¥å°„å‡»é˜¶æ®µ');
                } else if (this.currentPhase === 'ranged') {
                    // æ¸…é™¤å°„å‡»çŠ¶æ€
                    this.rangedAttacker = null;
                    this.rangedTarget = null;
                    
                    this.currentPhase = 'melee';
                    this.meleeSubPhase = 'select_attacker';
                    this.resetChargeState();
                    this.addGameLog(`âš”ï¸ ${this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}è¿›å…¥è¿‘æˆ˜æ”»å‡»é˜¶æ®µ`);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æŒç»­è¿‘æˆ˜å•ä½ï¼Œå¦‚æœæœ‰åˆ™è‡ªåŠ¨å¼€å§‹
                    setTimeout(() => {
                        const hasAutoStarted = this.autoStartNextSustainedMelee();
                        if (!hasAutoStarted) {
                            // æ²¡æœ‰æŒç»­è¿‘æˆ˜ï¼Œæ˜¾ç¤ºå¸¸è§„å†²é”‹æç¤º
                            this.addGameLog(`ğŸ’¡ é€‰æ‹©ä¸€ä¸ªä¸æ•Œæ–¹æ¥è§¦çš„å•ä½å‘èµ·å†²é”‹`);
                        }
                    }, 300);
                } else if (this.currentPhase === 'melee') {
                    // å®Œæˆæ‰€æœ‰é˜¶æ®µï¼Œç»“æŸå›åˆ
                    this.endTurn();
                    return;
                }
                
                // é‡ç½®ç§»åŠ¨çŠ¶æ€
                this.resetMoveState();
                this.updateUI();
            }

            endTurn() {
                // æ£€æŸ¥æ˜¯å¦å…è®¸ç»“æŸå›åˆ
                if (this.currentPhase !== 'melee') {
                    this.addGameLog(`âš ï¸ åªèƒ½åœ¨è¿‘æˆ˜é˜¶æ®µç»“æŸå›åˆ`);
                    console.log('[é˜¶æ®µæ§åˆ¶] éè¿‘æˆ˜é˜¶æ®µï¼Œé˜»æ­¢ç»“æŸå›åˆ');
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æŒç»­è¿‘æˆ˜å¾…å¤„ç†
                const pendingUnits = this.getAvailableSustainedMeleeUnits();
                if (pendingUnits.length > 0 && this.meleeSubPhase === 'select_attacker') {
                    this.addGameLog(`âš ï¸ è¿˜æœ‰${pendingUnits.length}ä¸ªå•ä½éœ€è¦è¿›è¡ŒæŒç»­è¿‘æˆ˜ï¼Œæ— æ³•ç»“æŸå›åˆ`);
                    console.log('[é˜¶æ®µæ§åˆ¶] æŒç»­è¿‘æˆ˜æœªå®Œæˆï¼Œé˜»æ­¢ç»“æŸå›åˆ');
                    return;
                }
                
                // é‡ç½®ç§»åŠ¨çŠ¶æ€å’Œæ‰€æœ‰è§„åˆ’
                this.resetAllPlans();
                this.resetChargeState();
                
                // é‡ç½®é˜¶æ®µçŠ¶æ€
                this.phaseCompleted = { movement: false, turning: false, ranged: false, melee: false };
                this.currentPhase = 'movement';
                
                // é‡ç½®æ‰€æœ‰å½“å‰ç©å®¶å•ä½çš„è¡ŒåŠ¨çŠ¶æ€
                this.units.forEach(unit => {
                    if (unit.faction === this.currentPlayer) {
                        unit.hasMoved = false;
                        unit.hasRangedAttacked = false;
                        unit.hasMeleeAttacked = false;
                    }
                    // é‡ç½®æ‰€æœ‰å•ä½çš„è¿‘æˆ˜çŠ¶æ€
                    if (unit.combatStatus === 'supporting') {
                        unit.combatStatus = 'not_engaged';
                        this.updateUnitDisplay(unit); // æ›´æ–°æ˜¾ç¤º
                    }
                });

                // åˆ‡æ¢ç©å®¶
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 'rome' ? 'carthage' : 'rome';
                
                const prevPlayerName = previousPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                const currentPlayerName = this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                this.addGameLog(`ğŸ”„ ${prevPlayerName}å›åˆç»“æŸï¼Œè½®åˆ°${currentPlayerName}è¡ŒåŠ¨`);
                
                // åœ¨ç§»åŠ¨é˜¶æ®µå¼€å§‹å‰ï¼Œå¯¹æ··ä¹±å•ä½è¿›è¡Œæ¢å¤æµ‹è¯•
                this.performRallyTests();
                
                this.addGameLog(`ğŸš¶ ${currentPlayerName}å¼€å§‹è§„åˆ’å’Œç§»åŠ¨é˜¶æ®µ`);
                
                this.renderBoard();
                this.updateUI();
            }

            resetGame() {
                this.resetMoveState();
                this.currentPlayer = 'rome';
                this.currentPhase = 'deployment';
                this.deploymentPhase = 'rome';
                this.phaseCompleted = { movement: false, turning: false, ranged: false, melee: false };
                this.isDragging = false;
                this.draggedUnit = null;
                this.dragOffset = { x: 0, y: 0 };
                this.lastClickTime = 0;
                this.lastClickedUnit = null;
                this.generalDeathTestDone = { rome: false, carthage: false }; // é‡ç½®å°†é¢†é˜µäº¡æµ‹è¯•æ ‡å¿—
                this.units = [];
                this.gameBoard = [];
                this.initializeGame();
                this.addGameLog(`ğŸ“¦ æ¸¸æˆå¼€å§‹ï¼ŒğŸ›ï¸ ç½—é©¬å…ˆè¿›è¡Œéƒ¨ç½²`);
            }

            saveGame() {
                try {
                    // åˆ›å»ºæ¸¸æˆçŠ¶æ€å¯¹è±¡
                    const gameState = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        currentPlayer: this.currentPlayer,
                        currentPhase: this.currentPhase,
                        deploymentPhase: this.deploymentPhase,
                        meleeSubPhase: this.meleeSubPhase,
                        meleeType: this.meleeType,
                        phaseCompleted: this.phaseCompleted,
                        generalDeathTestDone: this.generalDeathTestDone,
                        initialPoints: this.initialPoints,
                        initialRomeValue: this.initialRomeValue,
                        initialCarthageValue: this.initialCarthageValue,
                        units: this.units.map(unit => ({
                            ...unit,
                            // æ·±æ‹·è´æ‰€æœ‰å±æ€§
                        })),
                        allUnitPlans: Array.from(this.allUnitPlans.entries()).map(([id, plan]) => ({
                            id: id,
                            plan: plan
                        })),
                        moveState: this.moveState,
                        planningPhase: this.planningPhase
                    };

                    // ä¿å­˜åˆ°localStorage
                    localStorage.setItem('battleGameSave', JSON.stringify(gameState));
                    
                    // æ˜¾ç¤ºä¿å­˜æˆåŠŸæ¶ˆæ¯
                    this.addGameLog(`ğŸ’¾ æ¸¸æˆå·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨ (${new Date().toLocaleString('zh-CN')})`);
                    
                    // æ˜¾ç¤ºä¸´æ—¶æç¤º
                    this.showTempMessage('âœ… æ¸¸æˆä¿å­˜æˆåŠŸï¼', 'success');
                } catch (error) {
                    console.error('ä¿å­˜æ¸¸æˆå¤±è´¥:', error);
                    this.addGameLog(`âŒ ä¿å­˜æ¸¸æˆå¤±è´¥: ${error.message}`);
                    this.showTempMessage('âŒ ä¿å­˜æ¸¸æˆå¤±è´¥ï¼', 'error');
                }
            }

            loadGame() {
                try {
                    // ä»localStorageè¯»å–
                    const savedData = localStorage.getItem('battleGameSave');
                    
                    if (!savedData) {
                        this.addGameLog(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„æ¸¸æˆæ•°æ®`);
                        this.showTempMessage('âš ï¸ æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„æ¸¸æˆï¼', 'warning');
                        return;
                    }

                    const gameState = JSON.parse(savedData);
                    
                    // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                    const saveTime = new Date(gameState.timestamp).toLocaleString('zh-CN');
                    if (!confirm(`ç¡®å®šè¦è½½å…¥ä¿å­˜çš„æ¸¸æˆå—ï¼Ÿ\n\nä¿å­˜æ—¶é—´: ${saveTime}\nå½“å‰è¿›åº¦å°†ä¼šä¸¢å¤±ï¼`)) {
                        return;
                    }

                    // æ¢å¤æ¸¸æˆçŠ¶æ€
                    this.currentPlayer = gameState.currentPlayer;
                    this.currentPhase = gameState.currentPhase;
                    this.deploymentPhase = gameState.deploymentPhase;
                    this.meleeSubPhase = gameState.meleeSubPhase || 'select_attacker';
                    this.meleeType = gameState.meleeType || null;
                    this.phaseCompleted = gameState.phaseCompleted;
                    this.generalDeathTestDone = gameState.generalDeathTestDone || { rome: false, carthage: false };
                    this.initialPoints = gameState.initialPoints;
                    this.initialRomeValue = gameState.initialRomeValue;
                    this.initialCarthageValue = gameState.initialCarthageValue;
                    this.units = gameState.units;
                    this.moveState = gameState.moveState || 'none';
                    this.planningPhase = gameState.planningPhase || 'planning';
                    
                    // æ¢å¤å•ä½è§„åˆ’
                    this.allUnitPlans.clear();
                    if (gameState.allUnitPlans) {
                        gameState.allUnitPlans.forEach(item => {
                            this.allUnitPlans.set(item.id, item.plan);
                        });
                    }

                    // é‡ç½®ä¸´æ—¶çŠ¶æ€
                    this.selectedUnit = null;
                    this.targetPosition = null;
                    this.movePlan = [];
                    this.currentPlanStep = 0;
                    this.meleeAttacker = null;
                    this.meleeTarget = null;
                    this.attackerSupports = [];
                    this.defenderSupports = [];
                    this.lastClickTime = 0;
                    this.lastClickedUnit = null;
                    this.isDragging = false;
                    this.draggedUnit = null;
                    this.dragOffset = { x: 0, y: 0 };

                    // é‡æ–°æ¸²æŸ“æ¸¸æˆ
                    this.renderBoard();
                    this.updateUI();
                    
                    this.addGameLog(`ğŸ“‚ æ¸¸æˆå·²ä»æœ¬åœ°å­˜å‚¨è½½å…¥ (ä¿å­˜äº ${saveTime})`);
                    this.showTempMessage('âœ… æ¸¸æˆè½½å…¥æˆåŠŸï¼', 'success');
                } catch (error) {
                    console.error('è½½å…¥æ¸¸æˆå¤±è´¥:', error);
                    this.addGameLog(`âŒ è½½å…¥æ¸¸æˆå¤±è´¥: ${error.message}`);
                    this.showTempMessage('âŒ è½½å…¥æ¸¸æˆå¤±è´¥ï¼', 'error');
                }
            }

            showTempMessage(message, type = 'info') {
                // åˆ›å»ºä¸´æ—¶æ¶ˆæ¯å…ƒç´ 
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 20px 40px;
                    font-size: 24px;
                    font-weight: bold;
                    color: white;
                    background: ${type === 'success' ? 'linear-gradient(135deg, #27ae60, #229954)' : 
                                 type === 'error' ? 'linear-gradient(135deg, #e74c3c, #c0392b)' : 
                                 'linear-gradient(135deg, #f39c12, #e67e22)'};
                    border-radius: 15px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                    z-index: 10001;
                    animation: fadeInOut 2s ease-in-out;
                `;
                
                document.body.appendChild(messageDiv);
                
                // 2ç§’åè‡ªåŠ¨ç§»é™¤
                setTimeout(() => {
                    messageDiv.remove();
                }, 2000);
            }

            clearHighlights() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'possible-move', 'target-selected');
                });
                
                // æ¸…é™¤å•ä½çš„ç‰¹æ®Šé«˜äº®æ•ˆæœ
                document.querySelectorAll('.unit-large').forEach(unit => {
                    unit.classList.remove('selected');
                    unit.style.boxShadow = '';
                });
            }

            drawMovePath() {
                // ä¸æ¸…é™¤æ‰€æœ‰è·¯å¾„ï¼Œåªç»˜åˆ¶å½“å‰è§„åˆ’çš„è·¯å¾„
                if (this.movePlan.length === 0) return;
                
                // å…ˆç§»é™¤å½“å‰å•ä½çš„æ—§è·¯å¾„
                if (this.selectedUnit) {
                    const container = document.getElementById('square-grid');
                    container.querySelectorAll(`[data-unit-id="${this.selectedUnit.id}"]`).forEach(el => el.remove());
                }
                
                const container = document.getElementById('square-grid');
                const squareSize = 16;
                
                this.movePlan.forEach((step, index) => {
                    const startCenterX = step.startX * squareSize + squareSize * this.unitSizes[this.selectedUnit.type].width / 2;
                    const startCenterY = step.startY * squareSize + squareSize * this.unitSizes[this.selectedUnit.type].height / 2;
                    const endCenterX = step.endX * squareSize + squareSize * this.unitSizes[this.selectedUnit.type].width / 2;
                    const endCenterY = step.endY * squareSize + squareSize * this.unitSizes[this.selectedUnit.type].height / 2;
                    
                    // è®¡ç®—ç®­å¤´è§’åº¦å’Œé•¿åº¦
                    const dx = endCenterX - startCenterX;
                    const dy = endCenterY - startCenterY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    
                    // å½“å‰è§„åˆ’ä½¿ç”¨é‡‘è‰²ï¼ˆæ›´äº®ï¼‰
                    const arrowColor = 'rgba(241, 196, 15, 1.0)';
                    
                    // åˆ›å»ºç®­å¤´å…ƒç´ 
                    const arrow = document.createElement('div');
                    arrow.className = 'move-arrow';
                    arrow.style.left = startCenterX + 'px';
                    arrow.style.top = startCenterY + 'px';
                    arrow.style.width = length + 'px';
                    arrow.style.transform = `rotate(${angle}deg)`;
                    arrow.style.background = arrowColor;
                    arrow.dataset.unitId = this.selectedUnit.id;
                    arrow.style.setProperty('--arrow-color', arrowColor);
                    
                    container.appendChild(arrow);
                    
                    // åˆ›å»ºæ­¥éª¤ç¼–å·
                    const stepNumber = document.createElement('div');
                    stepNumber.className = 'step-number';
                    stepNumber.textContent = index + 1;
                    stepNumber.style.left = (endCenterX - 8) + 'px';
                    stepNumber.style.top = (endCenterY - 8) + 'px';
                    stepNumber.style.background = '#f39c12'; // å½“å‰è§„åˆ’ç”¨é‡‘è‰²
                    stepNumber.dataset.unitId = this.selectedUnit.id;
                    
                    container.appendChild(stepNumber);
                });
            }

            clearMovePath() {
                const container = document.getElementById('square-grid');
                container.querySelectorAll('.move-arrow, .step-number').forEach(el => el.remove());
            }

            drawAllMovePaths() {
                this.clearMovePath();
                
                const container = document.getElementById('square-grid');
                const squareSize = 16;
                
                // ç»˜åˆ¶æ‰€æœ‰å·²è§„åˆ’å•ä½çš„è·¯å¾„
                this.allUnitPlans.forEach((planData, unitId) => {
                    const unit = planData.unit;
                    const plan = planData.plan;
                    
                    plan.forEach((step, index) => {
                        const startCenterX = step.startX * squareSize + squareSize * this.unitSizes[unit.type].width / 2;
                        const startCenterY = step.startY * squareSize + squareSize * this.unitSizes[unit.type].height / 2;
                        const endCenterX = step.endX * squareSize + squareSize * this.unitSizes[unit.type].width / 2;
                        const endCenterY = step.endY * squareSize + squareSize * this.unitSizes[unit.type].height / 2;
                        
                        // è®¡ç®—ç®­å¤´è§’åº¦å’Œé•¿åº¦
                        const dx = endCenterX - startCenterX;
                        const dy = endCenterY - startCenterY;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                        
                        // ä¸ºä¸åŒå•ä½ä½¿ç”¨ä¸åŒé¢œè‰²
                        const arrowColor = unit.faction === 'rome' ? 'rgba(231, 76, 60, 0.8)' : 'rgba(52, 152, 219, 0.8)';
                        
                        // åˆ›å»ºç®­å¤´å…ƒç´ 
                        const arrow = document.createElement('div');
                        arrow.className = 'move-arrow';
                        arrow.style.left = startCenterX + 'px';
                        arrow.style.top = startCenterY + 'px';
                        arrow.style.width = length + 'px';
                        arrow.style.transform = `rotate(${angle}deg)`;
                        arrow.style.background = arrowColor;
                        arrow.dataset.unitId = unitId; // æ ‡è®°æ‰€å±å•ä½
                        
                        // è®¾ç½®ç®­å¤´å¤´éƒ¨é¢œè‰²
                        arrow.style.setProperty('--arrow-color', arrowColor);
                        
                        container.appendChild(arrow);
                        
                        // åˆ›å»ºæ­¥éª¤ç¼–å·
                        const stepNumber = document.createElement('div');
                        stepNumber.className = 'step-number';
                        stepNumber.textContent = index + 1;
                        stepNumber.style.left = (endCenterX - 8) + 'px';
                        stepNumber.style.top = (endCenterY - 8) + 'px';
                        stepNumber.style.background = unit.faction === 'rome' ? '#e74c3c' : '#3498db';
                        stepNumber.dataset.unitId = unitId;
                        
                        container.appendChild(stepNumber);
                    });
                });
                
                // å¦‚æœæœ‰å½“å‰æ­£åœ¨è§„åˆ’çš„å•ä½ï¼Œä¹Ÿç»˜åˆ¶å…¶è·¯å¾„
                if (this.selectedUnit && this.movePlan.length > 0) {
                    this.drawMovePath();
                }
            }

            getNearestGeneralLeadership(unit) {
                let nearestGeneral = null;
                let minDistance = Infinity;
                
                // æŸ¥æ‰¾åŒé˜µè¥æœ€è¿‘çš„å°†é¢†
                this.units.forEach(u => {
                    if (u.type === 'general' && u.faction === unit.faction && u.hp > 0) {
                        const distance = this.getDistance(unit.x, unit.y, u.x, u.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestGeneral = u;
                        }
                    }
                });
                
                // å¦‚æœæ²¡æœ‰å°†é¢†æˆ–å°†é¢†è¢«æ¶ˆç­ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6
                return nearestGeneral ? nearestGeneral.leadership : 6;
            }

            executeMovePlan(stepsToExecute) {
                if (stepsToExecute === 0) {
                    console.log('ç§»åŠ¨å¤±è´¥ï¼Œæ— æ³•æ‰§è¡Œä»»ä½•æ­¥éª¤');
                    this.showExecutionResult('', 'ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œå•ä½æ— æ³•ç§»åŠ¨');
                    this.resetMoveState();
                    this.renderBoard();
                    this.updateUI();
                    return;
                }
                
                const totalSteps = this.movePlan.length;
                let actualStepsExecuted = 0;
                let collisionOccurred = false;
                
                // é€æ­¥æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦ç¢°æ’æ£€æµ‹ï¼‰
                for (let i = 0; i < stepsToExecute; i++) {
                    const step = this.movePlan[i];
                    const size = this.unitSizes[this.selectedUnit.type];
                    
                    // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦è¢«å…¶ä»–å•ä½å ç”¨
                    if (this.isAreaOccupiedByOthers(step.endX, step.endY, size.width, size.height, this.selectedUnit.id)) {
                        const unitTypeName = this.getUnitTypeName(this.selectedUnit.type);
                        const collidingUnit = this.findUnitAtPosition(step.endX, step.endY, this.selectedUnit.id);
                        const collidingUnitName = collidingUnit ? this.getUnitTypeName(collidingUnit.type) : 'å…¶ä»–å•ä½';
                        this.addGameLog(`ğŸš« ${unitTypeName}ç¬¬${i + 1}æ­¥ç§»åŠ¨å—é˜»ï¼Œä¸${collidingUnitName}å‘ç”Ÿç¢°æ’`);
                        
                        // æ˜¾ç¤ºç¢°æ’æ•ˆæœ
                        this.showCollisionEffect(this.selectedUnit, collidingUnit);
                        
                        collisionOccurred = true;
                        break;
                    }
                    
                    // æ‰§è¡Œç§»åŠ¨
                    this.selectedUnit.x = step.endX;
                    this.selectedUnit.y = step.endY;
                    actualStepsExecuted++;
                    console.log(`æ‰§è¡Œç¬¬${i + 1}æ­¥: ç§»åŠ¨åˆ° (${step.endX}, ${step.endY})`);
                }
                
                this.selectedUnit.hasMoved = true;
                
                // æ˜¾ç¤ºæ‰§è¡Œç»“æœ
                let resultText = '';
                if (collisionOccurred) {
                    if (actualStepsExecuted > 0) {
                        resultText = `ç§»åŠ¨éƒ¨åˆ†æˆåŠŸï¼è§„åˆ’${totalSteps}æ­¥ï¼Œå› ç¢°æ’å®é™…æ‰§è¡Œ${actualStepsExecuted}æ­¥`;
                    } else {
                        resultText = `ç§»åŠ¨å¤±è´¥ï¼ç¬¬1æ­¥å°±é‡åˆ°ç¢°æ’ï¼Œæ— æ³•ç§»åŠ¨`;
                    }
                } else if (actualStepsExecuted === totalSteps) {
                    resultText = `ç§»åŠ¨æˆåŠŸï¼æ‰§è¡Œäº†å…¨éƒ¨${totalSteps}æ­¥è§„åˆ’`;
                } else {
                    resultText = `ç§»åŠ¨éƒ¨åˆ†æˆåŠŸï¼è§„åˆ’${totalSteps}æ­¥ï¼Œå®é™…æ‰§è¡Œ${actualStepsExecuted}æ­¥`;
                }
                
                this.showExecutionResult('', resultText);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å•ä½å› ç§»åŠ¨è„±ç¦»è¿‘æˆ˜
                this.checkAndDisengageUnits();
                
                this.resetMoveState();
                this.renderBoard();
                this.updateUI();
            }

            async executeAllPlans() {
                if (this.allUnitPlans.size === 0) {
                    console.log('æ²¡æœ‰å•ä½è§„åˆ’éœ€è¦æ‰§è¡Œ');
                    return;
                }
                
                this.addGameLog(`ğŸ² å¼€å§‹é€ä¸ªæ‰§è¡Œ${this.allUnitPlans.size}ä¸ªå•ä½çš„ç§»åŠ¨è®¡åˆ’ï¼ˆåŒ…å«ç§»åŠ¨åŠ¨ç”»ï¼‰`);
                
                // è½¬æ¢ä¸ºæ•°ç»„ä»¥ä¾¿æŒ‰é¡ºåºæ‰§è¡Œ
                const planEntries = Array.from(this.allUnitPlans.entries());
                
                // æŒ‰å•ä½ç±»å‹åˆ†ç»„ï¼Œç½—é©¬å†›å›¢å…µå’Œåå¤‡å…µä¸ºä¸€ç»„ï¼Œè¿¦å¤ªåŸºæ­¥å…µä¸ºä¸€ç»„ï¼Œå¼“ç®­æ‰‹å„è‡ªä¸ºä¸€ç»„
                const unitGroups = [];
                const romeInfantryGroup = [];
                const carthageInfantryGroup = [];
                const romeArcherGroup = [];
                const carthageArcherGroup = [];
                const otherUnits = [];
                
                for (const [unitId, planData] of planEntries) {
                    const unit = this.units.find(u => u.id === unitId && u.hp > 0);
                    if (!unit) continue;
                    
                    if (unit.faction === 'rome' && (unit.type === 'legionary' || unit.type === 'hastati')) {
                        romeInfantryGroup.push([unitId, planData, unit]);
                    } else if (unit.faction === 'carthage' && unit.type === 'infantry') {
                        carthageInfantryGroup.push([unitId, planData, unit]);
                    } else if (unit.faction === 'rome' && unit.type === 'archer') {
                        romeArcherGroup.push([unitId, planData, unit]);
                    } else if (unit.faction === 'carthage' && unit.type === 'archer') {
                        carthageArcherGroup.push([unitId, planData, unit]);
                    } else {
                        otherUnits.push([unitId, planData, unit]);
                    }
                }
                
                // å¦‚æœæœ‰ç½—é©¬æ­¥å…µå•ä½ï¼Œä½œä¸ºä¸€ç»„å¤„ç†
                if (romeInfantryGroup.length > 0) {
                    unitGroups.push({
                        type: 'rome_infantry',
                        units: romeInfantryGroup
                    });
                }
                
                // å¦‚æœæœ‰è¿¦å¤ªåŸºæ­¥å…µå•ä½ï¼Œä½œä¸ºä¸€ç»„å¤„ç†
                if (carthageInfantryGroup.length > 0) {
                    unitGroups.push({
                        type: 'carthage_infantry',
                        units: carthageInfantryGroup
                    });
                }
                
                // å¦‚æœæœ‰ç½—é©¬å¼“ç®­æ‰‹å•ä½ï¼Œä½œä¸ºä¸€ç»„å¤„ç†
                if (romeArcherGroup.length > 0) {
                    unitGroups.push({
                        type: 'rome_archer',
                        units: romeArcherGroup
                    });
                }
                
                // å¦‚æœæœ‰è¿¦å¤ªåŸºå¼“ç®­æ‰‹å•ä½ï¼Œä½œä¸ºä¸€ç»„å¤„ç†
                if (carthageArcherGroup.length > 0) {
                    unitGroups.push({
                        type: 'carthage_archer',
                        units: carthageArcherGroup
                    });
                }
                
                // å…¶ä»–å•ä½åˆ†åˆ«å¤„ç†
                for (const unitData of otherUnits) {
                    unitGroups.push({
                        type: 'individual',
                        units: [unitData]
                    });
                }
                
                // é€ç»„æ‰§è¡Œ
                for (const group of unitGroups) {
                    if (group.type === 'rome_infantry') {
                        // ç½—é©¬æ­¥å…µç»„ï¼šå…±ç”¨ä¸€æ¬¡æŠ•æ·
                        const dice1 = Math.floor(Math.random() * 6) + 1;
                        const dice2 = Math.floor(Math.random() * 6) + 1;
                        const diceTotal = dice1 + dice2;
                        
                        this.addGameLog(`ğŸ² ç½—é©¬æ­¥å…µå›¢ä½“æŠ•æ·: 2D6=${dice1}+${dice2}=${diceTotal}`);
                        
                        // ä¸ºè¯¥ç»„çš„æ¯ä¸ªå•ä½æ‰§è¡Œç§»åŠ¨
                        for (const [unitId, planData, unit] of group.units) {
                            const plan = planData.plan;
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                            const hasGeneral = this.units.some(u => 
                                u.type === 'general' && 
                                u.faction === unit.faction && 
                                u.hp > 0
                            );
                            
                            // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                            const leadership = this.getNearestGeneralLeadership(unit);
                            const result = diceTotal - leadership;
                            
                            // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                            let stepsToExecute = 0;
                            if (result <= -3) {
                                stepsToExecute = plan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                            } else if (result === -2) {
                                stepsToExecute = Math.min(2, plan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                            } else if (result >= -1 && result <= 1) {
                                stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                            } else if (result >= 2) {
                                stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                            }
                            
                            const unitTypeName = this.getUnitTypeName(unit.type);
                            
                            // è®°å½•ç»“æœ
                            let resultText = `${unit.name}`;
                            if (hasGeneral) {
                                resultText += `: ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                            } else {
                                resultText += `: æ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                            }
                            
                            if (result <= -3) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${plan.length}æ­¥ç§»åŠ¨`;
                            } else if (result === -2) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, plan.length)}æ­¥ç§»åŠ¨`;
                            } else if (result >= -1 && result <= 1) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                            } else if (result >= 2) {
                                resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                            }
                            
                            this.addGameLog(resultText);
                            
                            // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»å’Œç¢°æ’æ£€æµ‹ï¼‰
                            if (stepsToExecute > 0) {
                                await this.executeUnitPlanWithAnimation(unit, plan, stepsToExecute);
                            } else {
                                this.addGameLog(`âŒ ${unit.name}ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œæ— æ³•ç§»åŠ¨`);
                            }
                            
                            // æ¯ä¸ªå•ä½æ‰§è¡Œå®Œåç¨ä½œåœé¡¿
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else if (group.type === 'carthage_infantry') {
                        // è¿¦å¤ªåŸºæ­¥å…µç»„ï¼šå…±ç”¨ä¸€æ¬¡æŠ•æ·
                        const dice1 = Math.floor(Math.random() * 6) + 1;
                        const dice2 = Math.floor(Math.random() * 6) + 1;
                        const diceTotal = dice1 + dice2;
                        
                        this.addGameLog(`ğŸ² è¿¦å¤ªåŸºæ­¥å…µå›¢ä½“æŠ•æ·: 2D6=${dice1}+${dice2}=${diceTotal}`);
                        
                        // ä¸ºè¯¥ç»„çš„æ¯ä¸ªå•ä½æ‰§è¡Œç§»åŠ¨
                        for (const [unitId, planData, unit] of group.units) {
                            const plan = planData.plan;
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                            const hasGeneral = this.units.some(u => 
                                u.type === 'general' && 
                                u.faction === unit.faction && 
                                u.hp > 0
                            );
                            
                            // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                            const leadership = this.getNearestGeneralLeadership(unit);
                            const result = diceTotal - leadership;
                            
                            // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                            let stepsToExecute = 0;
                            if (result <= -3) {
                                stepsToExecute = plan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                            } else if (result === -2) {
                                stepsToExecute = Math.min(2, plan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                            } else if (result >= -1 && result <= 1) {
                                stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                            } else if (result >= 2) {
                                stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                            }
                            
                            const unitTypeName = this.getUnitTypeName(unit.type);
                            
                            // è®°å½•ç»“æœ
                            let resultText = `${unit.name}`;
                            if (hasGeneral) {
                                resultText += `: ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                            } else {
                                resultText += `: æ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                            }
                            
                            if (result <= -3) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${plan.length}æ­¥ç§»åŠ¨`;
                            } else if (result === -2) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, plan.length)}æ­¥ç§»åŠ¨`;
                            } else if (result >= -1 && result <= 1) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                            } else if (result >= 2) {
                                resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                            }
                            
                            this.addGameLog(resultText);
                            
                            // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»å’Œç¢°æ’æ£€æµ‹ï¼‰
                            if (stepsToExecute > 0) {
                                await this.executeUnitPlanWithAnimation(unit, plan, stepsToExecute);
                            } else {
                                this.addGameLog(`âŒ ${unit.name}ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œæ— æ³•ç§»åŠ¨`);
                            }
                            
                            // æ¯ä¸ªå•ä½æ‰§è¡Œå®Œåç¨ä½œåœé¡¿
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else if (group.type === 'rome_archer') {
                        // ç½—é©¬å¼“ç®­æ‰‹ç»„ï¼šå…±ç”¨ä¸€æ¬¡æŠ•æ·
                        const dice1 = Math.floor(Math.random() * 6) + 1;
                        const dice2 = Math.floor(Math.random() * 6) + 1;
                        const diceTotal = dice1 + dice2;
                        
                        this.addGameLog(`ğŸ² ç½—é©¬å¼“ç®­æ‰‹å›¢ä½“æŠ•æ·: 2D6=${dice1}+${dice2}=${diceTotal}`);
                        
                        // ä¸ºè¯¥ç»„çš„æ¯ä¸ªå•ä½æ‰§è¡Œç§»åŠ¨
                        for (const [unitId, planData, unit] of group.units) {
                            const plan = planData.plan;
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                            const hasGeneral = this.units.some(u => 
                                u.type === 'general' && 
                                u.faction === unit.faction && 
                                u.hp > 0
                            );
                            
                            // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                            const leadership = this.getNearestGeneralLeadership(unit);
                            const result = diceTotal - leadership;
                            
                            // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                            let stepsToExecute = 0;
                            if (result <= -3) {
                                stepsToExecute = plan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                            } else if (result === -2) {
                                stepsToExecute = Math.min(2, plan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                            } else if (result >= -1 && result <= 1) {
                                stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                            } else if (result >= 2) {
                                stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                            }
                            
                            const unitTypeName = this.getUnitTypeName(unit.type);
                            
                            // è®°å½•ç»“æœ
                            let resultText = `${unit.name}`;
                            if (hasGeneral) {
                                resultText += `: ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                            } else {
                                resultText += `: æ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                            }
                            
                            if (result <= -3) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${plan.length}æ­¥ç§»åŠ¨`;
                            } else if (result === -2) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, plan.length)}æ­¥ç§»åŠ¨`;
                            } else if (result >= -1 && result <= 1) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                            } else if (result >= 2) {
                                resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                            }
                            
                            this.addGameLog(resultText);
                            
                            // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»å’Œç¢°æ’æ£€æµ‹ï¼‰
                            if (stepsToExecute > 0) {
                                await this.executeUnitPlanWithAnimation(unit, plan, stepsToExecute);
                            } else {
                                this.addGameLog(`âŒ ${unit.name}ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œæ— æ³•ç§»åŠ¨`);
                            }
                            
                            // æ¯ä¸ªå•ä½æ‰§è¡Œå®Œåç¨ä½œåœé¡¿
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else if (group.type === 'carthage_archer') {
                        // è¿¦å¤ªåŸºå¼“ç®­æ‰‹ç»„ï¼šå…±ç”¨ä¸€æ¬¡æŠ•æ·
                        const dice1 = Math.floor(Math.random() * 6) + 1;
                        const dice2 = Math.floor(Math.random() * 6) + 1;
                        const diceTotal = dice1 + dice2;
                        
                        this.addGameLog(`ğŸ² è¿¦å¤ªåŸºå¼“ç®­æ‰‹å›¢ä½“æŠ•æ·: 2D6=${dice1}+${dice2}=${diceTotal}`);
                        
                        // ä¸ºè¯¥ç»„çš„æ¯ä¸ªå•ä½æ‰§è¡Œç§»åŠ¨
                        for (const [unitId, planData, unit] of group.units) {
                            const plan = planData.plan;
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                            const hasGeneral = this.units.some(u => 
                                u.type === 'general' && 
                                u.faction === unit.faction && 
                                u.hp > 0
                            );
                            
                            // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                            const leadership = this.getNearestGeneralLeadership(unit);
                            const result = diceTotal - leadership;
                            
                            // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                            let stepsToExecute = 0;
                            if (result <= -3) {
                                stepsToExecute = plan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                            } else if (result === -2) {
                                stepsToExecute = Math.min(2, plan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                            } else if (result >= -1 && result <= 1) {
                                stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                            } else if (result >= 2) {
                                stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                            }
                            
                            const unitTypeName = this.getUnitTypeName(unit.type);
                            
                            // è®°å½•ç»“æœ
                            let resultText = `${unit.name}`;
                            if (hasGeneral) {
                                resultText += `: ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                            } else {
                                resultText += `: æ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                            }
                            
                            if (result <= -3) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${plan.length}æ­¥ç§»åŠ¨`;
                            } else if (result === -2) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, plan.length)}æ­¥ç§»åŠ¨`;
                            } else if (result >= -1 && result <= 1) {
                                resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                            } else if (result >= 2) {
                                resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                            }
                            
                            this.addGameLog(resultText);
                            
                            // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»å’Œç¢°æ’æ£€æµ‹ï¼‰
                            if (stepsToExecute > 0) {
                                await this.executeUnitPlanWithAnimation(unit, plan, stepsToExecute);
                            } else {
                                this.addGameLog(`âŒ ${unit.name}ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œæ— æ³•ç§»åŠ¨`);
                            }
                            
                            // æ¯ä¸ªå•ä½æ‰§è¡Œå®Œåç¨ä½œåœé¡¿
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    } else {
                        // å•ç‹¬æ‰§è¡Œçš„å•ä½
                        const [unitId, planData, unit] = group.units[0];
                    const plan = planData.plan;
                    
                    // æŠ•æ·2D6
                    const dice1 = Math.floor(Math.random() * 6) + 1;
                    const dice2 = Math.floor(Math.random() * 6) + 1;
                    const diceTotal = dice1 + dice2;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å­˜æ´»çš„å°†é¢†
                    const hasGeneral = this.units.some(u => 
                        u.type === 'general' && 
                        u.faction === unit.faction && 
                        u.hp > 0
                    );
                    
                    // è·å–æœ€è¿‘çš„å°†é¢†é¢†å¯¼åŠ›ï¼ˆæ²¡æœ‰å°†é¢†æ—¶è¿”å›é»˜è®¤å€¼6ï¼‰
                    const leadership = this.getNearestGeneralLeadership(unit);
                    const result = diceTotal - leadership;
                    
                    // æ ¹æ®æ–°è§„åˆ™æ‰§è¡Œç›¸åº”æ­¥æ•°
                    let stepsToExecute = 0;
                    if (result <= -3) {
                        stepsToExecute = plan.length; // æ‰§è¡Œå…¨éƒ¨è§„åˆ’
                    } else if (result === -2) {
                        stepsToExecute = Math.min(2, plan.length); // æ‰§è¡Œå‰ä¸¤æ­¥
                    } else if (result >= -1 && result <= 1) {
                        stepsToExecute = 1; // æ‰§è¡Œç¬¬ä¸€æ­¥
                    } else if (result >= 2) {
                        stepsToExecute = 0; // ä¸æ‰§è¡Œä»»ä½•æ­¥éª¤
                    }
                    
                    const unitTypeName = this.getUnitTypeName(unit.type);
                    
                    // è®°å½•éª°å­ç»“æœ
                        let resultText = `${unit.name}: 2D6æŠ•æ·ç»“æœä¸º${diceTotal}`;
                    if (hasGeneral) {
                        resultText += `ï¼Œ${diceTotal}-å°†é¢†é¢†å¯¼åŠ›${leadership}=${result}`;
                    } else {
                        resultText += `ï¼Œæ— å°†é¢†ï¼Œä½¿ç”¨é»˜è®¤é¢†å¯¼å€¼6ï¼Œ${diceTotal}-6=${result}`;
                    }
                    
                    if (result <= -3) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œå…¨éƒ¨${plan.length}æ­¥ç§»åŠ¨`;
                    } else if (result === -2) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ${Math.min(2, plan.length)}æ­¥ç§»åŠ¨`;
                    } else if (result >= -1 && result <= 1) {
                        resultText += `ï¼Œå¯ä»¥æ‰§è¡Œ1æ­¥ç§»åŠ¨`;
                    } else if (result >= 2) {
                        resultText += `ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`;
                    }
                    
                    this.addGameLog(resultText);
                    
                    // æ‰§è¡Œç§»åŠ¨ï¼ˆå¸¦åŠ¨ç”»å’Œç¢°æ’æ£€æµ‹ï¼‰
                    if (stepsToExecute > 0) {
                        await this.executeUnitPlanWithAnimation(unit, plan, stepsToExecute);
                    } else {
                            this.addGameLog(`âŒ ${unit.name}ç§»åŠ¨å¤±è´¥ï¼éª°å­ç»“æœä¸ä½³ï¼Œæ— æ³•ç§»åŠ¨`);
                    }
                    
                    // æ¯ä¸ªå•ä½æ‰§è¡Œå®Œåç¨ä½œåœé¡¿
                    await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
                
                // æ¸…ç©ºæ‰€æœ‰è§„åˆ’ï¼Œé‡ç½®çŠ¶æ€
                this.allUnitPlans.clear();
                this.planningPhase = 'planning';
                this.moveState = 'none';
                this.resetMoveState();
                this.renderBoard();
                // æ¸…é™¤æ‰€æœ‰å ä½é¢„è§ˆ
                this.clearPlannedOccupations();
                
                // è‡ªåŠ¨è¿›å…¥è½¬å‘é˜¶æ®µ
                this.addGameLog(`ğŸ“‹ ç§»åŠ¨é˜¶æ®µæ‰§è¡Œå®Œæ¯•ï¼Œè‡ªåŠ¨è¿›å…¥è½¬å‘é˜¶æ®µ`);
                this.currentPhase = 'turning';
                this.phaseCompleted.movement = true;
                this.addGameLog(`ğŸ”„ ${this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'}è¿›å…¥è½¬å‘é˜¶æ®µï¼Œå³é”®ç‚¹å‡»å•ä½è°ƒæ•´æœå‘`);
                
                this.updateUI();
            }

            showDiceResult(dice1, dice2, leadership, result) {
                // è¿™ä¸ªæ–¹æ³•ç°åœ¨ä¸å†ä½¿ç”¨ï¼Œéª°å­ç»“æœç›´æ¥åœ¨executePlanä¸­å¤„ç†
            }

            hideDiceResult() {
                const diceDiv = document.getElementById('dice-result');
                diceDiv.style.display = 'none';
            }

            getUnitTypeName(unitType) {
                const typeNames = {
                    'legionary': 'å†›å›¢å…µ',
                    'centurion': 'ç™¾å¤«é•¿',
                    'hastati': 'åå¤‡å…µ',
                    'archer': 'å¼“ç®­æ‰‹',
                    'infantry': 'æ­¥å…µ',
                    'elephant': 'æˆ˜è±¡',
                    'cavalry': 'éª‘å…µ',
                    'general': 'å°†é¢†'
                };
                return typeNames[unitType] || unitType;
            }

            showExecutionResult(title, details) {
                // åœ¨æ¸¸æˆæ—¥å¿—ä¸­æ˜¾ç¤ºæ‰§è¡Œç»“æœ
                this.addGameLog(details);
            }

            addGameLog(message) {
                try {
                    const logContent = document.getElementById('game-log-content');
                    if (!logContent) {
                        console.error('æ¸¸æˆæ—¥å¿—å®¹å™¨æœªæ‰¾åˆ°');
                        return;
                    }
                    
                    const timestamp = new Date().toLocaleTimeString();
                    
                    const logEntry = document.createElement('div');
                    logEntry.style.cssText = `
                        margin-bottom: 8px;
                        padding: 5px 8px;
                        background: white;
                        border-radius: 4px;
                        border-left: 3px solid #3498db;
                    `;
                    
                                    logEntry.innerHTML = `
                    <span style="color: #7f8c8d; font-size: 12px;">[${timestamp}]</span>
                    <span style="margin-left: 8px; color: #2c3e50;">${message}</span>
                `;
                    
                    logContent.appendChild(logEntry);
                    
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                    logContent.scrollTop = logContent.scrollHeight;
                    
                    // é™åˆ¶æ—¥å¿—æ¡ç›®æ•°é‡ï¼Œä¿æŒæ€§èƒ½
                    const entries = logContent.children;
                    if (entries.length > 50) {
                        logContent.removeChild(entries[0]);
                    }
                } catch (error) {
                    console.error('æ·»åŠ æ¸¸æˆæ—¥å¿—æ—¶å‡ºé”™:', error);
                }
            }
            
            showCollisionEffect(movingUnit, collidingUnit) {
                // ä¸ºç§»åŠ¨å•ä½æ·»åŠ ç¢°æ’æ•ˆæœ
                if (movingUnit) {
                    const movingUnitElement = document.querySelector(`[data-x="${movingUnit.x}"][data-y="${movingUnit.y}"]`);
                    if (movingUnitElement) {
                        movingUnitElement.classList.add('collision-effect');
                        setTimeout(() => {
                            movingUnitElement.classList.remove('collision-effect');
                        }, 600);
                    }
                }
                
                // ä¸ºè¢«ç¢°æ’å•ä½æ·»åŠ éœ‡åŠ¨æ•ˆæœ
                if (collidingUnit) {
                    const collidingUnitElement = document.querySelector(`[data-x="${collidingUnit.x}"][data-y="${collidingUnit.y}"]`);
                    if (collidingUnitElement) {
                        collidingUnitElement.style.animation = 'shake 0.5s ease-in-out';
                        setTimeout(() => {
                            collidingUnitElement.style.animation = '';
                        }, 500);
                    }
                }
            }
            
            // æ˜¾ç¤ºæ‰€æœ‰å·²è§„åˆ’å•ä½çš„å ä½
            showAllPlannedOccupations() {
                // æ¸…é™¤ç°æœ‰çš„å ä½æ˜¾ç¤º
                this.clearPlannedOccupations();
                
                const container = document.getElementById('square-grid');
                
                // æ˜¾ç¤ºæ‰€æœ‰å·²å®Œæˆè§„åˆ’çš„å•ä½å ä½
                for (const [unitId, planData] of this.allUnitPlans) {
                    const { unit, plan } = planData;
                    const size = this.unitSizes[unit.type];
                    
                    // æ˜¾ç¤ºåˆå§‹ä½ç½®å ä½
                    this.createOccupationElement(container, unit.x, unit.y, size, unit.faction, 0);
                    
                    // æ˜¾ç¤ºè§„åˆ’æ­¥éª¤å ä½
                    plan.forEach((step, stepIndex) => {
                        this.createOccupationElement(container, step.endX, step.endY, size, unit.faction, stepIndex + 1);
                    });
                }
                
                // æ˜¾ç¤ºå½“å‰è§„åˆ’ä¸­å•ä½çš„å ä½
                if (this.selectedUnit && this.movePlan.length > 0) {
                    const size = this.unitSizes[this.selectedUnit.type];
                    
                    // æ˜¾ç¤ºå½“å‰å•ä½çš„åˆå§‹ä½ç½®å ä½
                    this.createOccupationElement(container, this.selectedUnit.x, this.selectedUnit.y, size, this.selectedUnit.faction, 0);
                    
                    // æ˜¾ç¤ºè§„åˆ’æ­¥éª¤å ä½
                    this.movePlan.forEach((step, stepIndex) => {
                        this.createOccupationElement(container, step.endX, step.endY, size, this.selectedUnit.faction, stepIndex + 1);
                    });
                }
            }
            
            // åªæ˜¾ç¤ºå…¶ä»–å·²å®Œæˆè§„åˆ’å•ä½çš„å ä½ï¼ˆä¸åŒ…æ‹¬å½“å‰é€‰ä¸­å•ä½ï¼‰
            showOtherPlannedOccupations() {
                // æ¸…é™¤ç°æœ‰çš„å ä½æ˜¾ç¤º
                this.clearPlannedOccupations();
                
                const container = document.getElementById('square-grid');
                
                // åªæ˜¾ç¤ºå·²å®Œæˆè§„åˆ’çš„å•ä½å ä½
                for (const [unitId, planData] of this.allUnitPlans) {
                    const { unit, plan } = planData;
                    const size = this.unitSizes[unit.type];
                    
                    plan.forEach((step, stepIndex) => {
                        this.createOccupationElement(container, step.endX, step.endY, size, unit.faction, stepIndex + 1);
                    });
                }
            }
            
            // åˆ›å»ºå ä½æ˜¾ç¤ºå…ƒç´ 
            createOccupationElement(container, x, y, size, faction, stepNumber) {
                const occupationDiv = document.createElement('div');
                occupationDiv.className = `planned-occupation ${faction} step-${stepNumber}`;
                occupationDiv.style.left = `${x * 16}px`;
                occupationDiv.style.top = `${y * 16}px`;
                occupationDiv.style.width = `${size.width * 16}px`;
                occupationDiv.style.height = `${size.height * 16}px`;
                occupationDiv.dataset.unitOccupation = 'true';
                occupationDiv.dataset.x = x;
                occupationDiv.dataset.y = y;
                occupationDiv.dataset.width = size.width;
                occupationDiv.dataset.height = size.height;
                occupationDiv.dataset.step = stepNumber;
                
                container.appendChild(occupationDiv);
            }
            
            // æ¸…é™¤æ‰€æœ‰å ä½æ˜¾ç¤º
            clearPlannedOccupations() {
                const occupations = document.querySelectorAll('.planned-occupation');
                occupations.forEach(el => el.remove());
            }
            
            // æ£€æŸ¥è§„åˆ’ä½ç½®æ˜¯å¦ä¸å·²æœ‰å ä½å†²çª
            checkPlannedOccupationConflict(x, y, width, height, excludeUnitId = null) {
                // æ£€æŸ¥ä¸å·²è§„åˆ’å•ä½çš„å†²çª
                for (const [unitId, planData] of this.allUnitPlans) {
                    if (excludeUnitId && unitId === excludeUnitId) continue;
                    
                    const { unit, plan } = planData;
                    const unitSize = this.unitSizes[unit.type];
                    
                    // æ£€æŸ¥ä¸è¯¥å•ä½æ‰€æœ‰è§„åˆ’æ­¥éª¤çš„å†²çª
                    for (const step of plan) {
                        if (this.isAreaOverlap(x, y, width, height, step.endX, step.endY, unitSize.width, unitSize.height)) {
                            return {
                                conflict: true,
                                conflictUnit: unit,
                                conflictPosition: { x: step.endX, y: step.endY }
                            };
                        }
                    }
                }
                
                // æ£€æŸ¥ä¸å½“å‰è§„åˆ’ä¸­å•ä½çš„å†²çªï¼ˆå¦‚æœä¸æ˜¯åŒä¸€å•ä½ï¼‰
                if (this.selectedUnit && this.selectedUnit.id !== excludeUnitId && this.movePlan.length > 0) {
                    const size = this.unitSizes[this.selectedUnit.type];
                    
                    for (const step of this.movePlan) {
                        if (this.isAreaOverlap(x, y, width, height, step.endX, step.endY, size.width, size.height)) {
                            return {
                                conflict: true,
                                conflictUnit: this.selectedUnit,
                                conflictPosition: { x: step.endX, y: step.endY }
                            };
                        }
                    }
                }
                
                return { conflict: false };
            }
            
            // æ£€æŸ¥ä¸¤ä¸ªçŸ©å½¢åŒºåŸŸæ˜¯å¦é‡å 
            isAreaOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
                return !(x1 + w1 <= x2 || x2 + w2 <= x1 || y1 + h1 <= y2 || y2 + h2 <= y1);
            }
            
            // å•æ­¥ç§»åŠ¨åŠ¨ç”» - æ˜¾ç¤ºæ•´ä¸ªå ä½åŒºåŸŸçš„ç§»åŠ¨
            animateUnitMove(unit, targetX, targetY) {
                return new Promise((resolve, reject) => {
                    try {
                        const size = this.unitSizes[unit.type];
                        const container = document.getElementById('square-grid');
                        
                        if (!container) {
                            console.error('æ‰¾ä¸åˆ°æ¸¸æˆå®¹å™¨');
                            unit.x = targetX;
                            unit.y = targetY;
                            resolve();
                            return;
                        }
                        
                        // åˆ›å»ºç§»åŠ¨åŠ¨ç”»å…ƒç´ ï¼Œæ˜¾ç¤ºæ•´ä¸ªå ä½åŒºåŸŸ
                        const animationElement = document.createElement('div');
                        animationElement.className = `unit-large ${unit.faction} unit-moving-animation`;
                        animationElement.style.cssText = `
                            position: absolute;
                            width: ${size.width * 16}px;
                            height: ${size.height * 16}px;
                            left: ${unit.x * 16}px;
                            top: ${unit.y * 16}px;
                            background: ${unit.faction === 'rome' ? 'rgba(231, 76, 60, 0.8)' : 'rgba(52, 152, 219, 0.8)'};
                            border: 3px solid ${unit.faction === 'rome' ? '#c0392b' : '#2980b9'};
                            border-radius: 4px;
                            z-index: 1500;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            color: white;
                            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                            transition: left 0.8s ease-in-out, top 0.8s ease-in-out;
                            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                        `;
                        
                        // æ˜¾ç¤ºå•ä½ç±»å‹å’Œæ–¹å‘
                        try {
                            const unitIcon = this.getUnitIcon(unit);
                            const directionArrow = this.getDirectionArrow(unit.direction);
                            
                            // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡å•ä½
                            const isImageUnit = (unit.faction === 'rome' && (unit.type === 'legionary' || unit.type === 'centurion' || unit.type === 'hastati' || unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general')) || 
                                               (unit.faction === 'carthage' && (unit.type === 'cavalry' || unit.type === 'archer' || unit.type === 'general' || unit.type === 'infantry' || unit.type === 'elephant'));
                            
                            if (isImageUnit) {
                                // å›¾ç‰‡å•ä½ï¼šå›¾æ ‡æ—‹è½¬ï¼Œä¸æ˜¾ç¤ºæ–¹å‘ç®­å¤´
                                const rotationDegrees = {
                                    'north': 0,
                                    'east': 90,
                                    'south': 180,
                                    'west': 270
                                };
                                const rotation = rotationDegrees[unit.direction] || 0;
                                
                                // è·å–å•ä½å°ºå¯¸å¹¶è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                                const unitSize = this.getUnitSizeWithDirection(unit);
                                const baseSize = this.unitBaseSizes[unit.type];
                                const isRotated = (unit.direction === 'east' || unit.direction === 'west');
                                const scaleValue = isRotated ? Math.max(baseSize.width / baseSize.height, baseSize.height / baseSize.width) : 1;
                                
                                animationElement.innerHTML = `
                                    <div style="transform: rotate(${rotation}deg) scale(${scaleValue}); display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">
                                        ${unitIcon}
                                    </div>
                                `;
                            } else {
                                // Emojiå•ä½ï¼šæ˜¾ç¤ºå›¾æ ‡å’Œæ–¹å‘ç®­å¤´
                                animationElement.innerHTML = `
                                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;">
                                        <div style="font-size: 20px;">${unitIcon}</div>
                                        <div style="font-size: 12px; color: #f1c40f;">${directionArrow}</div>
                                    </div>
                                `;
                            }
                        } catch (iconError) {
                            console.warn('è·å–å•ä½å›¾æ ‡å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ˜¾ç¤º:', iconError);
                            animationElement.innerHTML = unit.type.charAt(0).toUpperCase();
                        }
                        
                        container.appendChild(animationElement);
                        
                        // ç¨ä½œå»¶è¿Ÿåå¼€å§‹åŠ¨ç”»
                        setTimeout(() => {
                            try {
                                const newLeft = targetX * 16;
                                const newTop = targetY * 16;
                                
                                animationElement.style.left = `${newLeft}px`;
                                animationElement.style.top = `${newTop}px`;
                                
                                // åŠ¨ç”»å®Œæˆåæ›´æ–°å•ä½ä½ç½®å¹¶ç§»é™¤åŠ¨ç”»å…ƒç´ 
                                setTimeout(() => {
                                    try {
                                        unit.x = targetX;
                                        unit.y = targetY;
                                        if (animationElement.parentNode) {
                                            animationElement.remove();
                                        }
                                        resolve();
                                    } catch (cleanupError) {
                                        console.error('åŠ¨ç”»æ¸…ç†æ—¶å‡ºé”™:', cleanupError);
                                        unit.x = targetX;
                                        unit.y = targetY;
                                        resolve();
                                    }
                                }, 800); // ä¸CSSåŠ¨ç”»æ—¶é—´ä¸€è‡´
                            } catch (animError) {
                                console.error('åŠ¨ç”»æ‰§è¡Œæ—¶å‡ºé”™:', animError);
                                unit.x = targetX;
                                unit.y = targetY;
                                if (animationElement.parentNode) {
                                    animationElement.remove();
                                }
                                resolve();
                            }
                        }, 50);
                    } catch (error) {
                        console.error('åˆ›å»ºåŠ¨ç”»æ—¶å‡ºé”™:', error);
                        unit.x = targetX;
                        unit.y = targetY;
                        resolve();
                    }
                });
            }
            
            // æ‰§è¡Œå•ä¸ªå•ä½çš„ç§»åŠ¨è®¡åˆ’ï¼ˆå¸¦åŠ¨ç”»ï¼‰
            async executeUnitPlanWithAnimation(unit, plan, stepsToExecute) {
                const unitTypeName = this.getUnitTypeName(unit.type);
                let actualStepsExecuted = 0;
                let collisionOccurred = false;
                
                // åœ¨å¼€å§‹ç§»åŠ¨å‰éšè—åŸå§‹å•ä½ï¼ˆé€šè¿‡ä¸´æ—¶æ ‡è®°ï¼‰
                unit.isAnimating = true;
                this.renderBoard(); // é‡æ–°æ¸²æŸ“ä»¥éšè—æ­£åœ¨åŠ¨ç”»çš„å•ä½
                
                for (let i = 0; i < stepsToExecute; i++) {
                    const step = plan[i];
                    const size = this.unitSizes[unit.type];
                    
                    // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦è¢«å…¶ä»–å•ä½å ç”¨ï¼ˆå®æ—¶æ£€æµ‹ï¼‰
                    if (this.isAreaOccupiedByOthers(step.endX, step.endY, size.width, size.height, unit.id)) {
                        // æ‰¾åˆ°ç¢°æ’çš„å•ä½
                        const collidingUnit = this.findUnitAtPosition(step.endX, step.endY, unit.id);
                        const collidingUnitName = collidingUnit ? this.getUnitTypeName(collidingUnit.type) : 'å…¶ä»–å•ä½';
                        this.addGameLog(`ğŸš« ${unitTypeName}ç¬¬${i + 1}æ­¥ç§»åŠ¨å—é˜»ï¼Œä¸${collidingUnitName}å‘ç”Ÿç¢°æ’`);
                        
                        // æ˜¾ç¤ºç¢°æ’æ•ˆæœ
                        this.showCollisionEffect(unit, collidingUnit);
                        
                        collisionOccurred = true;
                        break;
                    }
                    
                    // æ‰§è¡Œå¸¦åŠ¨ç”»çš„ç§»åŠ¨
                    try {
                        await this.animateUnitMove(unit, step.endX, step.endY);
                        actualStepsExecuted++;
                        console.log(`${unitTypeName}æ‰§è¡Œç¬¬${i + 1}æ­¥: ç§»åŠ¨åˆ° (${step.endX}, ${step.endY})`);
                    } catch (error) {
                        console.error(`${unitTypeName}ç¬¬${i + 1}æ­¥ç§»åŠ¨åŠ¨ç”»å‡ºé”™:`, error);
                        // å³ä½¿åŠ¨ç”»å¤±è´¥ï¼Œä¹Ÿè¦æ›´æ–°å•ä½ä½ç½®
                        unit.x = step.endX;
                        unit.y = step.endY;
                        actualStepsExecuted++;
                    }
                }
                
                // åŠ¨ç”»å®Œæˆï¼Œç§»é™¤åŠ¨ç”»æ ‡è®°
                unit.isAnimating = false;
                unit.hasMoved = true;
                
                // æ ¹æ®å®é™…æ‰§è¡Œæƒ…å†µæ˜¾ç¤ºç»“æœ
                if (collisionOccurred) {
                    if (actualStepsExecuted > 0) {
                        this.addGameLog(`âš¡ ${unitTypeName}ç§»åŠ¨éƒ¨åˆ†æˆåŠŸï¼è§„åˆ’${plan.length}æ­¥ï¼Œå› ç¢°æ’å®é™…æ‰§è¡Œ${actualStepsExecuted}æ­¥`);
                    } else {
                        this.addGameLog(`âŒ ${unitTypeName}ç§»åŠ¨å¤±è´¥ï¼ç¬¬1æ­¥å°±é‡åˆ°ç¢°æ’ï¼Œæ— æ³•ç§»åŠ¨`);
                    }
                } else if (actualStepsExecuted === plan.length) {
                    this.addGameLog(`âœ… ${unitTypeName}ç§»åŠ¨æˆåŠŸï¼æ‰§è¡Œäº†å…¨éƒ¨${plan.length}æ­¥è§„åˆ’`);
                } else {
                    this.addGameLog(`âš¡ ${unitTypeName}ç§»åŠ¨éƒ¨åˆ†æˆåŠŸï¼è§„åˆ’${plan.length}æ­¥ï¼Œå®é™…æ‰§è¡Œ${actualStepsExecuted}æ­¥`);
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å•ä½å› ç§»åŠ¨è„±ç¦»è¿‘æˆ˜
                this.checkAndDisengageUnits();
            }

            updateUI() {
                console.log(`æ›´æ–°UI: å½“å‰ç©å®¶=${this.currentPlayer}, å½“å‰é˜¶æ®µ=${this.currentPhase}, ç§»åŠ¨çŠ¶æ€=${this.moveState}`);
                
                const playerText = document.getElementById('current-player-text');
                playerText.textContent = this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                playerText.className = this.currentPlayer;

                // æ›´æ–°é˜¶æ®µæ˜¾ç¤º
                const phaseText = document.getElementById('current-phase-text');
                const phaseNames = {
                    'deployment': 'ğŸ“¦ éƒ¨ç½²é˜¶æ®µ',
                    'movement': 'ğŸš¶ è§„åˆ’å’Œç§»åŠ¨',
                    'turning': 'ğŸ”„ è½¬å‘è°ƒæ•´',
                    'ranged': 'ğŸ¹ è¿œç¨‹å°„å‡»', 
                    'melee': 'âš”ï¸ è¿‘æˆ˜æ”»å‡»'
                };
                
                if (this.currentPhase === 'deployment') {
                    const deploymentPlayerName = this.deploymentPhase === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                    phaseText.textContent = `é˜¶æ®µ: ${phaseNames[this.currentPhase]} - ${deploymentPlayerName}éƒ¨ç½²ä¸­`;
                } else {
                    phaseText.textContent = `é˜¶æ®µ: ${phaseNames[this.currentPhase]}`;
                }

                // æ›´æ–°å³ä¾§æ çš„å›åˆå’Œé˜¶æ®µä¿¡æ¯
                const sidebarPlayerText = document.getElementById('sidebar-player-text');
                if (sidebarPlayerText) {
                    sidebarPlayerText.textContent = this.currentPlayer === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                    sidebarPlayerText.className = this.currentPlayer;
                }
                
                const sidebarPhaseText = document.getElementById('sidebar-phase-text');
                if (sidebarPhaseText) {
                    if (this.currentPhase === 'deployment') {
                        const deploymentPlayerName = this.deploymentPhase === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                        sidebarPhaseText.textContent = `${phaseNames[this.currentPhase]} - ${deploymentPlayerName}éƒ¨ç½²ä¸­`;
                    } else {
                        sidebarPhaseText.textContent = phaseNames[this.currentPhase] || this.currentPhase;
                    }
                }

                // æ›´æ–°é˜µè¥ç»Ÿè®¡ï¼ˆç»Ÿè®¡åˆ†å€¼è€Œéæ•°é‡ï¼‰
                const romeValue = this.calculateFactionPoints('rome');
                const carthageValue = this.calculateFactionPoints('carthage');
                
                // æ˜¾ç¤ºæ ¼å¼ï¼šå½“å‰åˆ†å€¼/åˆå§‹æ€»åˆ†å€¼ (ç™¾åˆ†æ¯”)
                let romeText, carthageText;
                if (this.initialPoints) {
                    const romePercentage = ((romeValue / this.initialPoints.rome) * 100).toFixed(1);
                    const carthagePercentage = ((carthageValue / this.initialPoints.carthage) * 100).toFixed(1);
                    romeText = `${romeValue}/${this.initialPoints.rome} (${romePercentage}%)`;
                    carthageText = `${carthageValue}/${this.initialPoints.carthage} (${carthagePercentage}%)`;
                } else {
                    romeText = `${romeValue}`;
                    carthageText = `${carthageValue}`;
                }
                
                document.getElementById('rome-count').textContent = romeText;
                document.getElementById('carthage-count').textContent = carthageText;
                
                // æ›´æ–°åº•éƒ¨ç»Ÿè®¡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                const romeCountBottom = document.getElementById('rome-count-bottom');
                const carthageCountBottom = document.getElementById('carthage-count-bottom');
                if (romeCountBottom) romeCountBottom.textContent = romeText;
                if (carthageCountBottom) carthageCountBottom.textContent = carthageText;

                // æ›´æ–°é€‰ä¸­å•ä½ä¿¡æ¯
                const infoDiv = document.getElementById('selected-unit-info');
                                            if (this.selectedUnit) {
                    const unit = this.selectedUnit;
                    const hpPercentage = (unit.hp / unit.maxHp) * 100;
                    let hpColor = '#2ecc71';
                    if (hpPercentage < 70) hpColor = '#f39c12';
                    if (hpPercentage < 40) hpColor = '#e74c3c';
                    
                    const typeNames = {
                        'legionary': 'å†›å›¢å…µ',
                        'centurion': 'ç™¾å¤«é•¿',
                        'archer': 'å¼“ç®­æ‰‹',
                        'infantry': 'æ­¥å…µ',
                        'elephant': 'æˆ˜è±¡',
                        'cavalry': 'éª‘å…µ',
                        'general': 'å°†é¢†'
                    };

                    let statusInfo = '';
                    if (this.moveState === 'unit_selected') {
                        statusInfo = '<div style="color: #f39c12;">ğŸ“ å·²é€‰æ‹©å•ä½ï¼Œç‚¹å‡»ç©ºåœ°å¼€å§‹è§„åˆ’ç§»åŠ¨</div>';
                    } else if (this.moveState === 'planning') {
                        statusInfo = `<div style="color: #9b59b6;">ğŸ¯ ç§»åŠ¨è§„åˆ’ä¸­ (${this.movePlan.length}/3æ­¥)ï¼Œç‚¹å‡»ä½ç½®æ·»åŠ æ­¥éª¤</div>`;
                    } else if (this.moveState === 'ready_to_execute') {
                        statusInfo = '<div style="color: #27ae60;">âœ… è§„åˆ’å®Œæˆï¼Œç‚¹å‡»æ‰§è¡ŒæŒ‰é’®æŠ•æ·éª°å­</div>';
                    } else if (this.moveState === 'target_selected') {
                        const action = this.targetPosition.action === 'move' ? 'ç§»åŠ¨' : 'æ”»å‡»';
                        statusInfo = `<div style="color: #e74c3c;">ğŸ¯ å·²é€‰æ‹©${action}ç›®æ ‡ï¼Œç‚¹å‡»ç¡®å®šæŒ‰é’®æ‰§è¡Œ</div>`;
                    }
                    
                    // æ˜¾ç¤ºå·²è§„åˆ’çš„å•ä½æ•°é‡
                    if (this.allUnitPlans.size > 0) {
                        statusInfo += `<div style="color: #3498db; margin-top: 5px;">ğŸ“‹ å·²è§„åˆ’${this.allUnitPlans.size}ä¸ªå•ä½</div>`;
                    }
                    
                    infoDiv.innerHTML = `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-items: center;">
                            <div>
                                <div style="font-size: 18px; margin-bottom: 8px;">
                                    <strong>${unit.name}</strong> (${unit.faction === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº'})
                                </div>
                                <div style="margin-bottom: 5px;">
                                    <span style="color: ${hpColor};">â¤ï¸ HP: ${unit.hp}/${unit.maxHp}</span>
                                </div>
                                <div style="margin-bottom: 5px; font-size: 12px;">
                                    ğŸ§  å£«æ°”: <span style="color: ${unit.morale === 'good' ? '#2ecc71' : '#e74c3c'};">${unit.morale === 'good' ? 'è‰¯å¥½' : 'åŠ¨æ‘‡'}</span> | 
                                    ğŸ“‹ ç§©åº: <span style="color: ${unit.order === 'good' ? '#2ecc71' : '#e74c3c'};">${unit.order === 'good' ? 'è‰¯å¥½' : 'æ··ä¹±'}</span> | 
                                    âš”ï¸ æˆ˜æ–—: <span style="color: ${unit.combatStatus === 'engaged' ? '#e74c3c' : unit.combatStatus === 'supporting' ? '#f39c12' : '#95a5a6'};">${unit.combatStatus === 'engaged' ? 'è¿‘æˆ˜ä¸­' : unit.combatStatus === 'supporting' ? 'æ”¯æ´ä¸­' : 'æœªè¿‘æˆ˜'}</span>
                                </div>
                                <div style="font-size: 12px; line-height: 1.3;">
                                    âš”ï¸ å†²é”‹: ${unit.chargeAttack} | æŒç»­: ${unit.sustainedMelee} | æ”¯æ´: ${unit.supportMelee}<br>
                                    ğŸ¹ æŠ•æ·: ${unit.throwingAttack} | å°„å‡»: ${unit.rangedAttack} | ğŸ›¡ï¸ é˜²å¾¡: ${unit.defense}<br>
                                    ğŸ’ª æ‰¿å—åŠ›: ${unit.casualtyTolerance} | ğŸ¯ å°„ç¨‹: ${unit.range}
                                </div>
                            </div>
                            <div>
                                <div style="margin-bottom: 5px;">ğŸƒ ç§»åŠ¨: ${unit.movement}</div>
                                ${unit.leadership > 0 ? `<div style="margin-bottom: 5px; color: #f1c40f;">ğŸ‘‘ é¢†å¯¼åŠ›: ${unit.leadership}</div>` : ''}
                                <div style="margin-bottom: 5px; color: #9b59b6; font-weight: bold;">ğŸ’ åˆ†å€¼: ${unit.value || 0}</div>
                                <div style="margin-bottom: 5px; font-size: 13px; color: #3498db; font-weight: bold;">
                                    ${{
                                        'north': 'â¬†ï¸ æœå‘: åŒ—æ–¹',
                                        'east': 'â¡ï¸ æœå‘: ä¸œæ–¹',
                                        'south': 'â¬‡ï¸ æœå‘: å—æ–¹',
                                        'west': 'â¬…ï¸ æœå‘: è¥¿æ–¹'
                                    }[unit.direction] || 'ğŸ§­ æœå‘: æœªçŸ¥'}
                                </div>
                                <div style="font-size: 11px; line-height: 1.2;">
                                <div style="color: ${unit.hasMoved ? '#e74c3c' : '#2ecc71'};">
                                        ğŸš¶ ç§»åŠ¨: ${unit.hasMoved ? 'å·²å®Œæˆ' : 'å¯æ‰§è¡Œ'}
                                    </div>
                                    <div style="color: ${unit.hasRangedAttacked ? '#e74c3c' : '#2ecc71'};">
                                        ğŸ¹ å°„å‡»: ${unit.hasRangedAttacked ? 'å·²å®Œæˆ' : 'å¯æ‰§è¡Œ'}
                                    </div>
                                    <div style="color: ${unit.hasMeleeAttacked ? '#e74c3c' : '#2ecc71'};">
                                        âš”ï¸ è¿‘æˆ˜: ${unit.hasMeleeAttacked ? 'å·²å®Œæˆ' : 'å¯æ‰§è¡Œ'}
                                    </div>
                                </div>
                                <div style="margin-bottom: 5px; font-size: 11px; color: #3498db;">
                                    ç‰¹æ®ŠæŠ€èƒ½: ${unit.specialSkills.join(', ')}
                                </div>
                                <div style="margin-top: 8px; font-size: 12px; opacity: 0.8;">
                                    ğŸ“ åæ ‡: (${unit.x}, ${unit.y})
                                </div>
                            </div>
                        </div>
                        ${statusInfo}
                    `;
                } else {
                    let stateInfo = '';
                    if (this.currentPhase === 'deployment') {
                        const currentDeploymentPlayer = this.deploymentPhase === 'rome' ? 'ğŸ›ï¸ ç½—é©¬' : 'ğŸŒŠ è¿¦å¤ªåŸº';
                        stateInfo = `ğŸ“¦ ${currentDeploymentPlayer}éƒ¨ç½²ä¸­ - æ‹–æ‹½å•ä½è°ƒæ•´ä½ç½®ï¼Œå®Œæˆåç‚¹å‡»"ç¡®è®¤éƒ¨ç½²"æŒ‰é’®`;
                    } else if (this.planningPhase === 'executing') {
                        switch (this.moveState) {
                            case 'all_planned':
                                stateInfo = 'ğŸ² æ‰€æœ‰è§„åˆ’å®Œæˆï¼Œç‚¹å‡»ç»Ÿä¸€æ‰§è¡ŒæŒ‰é’®';
                                break;
                        }
                    } else {
                        switch (this.moveState) {
                            case 'none':
                                if (this.allUnitPlans.size > 0) {
                                    stateInfo = `ğŸ¯ ç»§ç»­è§„åˆ’å…¶ä»–å•ä½ï¼Œæˆ–ç‚¹å‡»å®Œæˆæ‰€æœ‰è§„åˆ’ (å·²è§„åˆ’${this.allUnitPlans.size}ä¸ª)`;
                                } else {
                                    stateInfo = 'ğŸ¯ é€‰æ‹©ä¸€ä¸ªå·±æ–¹å•ä½å¼€å§‹è§„åˆ’ç§»åŠ¨';
                                }
                                break;
                            case 'unit_selected':
                                stateInfo = 'ğŸ“ ç‚¹å‡»ç©ºåœ°å¼€å§‹è§„åˆ’ç§»åŠ¨ï¼Œæˆ–ç‚¹å‡»æ•Œæ–¹å•ä½æ”»å‡»';
                                break;
                            case 'planning':
                                stateInfo = `ğŸ—ºï¸ ç§»åŠ¨è§„åˆ’ä¸­ (${this.movePlan.length}/3æ­¥)`;
                                break;
                            case 'ready_to_execute':
                                stateInfo = 'ğŸ² ç‚¹å‡»æ‰§è¡ŒæŒ‰é’®æŠ•æ·éª°å­å†³å®šç§»åŠ¨ç»“æœ';
                                break;
                            case 'target_selected':
                                stateInfo = this.currentPhase === 'ranged' ? 'ğŸ¹ ç‚¹å‡»ç¡®è®¤å°„å‡»æŒ‰é’®æ‰§è¡Œå°„å‡»' : 'âš”ï¸ ç‚¹å‡»ç¡®å®šæŒ‰é’®æ‰§è¡Œæ”»å‡»';
                                break;
                        }
                    }
                    
                    infoDiv.innerHTML = `
                        <div style="text-align: center; opacity: 0.7;">
                            ${stateInfo}
                        </div>
                    `;
                }
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                this.updateMoveButtons();
            }

            // è®¡ç®—é˜µè¥å½“å‰åˆ†å€¼
            calculateFactionPoints(faction) {
                let totalPoints = 0;
                this.units.forEach(unit => {
                    if (unit.faction === faction && unit.hp > 0) {
                        const unitType = unit.type;
                        const points = this.unitValues[unitType] || 0;
                        totalPoints += points;
                    }
                });
                return totalPoints;
            }
            
            checkGameEnd() {
                // è®¡ç®—å½“å‰å‰©ä½™åˆ†å€¼
                const romeCurrentPoints = this.calculateFactionPoints('rome');
                const carthageCurrentPoints = this.calculateFactionPoints('carthage');
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åˆå§‹åˆ†å€¼ï¼ˆæ¸¸æˆåˆšå¼€å§‹æ—¶å¯èƒ½è¿˜æ²¡æœ‰ï¼‰
                if (!this.initialPoints) {
                    return;
                }
                
                // è®¡ç®—åˆ†å€¼æ¯”ä¾‹
                const romePercentage = (romeCurrentPoints / this.initialPoints.rome) * 100;
                const carthagePercentage = (carthageCurrentPoints / this.initialPoints.carthage) * 100;
                
                console.log(`[èƒœè´Ÿåˆ¤å®š] ç½—é©¬: ${romeCurrentPoints}/${this.initialPoints.rome} (${romePercentage.toFixed(1)}%)`);
                console.log(`[èƒœè´Ÿåˆ¤å®š] è¿¦å¤ªåŸº: ${carthageCurrentPoints}/${this.initialPoints.carthage} (${carthagePercentage.toFixed(1)}%)`);
                
                // æ£€æŸ¥èƒœè´Ÿæ¡ä»¶ï¼šå‰©ä½™åˆ†å€¼ä½äºåˆå§‹æ€»åˆ†å€¼çš„65%åˆ™æˆ˜è´¥
                if (romePercentage < 65) {
                    this.addGameLog(`\nğŸ† æ¸¸æˆç»“æŸï¼è¿¦å¤ªåŸºè·èƒœï¼`);
                    this.addGameLog(`ğŸ“Š ç½—é©¬å‰©ä½™åˆ†å€¼: ${romeCurrentPoints}/${this.initialPoints.rome} (${romePercentage.toFixed(1)}%)`);
                    this.addGameLog(`ğŸ“Š è¿¦å¤ªåŸºå‰©ä½™åˆ†å€¼: ${carthageCurrentPoints}/${this.initialPoints.carthage} (${carthagePercentage.toFixed(1)}%)`);
                    
                    setTimeout(() => {
                        this.showVictoryModal('carthage', romeCurrentPoints, carthageCurrentPoints, romePercentage, carthagePercentage);
                    }, 1000);
                } else if (carthagePercentage < 65) {
                    this.addGameLog(`\nğŸ† æ¸¸æˆç»“æŸï¼ç½—é©¬è·èƒœï¼`);
                    this.addGameLog(`ğŸ“Š ç½—é©¬å‰©ä½™åˆ†å€¼: ${romeCurrentPoints}/${this.initialPoints.rome} (${romePercentage.toFixed(1)}%)`);
                    this.addGameLog(`ğŸ“Š è¿¦å¤ªåŸºå‰©ä½™åˆ†å€¼: ${carthageCurrentPoints}/${this.initialPoints.carthage} (${carthagePercentage.toFixed(1)}%)`);
                    
                    setTimeout(() => {
                        this.showVictoryModal('rome', romeCurrentPoints, carthageCurrentPoints, romePercentage, carthagePercentage);
                    }, 1000);
                }
            }
            
            // æ˜¾ç¤ºèƒœåˆ©å¼¹çª—
            showVictoryModal(winner, romePoints, carthagePoints, romePercentage, carthagePercentage) {
                const modal = document.getElementById('victory-modal');
                const icon = document.getElementById('victory-icon');
                const title = document.getElementById('victory-title');
                const romeScore = document.getElementById('rome-final-score');
                const carthageScore = document.getElementById('carthage-final-score');
                const message = document.getElementById('victory-message');
                
                // è®¾ç½®èƒœåˆ©æ–¹çš„å›¾æ ‡å’Œæ ‡é¢˜
                if (winner === 'rome') {
                    icon.textContent = 'ğŸ›ï¸';
                    title.textContent = 'ç½—é©¬è·èƒœï¼';
                } else {
                    icon.textContent = 'ğŸŒŠ';
                    title.textContent = 'è¿¦å¤ªåŸºè·èƒœï¼';
                }
                
                // è®¾ç½®åŒæ–¹åˆ†æ•°
                romeScore.textContent = `${romePoints}/${this.initialPoints.rome} (${romePercentage.toFixed(1)}%)`;
                carthageScore.textContent = `${carthagePoints}/${this.initialPoints.carthage} (${carthagePercentage.toFixed(1)}%)`;
                
                // è®¾ç½®èƒœåˆ©ä¿¡æ¯
                const loserName = winner === 'rome' ? 'è¿¦å¤ªåŸº' : 'ç½—é©¬';
                message.innerHTML = `${loserName}çš„å‰©ä½™éƒ¨é˜Ÿåˆ†å€¼å·²ä½äºåˆå§‹æ€»åˆ†å€¼çš„65%ï¼Œ<br>æˆ˜æ–—ä»¥${winner === 'rome' ? 'ç½—é©¬' : 'è¿¦å¤ªåŸº'}çš„èƒœåˆ©å‘Šç»ˆï¼`;
                
                // æ˜¾ç¤ºå¼¹çª—
                modal.classList.add('show');
                
                // ç»‘å®šé‡æ–°å¼€å§‹æŒ‰é’®
                const restartBtn = document.getElementById('victory-restart-btn');
                restartBtn.onclick = () => {
                    modal.classList.remove('show');
                    this.resetGame();
                };
            }

            // åˆ¤æ–­ä¸¤ä¸ªå•ä½æ˜¯å¦æ¥è§¦ï¼ˆç›¸é‚»ï¼‰
            areUnitsAdjacent(unit1, unit2) {
                const size1 = this.getUnitSizeWithDirection(unit1);
                const size2 = this.getUnitSizeWithDirection(unit2);
                
                // æ£€æŸ¥æ‰€æœ‰ç»„åˆçš„æ ¼å­ï¼Œçœ‹æ˜¯å¦æœ‰ç›¸é‚»çš„
                for (let y1 = unit1.y; y1 < unit1.y + size1.height; y1++) {
                    for (let x1 = unit1.x; x1 < unit1.x + size1.width; x1++) {
                        for (let y2 = unit2.y; y2 < unit2.y + size2.height; y2++) {
                            for (let x2 = unit2.x; x2 < unit2.x + size2.width; x2++) {
                                // æ£€æŸ¥8ä¸ªæ–¹å‘æ˜¯å¦ç›¸é‚»
                                const dx = Math.abs(x1 - x2);
                                const dy = Math.abs(y1 - y2);
                                if ((dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            // è·å–ä¸å•ä½æ¥è§¦çš„æ•Œæ–¹å•ä½åˆ—è¡¨
            getAdjacentEnemyUnits(unit) {
                return this.units.filter(u => 
                    u.faction !== unit.faction && 
                    // HPä¸º0çš„å•ä½ï¼ˆåŠ¨æ‘‡çŠ¶æ€ï¼‰ä»ç„¶å¯ä»¥åœ¨è¿‘æˆ˜ä¸­è¢«æ”»å‡»
                    this.areUnitsAdjacent(unit, u)
                );
            }

            // è·å–è·ç¦»å•ä½æŒ‡å®šèŒƒå›´å†…çš„å‹æ–¹å•ä½
            getUnitsInRange(unit, range, sameFaction = true) {
                const centerX = unit.x + Math.floor(this.getUnitSizeWithDirection(unit).width / 2);
                const centerY = unit.y + Math.floor(this.getUnitSizeWithDirection(unit).height / 2);
                
                return this.units.filter(u => {
                    if (u.id === unit.id) return false;
                    // HPä¸º0çš„å•ä½ï¼ˆåŠ¨æ‘‡çŠ¶æ€ï¼‰ä»ç„¶å¯ä»¥å‚ä¸æˆ˜æ–—å’Œæ”¯æ´
                    if (sameFaction && u.faction !== unit.faction) return false;
                    if (!sameFaction && u.faction === unit.faction) return false;
                    
                    const targetCenterX = u.x + Math.floor(this.getUnitSizeWithDirection(u).width / 2);
                    const targetCenterY = u.y + Math.floor(this.getUnitSizeWithDirection(u).height / 2);
                    
                    const distance = this.getDistance(centerX, centerY, targetCenterX, targetCenterY);
                    return distance <= range;
                });
            }

            // è·å–å¯ä½œä¸ºæ”¯æ´çš„å•ä½
            getAvailableSupportUnits(targetUnit, range = 3) {
                return this.getUnitsInRange(targetUnit, range, true).filter(u => 
                    u.combatStatus === 'not_engaged' && 
                    !u.hasMeleeAttacked &&
                    u.id !== targetUnit.id && // æ’é™¤ç›®æ ‡å•ä½æœ¬èº«
                    u.id !== this.meleeAttacker?.id && // æ’é™¤å†²é”‹å•ä½
                    u.id !== this.meleeTarget?.id // æ’é™¤è¢«æ”»å‡»å•ä½
                );
            }
        }

        // å¯åŠ¨æ¸¸æˆ
        const game = new HexGame();
        
        // æ·»åŠ å…¨å±€é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            console.error('JavaScripté”™è¯¯:', e.error);
        });
    </script>
</body>
</html> 
</html> 